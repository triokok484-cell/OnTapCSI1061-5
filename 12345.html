<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSI FPTU - Công cụ Ôn tập Nâng cao</title>
    <style>
        :root {
            --fpt-blue: #0055a5;
            --fpt-orange: #f26f21;
            --info-blue: #007bff;
            --text-color: #333;
            --bg-color: #f8f9fa;
            --container-bg: #ffffff;
            --highlight-bg: #fff3cd;
            --highlight-text: #856404;
            --correct-bg: #d4edda;
            --correct-border: #c3e6cb;
            --incorrect-bg: #f8d7da;
            --incorrect-border: #f5c6cb;
            --explanation-bg: #e2e3e5;
        }
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            line-height: 1.7;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        .container {
            max-width: 960px;
            margin: auto;
            background: var(--container-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        header {
            text-align: center;
            border-bottom: 3px solid var(--fpt-blue);
            padding-bottom: 15px;
            margin-bottom: 25px;
        }
        header h1 {
            color: var(--fpt-blue);
            margin: 0 0 5px 0;
        }
        .lang-switcher {
            margin-top: 15px;
        }
        .lang-switcher button {
            padding: 6px 12px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            cursor: pointer;
            margin: 0 5px;
            border-radius: 5px;
            font-size: 14px;
        }
        .lang-switcher button.active {
            background-color: var(--fpt-blue);
            color: white;
            border-color: var(--fpt-blue);
        }
        .tab-nav {
            display: flex;
            margin-bottom: 25px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .tab-link {
            flex: 1;
            padding: 15px;
            cursor: pointer;
            border: none;
            background-color: #e9ecef;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.3s, color 0.3s;
            text-align: center;
        }
        .tab-link.active {
            background-color: var(--fpt-orange);
            color: white;
        }
        .tab-link:hover:not(.active) {
            background-color: #dee2e6;
        }
        .tab-pane { display: none; }
        .tab-pane.active { display: block; }
        
        .theory-content h2 { color: var(--fpt-blue); border-bottom: 2px solid var(--fpt-orange); padding-bottom: 5px; }
        .theory-content h3 { color: #333; margin-top: 25px; }
        .theory-content h4 { color: #555; margin-top: 20px; }
        .theory-content ul { list-style-type: none; padding-left: 0; }
        .theory-content li { background: #f8f9fa; margin-bottom: 10px; padding: 15px; border-left: 4px solid var(--fpt-blue); border-radius: 5px; }
        .theory-content ul ul { margin-top: 10px; }
        .theory-content li li { background: #e9ecef; border-left-color: var(--fpt-orange); }
        .theory-content code, .theory-content pre {
            font-family: Consolas, 'Courier New', monospace;
            background-color: #e9ecef;
            padding: 2px 5px;
            border-radius: 4px;
        }
        .theory-content pre {
            padding: 15px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            border-left: 4px solid #ccc;
        }

        .highlight {
            background-color: var(--highlight-bg);
            padding: 3px 6px;
            border-radius: 4px;
            font-weight: bold;
            color: var(--highlight-text);
        }
        .quiz-view, .quiz-setup, .quiz-results { display: none; }
        .quiz-container, .quiz-setup, .quiz-results {
            border: 1px solid #dee2e6;
            padding: 25px;
            margin-top: 25px;
            border-radius: 8px;
            background-color: #fafafa;
        }
        .quiz-question {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .quiz-options button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 14px;
            margin: 8px 0;
            border: 1px solid #ccc;
            background-color: var(--container-bg);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            font-size: 16px;
        }
        .quiz-options button:hover:not([disabled]) {
            background-color: #e9e9e9;
            border-color: #aaa;
        }
        .quiz-options button.correct {
            background-color: var(--correct-bg);
            border-color: var(--correct-border);
            font-weight: bold;
        }
        .quiz-options button.incorrect {
            background-color: var(--incorrect-bg);
            border-color: var(--incorrect-border);
        }
        .explanation-box {
            margin-top: 15px;
            padding: 15px;
            background-color: var(--explanation-bg);
            border-radius: 6px;
            border: 1px solid #ced4da;
        }
        .button-group button, .quiz-setup button, .quiz-results button, .quiz-setup input {
            padding: 12px 22px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 6px;
            margin: 10px 5px 10px 0;
            border: none;
            font-weight: 500;
        }
        .quiz-setup input {
            width: 80px;
            border: 1px solid #ccc;
            border-radius: 6px;
            text-align: center;
        }
        .primary-button { background-color: var(--fpt-blue); color: white; }
        .secondary-button { background-color: #6c757d; color: white; }
        .info-button { background-color: var(--info-blue); color: white; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 data-lang-key="title">CSI FPTU - Công cụ Ôn tập Nâng cao</h1>
            <p data-lang-key="subtitle">Chọn chương để học lý thuyết hoặc làm bài tập trắc nghiệm.</p>
            <div class="lang-switcher">
                <button onclick="switchLanguage('vi')" class="active" data-lang-key="vietnamese">Tiếng Việt</button>
                <button onclick="switchLanguage('en')" data-lang-key="english">English</button>
            </div>
        </header>

        <div class="tab-nav">
            <button class="tab-link active" onclick="switchTab('chapter1')" data-lang-key="ch1">Chương 1</button>
            <button class="tab-link" onclick="switchTab('chapter2')" data-lang-key="ch2">Chương 2</button>
            <button class="tab-link" onclick="switchTab('chapter3')" data-lang-key="ch3">Chương 3</button>
            <button class="tab-link" onclick="switchTab('chapter4')" data-lang-key="ch4">Chương 4</button>
            <button class="tab-link" onclick="switchTab('chapter5')" data-lang-key="ch5">Chương 5</button>
        </div>

        <div class="tab-content">
            <!-- Content will be generated by JavaScript -->
        </div>
    </div>

    <script>
        // --- START: NGÂN HÀNG CÂU HỎI VÀ LÝ THUYẾT ---
        const contentData = {
            chapter1: {
                theory: {
                    vi: `
                        <h2>Chương 1: Giới thiệu Tổng quan</h2>
                        <h3>1. Các mô hình máy tính cơ bản</h3>
                        <ul>
                            <li>
                                <strong>Mô hình Turing (Turing Model):</strong>
                                <ul>
                                    <li>Định nghĩa máy tính như một <span class="highlight">bộ xử lý dữ liệu có thể lập trình được (programmable data processor)</span>.</li>
                                    <li>Đây là một mô hình lý thuyết, toán học, không phải kiến trúc vật lý.</li>
                                    <li>Công thức cốt lõi: <strong>Dữ liệu đầu vào + Chương trình -> Máy tính -> Dữ liệu đầu ra</strong>.</li>
                                    <li>Ý nghĩa: Cùng một dữ liệu đầu vào, nếu thay đổi chương trình, ta sẽ có kết quả đầu ra khác nhau. Điều này định nghĩa nên một máy tính đa năng (general-purpose).</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Mô hình von Neumann (von Neumann Model):</strong>
                                <ul>
                                    <li>Mô hình kiến trúc cho hầu hết các máy tính hiện đại.</li>
                                    <li><span class="highlight">Khái niệm đột phá: Chương trình được lưu trong bộ nhớ (Stored Program Concept)</span>. Cả chương trình (tập lệnh) và dữ liệu đều được lưu trữ trong cùng một bộ nhớ và có cùng định dạng (nhị phân).</li>
                                    <li>Kiến trúc bao gồm 4 hệ thống con (subsystems):
                                        <ol>
                                            <li><strong>Bộ nhớ (Memory):</strong> Lưu trữ chương trình và dữ liệu.</li>
                                            <li><strong>Đơn vị Số học & Logic (Arithmetic Logic Unit - ALU):</strong> Thực hiện các phép tính và so sánh logic.</li>
                                            <li><strong>Đơn vị Điều khiển (Control Unit):</strong> Điều phối hoạt động của tất cả các thành phần khác.</li>
                                            <li><strong>Hệ thống Vào/Ra (Input/Output Subsystem):</strong> Giao tiếp với thế giới bên ngoài (bàn phím, màn hình, ổ cứng...).</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Ba thành phần của máy tính</h3>
                        <ul>
                            <li><strong>Phần cứng (Hardware):</strong> Các thành phần vật lý của máy tính (CPU, RAM, ổ đĩa, ...).</li>
                            <li><strong>Dữ liệu (Data):</strong> Các thông tin thô (số, văn bản, hình ảnh) được máy tính xử lý. Dữ liệu được biểu diễn dưới dạng nhị phân.</li>
                            <li><strong>Phần mềm (Software):</strong> Tập hợp các chương trình (tập lệnh) hướng dẫn phần cứng phải làm gì. Phần mềm là cầu nối giữa người dùng và phần cứng.</li>
                        </ul>
                    `,
                    en: `
                        <h2>Chapter 1: Introduction</h2>
                        <h3>1. Basic Computer Models</h3>
                        <ul>
                            <li>
                                <strong>Turing Model:</strong>
                                <ul>
                                    <li>Defines a computer as a <span class="highlight">programmable data processor</span>.</li>
                                    <li>This is a theoretical, mathematical model, not a physical architecture.</li>
                                    <li>Core formula: <strong>Input Data + Program -> Computer -> Output Data</strong>.</li>
                                    <li>Significance: With the same input data, changing the program yields a different output. This defines a general-purpose computer.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>von Neumann Model:</strong>
                                <ul>
                                    <li>The architectural model for most modern computers.</li>
                                    <li><span class="highlight">Breakthrough concept: The Stored Program Concept</span>. Both the program (instructions) and data are stored in the same memory and share the same format (binary).</li>
                                    <li>The architecture consists of four subsystems:
                                        <ol>
                                            <li><strong>Memory:</strong> Stores programs and data.</li>
                                            <li><strong>Arithmetic Logic Unit (ALU):</strong> Performs calculations and logical comparisons.</li>
                                            <li><strong>Control Unit:</strong> Coordinates the operations of all other components.</li>
                                            <li><strong>Input/Output (I/O) Subsystem:</strong> Communicates with the outside world (keyboard, monitor, drives...).</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Three Components of a Computer</h3>
                        <ul>
                            <li><strong>Hardware:</strong> The physical parts of the computer (CPU, RAM, disk drive, etc.).</li>
                            <li><strong>Data:</strong> Raw information (numbers, text, images) that the computer processes. Data is represented in binary format.</li>
                            <li><strong>Software:</strong> A collection of programs (sets of instructions) that tells the hardware what to do. Software is the bridge between the user and the hardware.</li>
                        </ul>
                    `
                },
                questions: [
                    { q: { vi: "Mô hình nào định nghĩa khái niệm 'Stored Program Concept' (Chương trình được lưu trong bộ nhớ)?", en: "Which model defines the 'Stored Program Concept'?" }, o: [{ vi: "Mô hình Turing", en: "Turing Model" }, { vi: "Mô hình von Neumann", en: "von Neumann Model" }, { vi: "Mô hình Pascal", en: "Pascal Model" }, { vi: "Mô hình Babbage", en: "Babbage Model" }], a: 1, explanation: { vi: "Ghi nhớ: Von Neumann = Chương trình trong Bộ nhớ. Đây là kiến trúc máy tính hiện đại.", en: "Remember: Von Neumann = Program in Memory. This is the modern computer architecture." } },
                    { q: { vi: "Theo mô hình Turing, đầu ra phụ thuộc vào yếu tố nào?", en: "According to the Turing model, what does the output depend on?" }, o: [{ vi: "Chỉ dữ liệu đầu vào", en: "Only the input data" }, { vi: "Chỉ chương trình", en: "Only the program" }, { vi: "Sự kết hợp của dữ liệu đầu vào và chương trình", en: "The combination of input data and the program" }, { vi: "Tốc độ của máy tính", en: "The speed of the computer" }], a: 2, explanation: { vi: "Máy Turing là một 'bộ xử lý dữ liệu LẬP TRÌNH ĐƯỢC'. 'Lập trình được' có nghĩa là chương trình quyết định cách xử lý dữ liệu.", en: "A Turing machine is a 'PROGRAMMABLE data processor'. 'Programmable' means the program dictates how the data is handled." } },
                    { q: { vi: "Bốn thành phần của máy tính theo kiến trúc von Neumann là gì?", en: "What are the four components of a computer according to the von Neumann architecture?"}, o: [ {vi: "CPU, RAM, Bàn phím, Màn hình", en: "CPU, RAM, Keyboard, Monitor"}, {vi: "Bộ nhớ, ALU, Đơn vị điều khiển, Thiết bị Vào/Ra", en: "Memory, ALU, Control Unit, Input/Output Subsystem"}, {vi: "Phần cứng, Phần mềm, Dữ liệu, Mạng", en: "Hardware, Software, Data, Network"}, {vi: "Hệ điều hành, Ứng dụng, Driver, Firmware", en: "Operating System, Application, Driver, Firmware"}], a: 1, explanation: {vi: "Kiến trúc von Neumann định nghĩa 4 khối chức năng chính: Memory (bộ nhớ), ALU (đơn vị số học logic), Control Unit (đơn vị điều khiển), và I/O (vào/ra).", en: "The von Neumann architecture defines 4 main functional blocks: Memory, ALU (Arithmetic Logic Unit), Control Unit, and I/O (Input/Output)."}},
                    { q: { vi: "Thành phần nào của CPU chịu trách nhiệm thực hiện các phép toán số học và logic?", en: "Which component of the CPU is responsible for performing arithmetic and logic operations?"}, o: [ {vi: "Control Unit", en: "Control Unit"}, {vi: "Registers", en: "Registers"}, {vi: "ALU (Arithmetic Logic Unit)", en: "ALU (Arithmetic Logic Unit)"}, {vi: "Main Memory", en: "Main Memory"}], a: 2, explanation: {vi: "ALU là viết tắt của Arithmetic Logic Unit, chuyên thực hiện các phép tính toán (+, -, *, /) và các phép so sánh logic (AND, OR, NOT).", en: "ALU stands for Arithmetic Logic Unit, which specializes in performing calculations (+, -, *, /) and logical operations (AND, OR, NOT)."}},
                    { q: { vi: "Sự khác biệt chính giữa máy tính đa năng (general-purpose) và máy tính chuyên dụng (specific-purpose) là gì?", en: "What is the main difference between a general-purpose and a specific-purpose computer?"}, o: [ {vi: "Kích thước vật lý", en: "Physical size"}, {vi: "Khả năng chạy các chương trình khác nhau", en: "The ability to run different programs"}, {vi: "Giá thành", en: "Cost"}, {vi: "Tốc độ xử lý", en: "Processing speed"}], a: 1, explanation: {vi: "Máy tính đa năng (như PC) có thể thực hiện nhiều tác vụ bằng cách chạy các chương trình khác nhau. Máy tính chuyên dụng (như máy tính trong lò vi sóng) chỉ được thiết kế cho một nhiệm vụ duy nhất.", en: "A general-purpose computer (like a PC) can perform many tasks by running different programs. A specific-purpose computer (like one in a microwave) is designed for only one task."}},
                    { q: { vi: "Định nghĩa 'khoa học máy tính' trong sách này là gì?", en: "What is the definition of 'computer science' in this book?"}, o: [ {vi: "Một thiết bị điện tử", en: "An electronic device"}, {vi: "Các vấn đề liên quan đến máy tính", en: "Issues related to the computer"}, {vi: "Một máy tính toán", en: "A calculating machine"}, {vi: "Một thiết bị có màn hình", en: "A device with a screen"}], a: 1, explanation: {vi: "Sách định nghĩa 'khoa học máy tính' là các vấn đề liên quan đến máy tính (issues related to the computer), bao gồm cả lý thuyết và thực hành.", en: "The book defines 'computer science' as 'issues related to the computer', encompassing both theory and practice."}},
                    { q: { vi: "Ai là người đầu tiên mô tả ý tưởng về một thiết bị tính toán phổ quát (universal computational device)?", en: "Who first described the idea of a universal computational device?"}, o: [ {vi: "John von Neumann", en: "John von Neumann"}, {vi: "Charles Babbage", en: "Charles Babbage"}, {vi: "Blaise Pascal", en: "Blaise Pascal"}, {vi: "Alan Turing", en: "Alan Turing"}], a: 3, explanation: {vi: "Alan Turing đã đề xuất ý tưởng này vào năm 1936 với máy Turing, một mô hình lý thuyết về máy tính đa năng.", en: "Alan Turing proposed this idea in 1936 with the Turing machine, a theoretical model of a general-purpose computer."}},
                    { q: { vi: "Trong mô hình máy tính cơ bản nhất (black box), máy tính được xem như một...", en: "In the most basic computer model (black box), a computer is seen as a..."}, o: [ {vi: "Bộ xử lý chương trình", en: "Program processor"}, {vi: "Bộ lưu trữ dữ liệu", en: "Data storage"}, {vi: "Bộ xử lý dữ liệu", en: "Data processor"}, {vi: "Bộ điều khiển", en: "Control unit"}], a: 2, explanation: {vi: "Mô hình đơn giản nhất coi máy tính như một 'hộp đen' nhận dữ liệu vào, xử lý nó, và tạo ra dữ liệu ra. Đây chính là một bộ xử lý dữ liệu.", en: "The simplest model views a computer as a 'black box' that accepts input data, processes it, and creates output data. This is a data processor."}},
                    { q: { vi: "Lịch sử máy tính được chia thành bao nhiêu giai đoạn chính?", en: "The history of computers is divided into how many main periods?"}, o: [ {vi: "2", en: "2"}, {vi: "3", en: "3"}, {vi: "4", en: "4"}, {vi: "5", en: "5"}], a: 1, explanation: {vi: "Lịch sử máy tính được chia làm 3 giai đoạn: Máy cơ học (trước 1930), Máy tính điện tử (1930-1950), và Các thế hệ máy tính hiện đại (1950-nay).", en: "The history of computers is divided into 3 periods: Mechanical machines (before 1930), Electronic computers (1930-1950), and Modern computer generations (1950-present)."}},
                    { q: { vi: "Thế hệ máy tính thứ hai (Second generation) sử dụng công nghệ nào thay cho bóng chân không (vacuum tubes)?", en: "The second generation of computers used which technology to replace vacuum tubes?"}, o: [ {vi: "Transistors (Bán dẫn)", en: "Transistors"}, {vi: "Integrated Circuits (Mạch tích hợp)", en: "Integrated Circuits"}, {vi: "Microprocessors (Vi xử lý)", en: "Microprocessors"}, {vi: "Artificial Intelligence (Trí tuệ nhân tạo)", en: "Artificial Intelligence"}], a: 0, explanation: {vi: "Sự ra đời của transistor đã giúp máy tính thế hệ thứ hai nhỏ hơn, rẻ hơn, và đáng tin cậy hơn so với thế hệ đầu tiên dùng bóng chân không.", en: "The invention of the transistor made second-generation computers smaller, cheaper, and more reliable than the first generation which used vacuum tubes."}},
                    { q: { vi: "Vi xử lý (microprocessor) là đặc trưng của thế hệ máy tính thứ mấy?", en: "The microprocessor is characteristic of which computer generation?"}, o: [ {vi: "Thứ nhất", en: "First"}, {vi: "Thứ hai", en: "Second"}, {vi: "Thứ ba", en: "Third"}, {vi: "Thứ tư", en: "Fourth"}], a: 3, explanation: {vi: "Thế hệ thứ tư chứng kiến sự ra đời của vi xử lý, tích hợp toàn bộ CPU lên một con chip duy nhất, mở đường cho máy tính cá nhân.", en: "The fourth generation saw the advent of the microprocessor, integrating the entire CPU onto a single chip, paving the way for personal computers."}},
                    { q: { vi: "ENIAC là viết tắt của cụm từ nào?", en: "ENIAC is an acronym for what phrase?"}, o: [ {vi: "Electronic Numerical Integrator and Computer", en: "Electronic Numerical Integrator and Computer"}, {vi: "Electronic Network Interface and Controller", en: "Electronic Network Interface and Controller"}, {vi: "Electrical Number Integration and Calculation", en: "Electrical Number Integration and Calculation"}, {vi: "Engine for Numerical Integration and Computation", en: "Engine for Numerical Integration and Computation"}], a: 0, explanation: {vi: "ENIAC, một trong những máy tính điện tử đa năng đầu tiên, là viết tắt của Electronic Numerical Integrator and Computer.", en: "ENIAC, one of the first general-purpose electronic computers, stands for Electronic Numerical Integrator and Computer."}},
                    { q: { vi: "Thành phần nào không thuộc về một máy tính theo mô hình von Neumann?", en: "Which component does NOT belong to a computer in the von Neumann model?"}, o: [ {vi: "Bộ nhớ", en: "Memory"}, {vi: "ALU", en: "ALU"}, {vi: "Mạng Internet", en: "Internet Network"}, {vi: "Đơn vị điều khiển", en: "Control Unit"}], a: 2, explanation: {vi: "Mô hình von Neumann định nghĩa các thành phần bên trong một máy tính độc lập (stand-alone). Mạng là để kết nối nhiều máy tính với nhau.", en: "The von Neumann model defines the internal components of a stand-alone computer. A network is for connecting multiple computers."}},
                    { q: { vi: "Một chương trình máy tính (program) là gì?", en: "What is a computer program?"}, o: [ {vi: "Một thành phần phần cứng", en: "A hardware component"}, {vi: "Một tập hợp các chỉ thị (instructions)", en: "A set of instructions"}, {vi: "Một loại dữ liệu", en: "A type of data"}, {vi: "Một thiết bị ngoại vi", en: "A peripheral device"}], a: 1, explanation: {vi: "Chương trình là một chuỗi các chỉ thị được viết để máy tính thực hiện một tác vụ cụ thể.", en: "A program is a sequence of instructions written for a computer to perform a specific task."}},
                    { q: { vi: "Lợi ích chính của khái niệm 'Stored Program' là gì?", en: "What is the main benefit of the 'Stored Program' concept?"}, o: [ {vi: "Làm máy tính rẻ hơn", en: "Makes computers cheaper"}, {vi: "Làm máy tính nhanh hơn", en: "Makes computers faster"}, {vi: "Cho phép máy tính trở nên đa năng", en: "Allows the computer to be general-purpose"}, {vi: "Tiết kiệm điện", en: "Saves electricity"}], a: 2, explanation: {vi: "Khi chương trình được lưu trong bộ nhớ, ta có thể dễ dàng thay đổi chương trình để máy tính thực hiện các công việc khác nhau, biến nó thành một thiết bị đa năng.", en: "When the program is stored in memory, we can easily change the program to make the computer perform different tasks, turning it into a general-purpose device."}},
                    { q: { vi: "Thế hệ máy tính thứ ba (Third generation) được đặc trưng bởi công nghệ nào?", en: "The third generation of computers was characterized by which technology?"}, o: [ {vi: "Bóng chân không", en: "Vacuum tubes"}, {vi: "Bán dẫn", en: "Transistors"}, {vi: "Mạch tích hợp (IC)", en: "Integrated Circuits (IC)"}, {vi: "Vi xử lý", en: "Microprocessors"}], a: 2, explanation: {vi: "Mạch tích hợp (IC) cho phép tích hợp nhiều transistor lên một con chip nhỏ, giúp máy tính nhỏ hơn, mạnh hơn và đáng tin cậy hơn nữa.", en: "Integrated Circuits (IC) allowed for the integration of many transistors onto a small chip, making computers even smaller, more powerful, and more reliable."}},
                    { q: { vi: "Ngôn ngữ lập trình bậc cao (high-level language) đầu tiên được giới thiệu trong thế hệ nào?", en: "The first high-level programming languages were introduced in which generation?"}, o: [ {vi: "Thế hệ thứ nhất", en: "First Generation"}, {vi: "Thế hệ thứ hai", en: "Second Generation"}, {vi: "Thế hệ thứ ba", en: "Third Generation"}, {vi: "Thế hệ thứ tư", en: "Fourth Generation"}], a: 1, explanation: {vi: "FORTRAN và COBOL, hai trong số các ngôn ngữ bậc cao đầu tiên, đã được phát triển trong thế hệ thứ hai, giúp việc lập trình trở nên dễ dàng hơn.", en: "FORTRAN and COBOL, two of the first high-level languages, were developed during the second generation, making programming easier."}},
                    { q: { vi: "Trong mô hình Turing, nếu bạn có cùng một chương trình nhưng thay đổi dữ liệu đầu vào, kết quả sẽ như thế nào?", en: "In the Turing model, if you have the same program but change the input data, what will the result be?"}, o: [ {vi: "Kết quả sẽ giống hệt nhau", en: "The result will be identical"}, {vi: "Kết quả có thể sẽ khác", en: "The result will likely be different"}, {vi: "Máy tính sẽ báo lỗi", en: "The computer will error"}, {vi: "Chương trình sẽ không chạy", en: "The program will not run"}], a: 1, explanation: {vi: "Bản chất của việc xử lý dữ liệu là chương trình sẽ thao tác trên dữ liệu đầu vào. Nếu dữ liệu thay đổi, kết quả của các thao tác đó cũng sẽ thay đổi.", en: "The nature of data processing is that the program operates on the input data. If the data changes, the result of those operations will also change."}},
                    { q: { vi: "Máy tính Colossus được phát minh ở Anh trong Thế chiến II với mục đích gì?", en: "The Colossus computer was invented in England during WWII for what purpose?"}, o: [ {vi: "Dự báo thời tiết", en: "Weather forecasting"}, {vi: "Giải mã mật mã của Đức", en: "Breaking German codes"}, {vi: "Tính toán quỹ đạo đạn đạo", en: "Calculating ballistic trajectories"}, {vi: "Quản lý điều tra dân số", en: "Managing census data"}], a: 1, explanation: {vi: "Colossus, do Alan Turing và nhóm của ông phát triển, là một máy tính chuyên dụng được thiết kế để giải mã các thông điệp được mã hóa bởi máy Enigma của Đức.", en: "Colossus, developed by Alan Turing and his team, was a special-purpose computer designed to break messages encrypted by the German Enigma machine."}},
                    { q: { vi: "Ai được coi là người phát minh ra máy tính cơ học đầu tiên có thể thực hiện phép cộng và trừ?", en: "Who is credited with inventing the first mechanical calculator that could perform addition and subtraction?"}, o: [ {vi: "Charles Babbage", en: "Charles Babbage"}, {vi: "Gottfried Leibniz", en: "Gottfried Leibniz"}, {vi: "Blaise Pascal", en: "Blaise Pascal"}, {vi: "Herman Hollerith", en: "Herman Hollerith"}], a: 2, explanation: {vi: "Blaise Pascal đã phát minh ra Pascaline vào thế kỷ 17, một máy tính cơ học có thể thực hiện cộng và trừ để giúp cha mình trong công việc thuế.", en: "Blaise Pascal invented the Pascaline in the 17th century, a mechanical calculator that could add and subtract to help his father with tax work."}},
                    { q: { vi: "Thuật ngữ 'thuật toán' (algorithm) có nghĩa là gì trong khoa học máy tính?", en: "What does the term 'algorithm' mean in computer science?"}, o: [ {vi: "Ngôn ngữ máy tính", en: "A computer language"}, {vi: "Một lỗi trong chương trình", en: "A bug in a program"}, {vi: "Một quy trình từng bước để giải quyết một vấn đề", en: "A step-by-step procedure for solving a problem"}, {vi: "Một thiết bị phần cứng", en: "A hardware device"}], a: 2, explanation: {vi: "Thuật toán là nền tảng của lập trình. Nó là một tập hợp các bước hữu hạn và rõ ràng để giải quyết một vấn đề cụ thể.", en: "An algorithm is the foundation of programming. It is a finite and clear set of steps to solve a specific problem."}},
                    { q: { vi: "Sự ra đời của máy tính cá nhân (personal computers) gắn liền với thế hệ máy tính nào?", en: "The advent of personal computers is associated with which computer generation?"}, o: [ {vi: "Thế hệ thứ nhất", en: "First Generation"}, {vi: "Thế hệ thứ hai", en: "Second Generation"}, {vi: "Thế hệ thứ ba", en: "Third Generation"}, {vi: "Thế hệ thứ tư", en: "Fourth Generation"}], a: 3, explanation: {vi: "Thế hệ thứ tư, với sự phát minh ra vi xử lý, đã làm cho máy tính đủ nhỏ và rẻ để có thể sở hữu cá nhân, dẫn đến cuộc cách mạng máy tính cá nhân.", en: "The fourth generation, with the invention of the microprocessor, made computers small and affordable enough for personal ownership, leading to the personal computer revolution."}},
                    { q: { vi: "Thành phần nào sau đây là ví dụ về phần mềm (software)?", en: "Which of the following is an example of software?"}, o: [ {vi: "CPU", en: "CPU"}, {vi: "RAM", en: "RAM"}, {vi: "Hệ điều hành Windows", en: "Windows Operating System"}, {vi: "Chuột máy tính", en: "Computer Mouse"}], a: 2, explanation: {vi: "Phần mềm là các chương trình và dữ liệu. Hệ điều hành là một loại phần mềm hệ thống phức tạp. CPU, RAM và chuột là các thành phần phần cứng.", en: "Software consists of programs and data. An operating system is a complex type of system software. The CPU, RAM, and mouse are hardware components."}},
                    { q: { vi: "Trong mô hình von Neumann, chương trình và dữ liệu được lưu trữ dưới dạng nào?", en: "In the von Neumann model, in what form are programs and data stored?"}, o: [ {vi: "Văn bản tiếng Anh", en: "English text"}, {vi: "Các mẫu nhị phân (Binary patterns)", en: "Binary patterns"}, {vi: "Sóng tương tự (Analog waves)", en: "Analog waves"}, {vi: "Các công thức toán học", en: "Mathematical formulas"}], a: 1, explanation: {vi: "Một nguyên tắc cốt lõi của kiến trúc von Neumann là cả chương trình và dữ liệu đều được biểu diễn dưới dạng các chuỗi bit (0 và 1) trong bộ nhớ.", en: "A core principle of the von Neumann architecture is that both programs and data are represented as bit patterns (0s and 1s) in memory."}},
                    { q: { vi: "Máy tính Analytical Engine của Charles Babbage có bốn thành phần. Thành phần 'mill' tương ứng với thành phần nào trong máy tính hiện đại?", en: "Charles Babbage's Analytical Engine had four components. The 'mill' component corresponds to which component in a modern computer?"}, o: [ {vi: "Memory", en: "Memory"}, {vi: "Control Unit", en: "Control Unit"}, {vi: "ALU", en: "ALU"}, {vi: "Input/Output", en: "Input/Output"}], a: 2, explanation: {vi: "Thành phần 'mill' (cối xay) được thiết kế để thực hiện các phép tính, tương tự như chức năng của ALU (Đơn vị Số học và Logic) trong CPU hiện đại.", en: "The 'mill' component was designed to perform calculations, which is analogous to the function of the ALU (Arithmetic Logic Unit) in a modern CPU."}},
                    { q: { vi: "Tại sao máy tính hiện đại được coi là 'đa năng' (general-purpose)?", en: "Why are modern computers considered 'general-purpose'?"}, o: [ {vi: "Vì chúng có thể kết nối Internet.", en: "Because they can connect to the Internet."}, {vi: "Vì chúng có thể thực hiện nhiều tác vụ khác nhau bằng cách chạy các chương trình khác nhau.", en: "Because they can perform many different tasks by running different programs."}, {vi: "Vì chúng có nhiều màu sắc khác nhau.", en: "Because they come in different colors."}, {vi: "Vì chúng được sản xuất trên toàn thế giới.", en: "Because they are manufactured worldwide."}], a: 1, explanation: {vi: "Khả năng nạp và thực thi các chương trình khác nhau là điều làm cho máy tính trở nên đa năng, trái ngược với các thiết bị chuyên dụng chỉ làm một việc.", en: "The ability to load and execute different programs is what makes a computer general-purpose, as opposed to special-purpose devices that do only one thing."}},
                    { q: { vi: "EDSAC được coi là một cột mốc quan trọng vì nó là máy tính nào?", en: "EDSAC is considered a milestone because it was which type of computer?"}, o: [ {vi: "Máy tính điện tử đầu tiên", en: "The first electronic computer"}, {vi: "Máy tính xách tay đầu tiên", en: "The first laptop computer"}, {vi: "Máy tính thực tế đầu tiên sử dụng khái niệm chương trình được lưu trữ", en: "The first practical stored-program computer"}, {vi: "Máy tính đầu tiên sử dụng bóng bán dẫn", en: "The first computer to use transistors"}], a: 2, explanation: {vi: "Trong khi ENIAC là máy tính điện tử đa năng đầu tiên, EDSAC (chế tạo tại Đại học Cambridge) là một trong những máy tính đầu tiên hoạt động đầy đủ theo kiến trúc von Neumann (stored-program).", en: "While ENIAC was the first general-purpose electronic computer, EDSAC (built at the University of Cambridge) was one of the first fully operational computers to implement the von Neumann (stored-program) architecture."}},
                    { q: { vi: "Thế hệ máy tính nào chứng kiến sự ra đời của các 'phần mềm đóng gói' (software packages)?", en: "Which computer generation saw the appearance of 'software packages'?"}, o: [ {vi: "Thế hệ thứ nhất", en: "First Generation"}, {vi: "Thế hệ thứ hai", en: "Second Generation"}, {vi: "Thế hệ thứ ba", en: "Third Generation"}, {vi: "Thế hệ thứ tư", en: "Fourth Generation"}], a: 2, explanation: {vi: "Với sự phát triển của máy tính mini trong thế hệ thứ ba, một ngành công nghiệp phần mềm đã ra đời, cung cấp các chương trình làm sẵn (đóng gói) cho các doanh nghiệp.", en: "With the development of minicomputers in the third generation, a software industry was born, providing ready-made (packaged) programs for businesses."}},
                    { q: { vi: "Trong mô hình von Neumann, Đơn vị Điều khiển (Control Unit) KHÔNG thực hiện chức năng nào sau đây?", en: "In the von Neumann model, which of the following functions is NOT performed by the Control Unit?"}, o: [ {vi: "Điều khiển hoạt động của bộ nhớ", en: "Controlling memory operations"}, {vi: "Điều khiển hoạt động của ALU", en: "Controlling ALU operations"}, {vi: "Thực hiện phép cộng hai số", en: "Performing the addition of two numbers"}, {vi: "Điều khiển hệ thống I/O", en: "Controlling the I/O subsystem"}], a: 2, explanation: {vi: "Đơn vị Điều khiển chỉ đạo và điều phối, nhưng việc thực hiện các phép toán số học như cộng là nhiệm vụ của ALU (Đơn vị Số học và Logic).", en: "The Control Unit directs and coordinates, but the actual execution of arithmetic operations like addition is the task of the ALU (Arithmetic Logic Unit)."}},
                    { q: { vi: "Dữ liệu và chương trình được lưu trong bộ nhớ dưới dạng các mẫu nhị phân, đó là một chuỗi của các số nào?", en: "Data and programs are stored in memory as binary patterns, which is a sequence of what numbers?"}, o: [ {vi: "0 và 1", en: "0s and 1s"}, {vi: "0 đến 7", en: "0s to 7s"}, {vi: "0 đến 9", en: "0s to 9s"}, {vi: "A đến F", en: "As to Fs"}], a: 0, explanation: {vi: "Hệ thống nhị phân (binary) là nền tảng của máy tính kỹ thuật số, chỉ sử dụng hai ký hiệu là 0 và 1 để biểu diễn tất cả thông tin.", en: "The binary system is the foundation of digital computing, using only two symbols, 0 and 1, to represent all information."}},
                    { q: { vi: "Sự kiện nào đánh dấu sự kết thúc của thời kỳ máy tính cơ học và bắt đầu thời kỳ máy tính điện tử?", en: "What event marked the end of the mechanical computer era and the beginning of the electronic computer era?"}, o: [ {vi: "Phát minh ra bóng bán dẫn", en: "The invention of the transistor"}, {vi: "Phát minh ra máy dệt Jacquard", en: "The invention of the Jacquard loom"}, {vi: "Việc sử dụng các linh kiện điện và điện tử thay cho cơ khí", en: "The use of electrical and electronic components instead of mechanical ones"}, {vi: "Sự ra đời của Internet", en: "The birth of the Internet"}], a: 2, explanation: {vi: "Bước nhảy vọt từ máy cơ học sang máy tính điện tử được định nghĩa bằng việc thay thế các bánh răng và đòn bẩy cơ khí bằng các công tắc điện tử như rơ le và bóng chân không.", en: "The leap from mechanical to electronic computers was defined by the replacement of mechanical gears and levers with electronic switches like relays and vacuum tubes."}},
                    { q: { vi: "Khái niệm 'reusability' (tái sử dụng) trong lập trình được tạo điều kiện thuận lợi bởi mô hình nào?", en: "The concept of 'reusability' in programming is facilitated by which model?"}, o: [ {vi: "Mô hình Turing và von Neumann", en: "Turing and von Neumann models"}, {vi: "Chỉ mô hình cơ học", en: "Only the mechanical model"}, {vi: "Mô hình máy tính lượng tử", en: "The quantum computing model"}, {vi: "Không có mô hình nào", en: "None of the models"}], a: 0, explanation: {vi: "Các mô hình này định nghĩa rằng một chương trình bao gồm các chỉ thị có thể tái sử dụng. Lập trình viên có thể kết hợp các chỉ thị này theo nhiều cách khác nhau để tạo ra các chương trình khác nhau, thúc đẩy việc tái sử dụng.", en: "These models define a program as consisting of reusable instructions. Programmers can combine these instructions in various ways to create different programs, promoting reusability."}},
                    { q: { vi: "Tại sao việc viết chương trình bằng ngôn ngữ máy (các mẫu nhị phân) lại trở nên tẻ nhạt?", en: "Why did writing programs in machine language (binary patterns) become tedious?"}, o: [ {vi: "Vì máy tính không hiểu được chúng", en: "Because computers could not understand them"}, {vi: "Vì các chương trình ngày càng lớn và phức tạp", en: "Because programs became larger and more complex"}, {vi: "Vì thiếu bộ nhớ", en: "Due to lack of memory"}, {vi: "Vì nó quá chậm", en: "Because it was too slow"}], a: 1, explanation: {vi: "Khi các chương trình phát triển về kích thước và độ phức tạp, việc viết và gỡ lỗi hàng nghìn dòng mã 0 và 1 trở nên cực kỳ khó khăn và dễ xảy ra lỗi.", en: "As programs grew in size and complexity, writing and debugging thousands of lines of 0s and 1s became extremely difficult and error-prone."}},
                    { q: { vi: "Hệ điều hành (Operating System) ban đầu xuất hiện để giải quyết vấn đề gì?", en: "Operating Systems initially emerged to solve what problem?"}, o: [ {vi: "Tăng tốc độ xử lý của CPU", en: "To increase CPU processing speed"}, {vi: "Cung cấp một tập hợp các chỉ thị chung cho tất cả các chương trình", en: "To provide a common set of instructions for all programs"}, {vi: "Kết nối máy tính với Internet", en: "To connect computers to the Internet"}, {vi: "Tạo ra đồ họa tốt hơn", en: "To create better graphics"}], a: 1, explanation: {vi: "Các nhà khoa học nhận thấy rằng nhiều chương trình cần cùng một chuỗi các chỉ thị cơ bản (ví dụ: để đọc dữ liệu). Hệ điều hành được tạo ra để quản lý các tác vụ chung này một cách hiệu quả.", en: "Scientists realized that many programs needed the same basic instruction sequences (e.g., to read data). The Operating System was created to manage these common tasks efficiently."}},
                    { q: { vi: "Thiết bị nào sau đây là một ví dụ về thiết bị đầu vào (input device)?", en: "Which of the following is an example of an input device?"}, o: [ {vi: "Màn hình (Monitor)", en: "Monitor"}, {vi: "Loa (Speakers)", en: "Speakers"}, {vi: "Máy in (Printer)", en: "Printer"}, {vi: "Chuột (Mouse)", en: "Mouse"}], a: 3, explanation: {vi: "Thiết bị đầu vào được sử dụng để đưa dữ liệu vào máy tính. Chuột được sử dụng để cung cấp đầu vào điều khiển con trỏ và các lệnh nhấp chuột.", en: "Input devices are used to get data into the computer. A mouse is used to provide cursor control and click commands as input."}},
                    { q: { vi: "Thành phần nào sau đây là một ví dụ về thiết bị đầu ra (output device)?", en: "Which of the following is an example of an output device?"}, o: [ {vi: "Bàn phím (Keyboard)", en: "Keyboard"}, {vi: "Máy quét (Scanner)", en: "Scanner"}, {vi: "Máy in (Printer)", en: "Printer"}, {vi: "Microphone", en: "Microphone"}], a: 2, explanation: {vi: "Thiết bị đầu ra được sử dụng để nhận dữ liệu từ máy tính. Máy in nhận dữ liệu và tạo ra một bản sao cứng.", en: "Output devices are used to receive data from the computer. A printer receives data and creates a hard copy."}},
                    { q: {vi: "Điều gì phân biệt một bộ xử lý dữ liệu với một bộ xử lý dữ liệu có thể lập trình?", en: "What distinguishes a data processor from a programmable data processor?"}, o: [{vi: "Loại dữ liệu nó có thể xử lý", en: "The type of data it can handle"}, {vi: "Khả năng thay đổi các chỉ thị xử lý của nó thông qua một chương trình", en: "The ability to change its processing instructions via a program"}, {vi: "Tốc độ xử lý", en: "The speed of processing"}, {vi: "Lượng bộ nhớ nó có", en: "The amount of memory it has"}], a: 1, explanation: {vi: "Một bộ xử lý dữ liệu đơn giản (như một máy tính cơ bản) có chức năng cố định. Một bộ xử lý có thể lập trình (như máy tính) có thể thực hiện các tác vụ khác nhau vì các chỉ thị của nó có thể được thay đổi thông qua một chương trình.", en: "A simple data processor (like a basic calculator) has a fixed function. A programmable one (like a computer) can perform different tasks because its instructions can be changed via a program."} },
                    { q: {vi: "Thế hệ máy tính nào được đặc trưng bởi sự xuất hiện của máy tính xách tay và internet?", en: "Which generation of computers is characterized by the emergence of laptops and the internet?"}, o: [{vi: "Thế hệ thứ hai", en: "Second Generation"}, {vi: "Thế hệ thứ ba", en: "Third Generation"}, {vi: "Thế hệ thứ tư", en: "Fourth Generation"}, {vi: "Thế hệ thứ năm", en: "Fifth Generation"}], a: 3, explanation: {vi: "Thế hệ thứ năm (1985-nay) được định nghĩa bởi sự phát triển của máy vi tính thành các dạng di động như máy tính xách tay, sự trỗi dậy của mạng máy tính, và các hiện tượng như đa phương tiện và thực tế ảo.", en: "The fifth generation (1985-present) is defined by the development of microcomputers into portable forms like laptops, the rise of computer networks, and phenomena like multimedia and virtual reality."} },
                    { q: {vi: "Vai trò chính của hệ thống con I/O là gì?", en: "What is the primary role of the I/O subsystem?"}, o: [{vi: "Thực hiện các phép tính", en: "To perform calculations"}, {vi: "Lưu trữ hệ điều hành", en: "To store the operating system"}, {vi: "Giao tiếp với thế giới bên ngoài và lưu trữ dữ liệu một cách bền vững", en: "To communicate with the outside world and store data persistently"}, {vi: "Điều khiển các hoạt động của CPU", en: "To control the CPU's operations"}], a: 2, explanation: {vi: "Hệ thống con I/O bao gồm các thiết bị như bàn phím, màn hình, và ổ cứng, cho phép máy tính tương tác với người dùng và lưu trữ dữ liệu ngay cả khi tắt nguồn.", en: "The I/O subsystem includes devices like keyboards, monitors, and hard drives, which allow the computer to interact with users and store data even when the power is off."} },
                    { q: {vi: "Ngành 'khoa học máy tính' với tư cách là một ngành học đã phát triển cùng với phát minh nào?", en: "The term 'computer science' as a discipline evolved with what invention?"}, o: [{vi: "Phát minh ra bóng bán dẫn", en: "The invention of the transistor"}, {vi: "Phát minh ra máy tính", en: "The invention of the computer"}, {vi: "Phát minh ra internet", en: "The invention of the internet"}, {vi: "Phát minh ra ngôn ngữ lập trình", en: "The invention of programming languages"}], a: 1, explanation: {vi: "Lĩnh vực khoa học máy tính đã xuất hiện và phát triển như một kết quả trực tiếp của sự phát minh và phổ biến của máy tính, tạo ra một lĩnh vực nghiên cứu mới về lý thuyết, thiết kế và ứng dụng của chúng.", en: "The field of computer science emerged and evolved as a direct result of the invention and proliferation of computers, creating a new area of study for their theory, design, and application."} },
                    { q: {vi: "Chương trình máy tính được thực thi tuần tự có nghĩa là gì?", en: "What does it mean for a computer program to be executed sequentially?"}, o: [{vi: "Các chỉ thị được thực thi theo thứ tự ngẫu nhiên", en: "Instructions are executed in a random order"}, {vi: "Các chỉ thị được thực thi lần lượt, theo thứ tự chúng được lưu trữ", en: "Instructions are executed one after another, in the order they are stored"}, {vi: "Tất cả các chỉ thị được thực thi cùng một lúc", en: "All instructions are executed at the same time"}, {vi: "Chỉ có chỉ thị đầu tiên và cuối cùng được thực thi", en: "Only the first and last instructions are executed"}], a: 1, explanation: {vi: "Trong mô hình von Neumann cơ bản, đơn vị điều khiển tìm nạp và thực thi các chỉ thị lần lượt từ bộ nhớ, theo trình tự được đặt ra trong chương trình.", en: "In the basic von Neumann model, the control unit fetches and executes instructions one by one from memory, following the sequence laid out in the program."} },
                    { q: {vi: "Máy Analytical Engine, do Charles Babbage thiết kế, có một thành phần 'store'. Thành phần này tương ứng với thành phần nào trong một máy tính hiện đại?", en: "The Analytical Engine, designed by Charles Babbage, had a 'store' component. What does this correspond to in a modern computer?"}, o: [{vi: "ALU", en: "ALU"}, {vi: "Đơn vị điều khiển", en: "Control Unit"}, {vi: "Đầu vào/Đầu ra", en: "Input/Output"}, {vi: "Bộ nhớ", en: "Memory"}], a: 3, explanation: {vi: "Thành phần 'store' được thiết kế để giữ các số và kết quả, đây là chức năng cơ bản của bộ nhớ (như RAM) trong một máy tính hiện đại.", en: "The 'store' was designed to hold numbers and results, which is the fundamental function of the memory (like RAM) in a modern computer."} },
                    { q: {vi: "Điều nào sau đây KHÔNG phải là đặc điểm của máy tính thế hệ thứ nhất?", en: "Which of these is NOT a characteristic of first-generation computers?"}, o: [{vi: "Chúng lớn và cồng kềnh", en: "They were large and bulky"}, {vi: "Chúng sử dụng bóng bán dẫn", en: "They used transistors"}, {vi: "Chúng tiêu thụ rất nhiều điện năng", en: "They consumed a lot of power"}, {vi: "Chúng được lập trình bằng ngôn ngữ máy", en: "They were programmed using machine language"}], a: 1, explanation: {vi: "Máy tính thế hệ thứ nhất sử dụng bóng chân không. Bóng bán dẫn là công nghệ chủ chốt của thế hệ thứ hai.", en: "First-generation computers used vacuum tubes. Transistors were the key technology of the second generation."} },
                    { q: {vi: "Sự khác biệt chính giữa dữ liệu và phần mềm là gì?", en: "What is the primary difference between data and software?"}, o: [{vi: "Dữ liệu là phần cứng, phần mềm thì không", en: "Data is hardware, software is not"}, {vi: "Dữ liệu là thông tin thô, phần mềm là một tập hợp các chỉ thị để xử lý dữ liệu đó", en: "Data is raw information, software is a set of instructions to process that data"}, {vi: "Không có sự khác biệt", en: "There is no difference"}, {vi: "Dữ liệu được lưu trữ trên ổ cứng, phần mềm ở trong RAM", en: "Data is stored on a hard drive, software is in RAM"}], a: 1, explanation: {vi: "Dữ liệu là các sự kiện và con số (ví dụ: số '5'). Phần mềm là chương trình cho máy tính biết phải làm gì với dữ liệu đó (ví dụ: 'cộng 5 vào một số khác').", en: "Data are the facts and figures (e.g., a number '5'). Software is the program that tells the computer what to do with that data (e.g., 'add 5 to another number')."} },
                    { q: {vi: "Thuật ngữ 'von Neumann bottleneck' đề cập đến điều gì?", en: "What does the term 'von Neumann bottleneck' refer to?"}, o: [{vi: "Tốc độ chậm của ALU", en: "The slow speed of the ALU"}, {vi: "Tốc độ truyền dữ liệu hạn chế giữa CPU và bộ nhớ", en: "The limited data transfer rate between the CPU and memory"}, {vi: "Khó khăn trong việc lập trình", en: "The difficulty in programming"}, {vi: "Kích thước vật lý của máy tính", en: "The physical size of the computer"}], a: 1, explanation: {vi: "Von Neumann bottleneck mô tả sự hạn chế về hiệu suất gây ra bởi đường dẫn dữ liệu duy nhất giữa CPU và bộ nhớ chính. CPU thường phải chờ dữ liệu, làm hạn chế tốc độ tổng thể.", en: "The von Neumann bottleneck describes the performance limitation caused by the single data path between the CPU and main memory. The CPU often has to wait for data, limiting overall speed."} },
                    { q: {vi: "Thiết bị nào, do Herman Hollerith phát minh, đã sử dụng thẻ đục lỗ để xử lý dữ liệu Điều tra dân số Hoa Kỳ năm 1890?", en: "Which device, invented by Herman Hollerith, used punched cards to process the 1890 US Census data?"}, o: [{vi: "Pascaline", en: "The Pascaline"}, {vi: "Analytical Engine", en: "The Analytical Engine"}, {vi: "Máy lập bảng", en: "The Tabulating Machine"}, {vi: "ENIAC", en: "The ENIAC"}], a: 2, explanation: {vi: "Máy lập bảng của Herman Hollerith là một thiết bị cơ điện đột phá đã tự động hóa việc kiểm đếm dữ liệu điều tra dân số được lưu trữ trên các thẻ đục lỗ, giảm đáng kể thời gian xử lý.", en: "Herman Hollerith's Tabulating Machine was a groundbreaking electromechanical device that automated the tallying of census data stored on punched cards, drastically reducing the processing time."} },
                    { q: {vi: "Trong kiến trúc von Neumann, tại sao chương trình và dữ liệu phải có cùng định dạng?", en: "In the von Neumann architecture, why must programs and data have the same format?"}, o: [{vi: "Để tiết kiệm chi phí phần cứng", en: "To save money on hardware"}, {vi: "Vì chúng được lưu trữ trong cùng một bộ nhớ", en: "Because they are stored in the same memory"}, {vi: "Để làm cho việc lập trình dễ dàng hơn", en: "To make programming easier"}, {vi: "Đây không phải là một yêu cầu", en: "This is not a requirement"}], a: 1, explanation: {vi: "Vì cả chỉ thị (chương trình) và dữ liệu đều nằm trong cùng một bộ nhớ, chúng phải được biểu diễn theo cùng một cách (dưới dạng các mẫu nhị phân) để bộ nhớ có thể lưu trữ chúng.", en: "Since both instructions (programs) and data reside in the same memory, they must be represented in the same way (as binary patterns) so the memory can store them."} },
                    { q: {vi: "Một máy tính bỏ túi chỉ có thể thực hiện các phép toán số học là một ví dụ về loại máy nào?", en: "A pocket calculator that can only perform arithmetic is an example of what kind of machine?"}, o: [{vi: "Một máy đa năng", en: "A general-purpose machine"}, {vi: "Một máy Turing", en: "A Turing machine"}, {vi: "Một máy von Neumann", en: "A von Neumann machine"}, {vi: "Một máy chuyên dụng", en: "A specific-purpose machine"}], a: 3, explanation: {vi: "Nó được thiết kế cho một công việc duy nhất (tính toán) và không thể được lập trình lại để thực hiện các tác vụ khác như xử lý văn bản, làm cho nó trở thành một máy chuyên dụng.", en: "It is designed for a single job (calculation) and cannot be reprogrammed to do other tasks like word processing, making it a specific-purpose machine."} },
                    { q: {vi: "Thế hệ nào đã chứng kiến sự chuyển đổi từ việc chỉ được sử dụng bởi các chuyên gia sang được sử dụng bởi các tập đoàn vừa và nhỏ?", en: "Which generation saw the transition from professional-only use to use by small and medium-sized corporations?"}, o: [{vi: "Thế hệ thứ nhất", en: "First Generation"}, {vi: "Thế hệ thứ hai", en: "Second Generation"}, {vi: "Thế hệ thứ ba", en: "Third Generation"}, {vi: "Thế hệ thứ tư", en: "Fourth Generation"}], a: 1, explanation: {vi: "Thế hệ thứ hai, với các máy tính dựa trên bóng bán dẫn nhỏ hơn và rẻ hơn, đã làm cho máy tính có thể tiếp cận được với các tổ chức ngoài các cơ quan chính phủ và quân sự lớn.", en: "The second generation, with its smaller and cheaper transistor-based computers, made computing accessible to organizations beyond large government and military bodies."} },
                    { q: {vi: "Khái niệm cơ bản nào mà máy dệt Jacquard đã giới thiệu sau này được sử dụng trong máy tính?", en: "What fundamental concept did the Jacquard Loom introduce that was later used in computing?"}, o: [{vi: "Việc sử dụng điện", en: "The use of electricity"}, {vi: "Khái niệm chương trình được lưu trữ bằng thẻ đục lỗ", en: "The stored-program concept using punched cards"}, {vi: "Hệ thống nhị phân", en: "The binary system"}, {vi: "Vi xử lý", en: "The microprocessor"}], a: 1, explanation: {vi: "Máy dệt Jacquard đã sử dụng các thẻ đục lỗ để điều khiển mẫu dệt, đây là một dạng cơ học sớm của một chương trình được lưu trữ—các chỉ thị được lưu trữ trên các thẻ.", en: "The Jacquard Loom used punched cards to control the weaving pattern, which is an early, mechanical form of a stored program—the instructions were stored on the cards."} }
                ]
            },
            chapter2: {
                 theory: {
                     vi: `
                        <h2>Chương 2: Hệ thống Số</h2>
                        <h3>1. Các hệ đếm cơ bản (Positional Number Systems)</h3>
                        <ul>
                            <li><strong>Khái niệm:</strong> Giá trị của một chữ số phụ thuộc vào <span class="highlight">vị trí (position)</span> của nó trong chuỗi số. Mỗi vị trí có một trọng số (place value) là lũy thừa của cơ số (base/radix).</li>
                            <li><strong>Các hệ đếm chính:</strong>
                                <ul>
                                    <li><strong>Thập phân (Decimal - Base 10):</strong> Dùng 10 ký tự {0, 1, ..., 9}.</li>
                                    <li><strong>Nhị phân (Binary - Base 2):</strong> Dùng 2 ký tự {0, 1}. Đây là <span class="highlight">ngôn ngữ tự nhiên của máy tính</span>.</li>
                                    <li><strong>Bát phân (Octal - Base 8):</strong> Dùng 8 ký tự {0, 1, ..., 7}.</li>
                                    <li><strong>Thập lục phân (Hexadecimal - Base 16):</strong> Dùng 16 ký tự {0, 1, ..., 9, A, B, C, D, E, F}.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Ví dụ về Chuyển đổi</h3>
                        <h4>Chuyển từ hệ bất kỳ sang Thập phân</h4>
                        <p>Quy tắc: Lấy từng chữ số nhân với (cơ số)<sup>vị trí</sup> rồi cộng tất cả lại.</p>
                        <pre><strong>Ví dụ 1: (11001)₂ sang thập phân</strong>
N = 1×2⁴ + 1×2³ + 0×2² + 0×2¹ + 1×2⁰
  = 16  +  8   +  0   +  0   +  1
  = 25₁₀

<strong>Ví dụ 2: (2AE)₁₆ sang thập phân (A=10, E=14)</strong>
N = 2×16² + 10×16¹ + 14×16⁰
  = 2×256 + 10×16  + 14×1
  = 512   + 160    + 14
  = 686₁₀</pre>
                        <h4>Chuyển từ Thập phân sang hệ bất kỳ (Phần nguyên)</h4>
                        <p>Quy tắc: <span class="highlight">Chia liên tiếp</span> cho cơ số mới, lấy phần dư theo thứ tự ngược lại.</p>
                        <pre><strong>Ví dụ: 35₁₀ sang nhị phân (chia cho 2)</strong>
35 / 2 = 17 dư 1  ↑
17 / 2 = 8  dư 1  |
 8 / 2 = 4  dư 0  | Đọc ngược
 4 / 2 = 2  dư 0  | từ dưới lên
 2 / 2 = 1  dư 0  |
 1 / 2 = 0  dư 1  ↑
Kết quả: (100011)₂</pre>
                        <h4>Chuyển đổi nhanh giữa Binary ↔ Octal ↔ Hexadecimal</h4>
                        <p>Quy tắc: Gom nhóm <span class="highlight">3 bits</span> cho Octal và <span class="highlight">4 bits</span> cho Hexadecimal.</p>
                        <pre><strong>Ví dụ 1: (10011100010)₂ sang Hexadecimal (gom nhóm 4)</strong>
   100  1110  0010   (Thêm 2 số 0 vào đầu cho đủ nhóm)
→ 0100  1110  0010
    ↓     ↓     ↓
    4     E     2
Kết quả: (4E2)₁₆

<strong>Ví dụ 2: (101110010)₂ sang Octal (gom nhóm 3)</strong>
  101  110  010
   ↓    ↓    ↓
   5    6    2
Kết quả: (562)₈</pre>
                    `,
                    en: `
                        <h2>Chapter 2: Number Systems</h2>
                        <h3>1. Positional Number Systems</h3>
                        <ul>
                            <li><strong>Concept:</strong> The value of a digit depends on its <span class="highlight">position</span> within the number string. Each position has a place value, which is a power of the base (radix).</li>
                            <li><strong>Main Systems:</strong>
                                <ul>
                                    <li><strong>Decimal (Base 10):</strong> Uses 10 symbols {0, 1, ..., 9}.</li>
                                    <li><strong>Binary (Base 2):</strong> Uses 2 symbols {0, 1}. This is the <span class="highlight">natural language of computers</span>.</li>
                                    <li><strong>Octal (Base 8):</strong> Uses 8 symbols {0, 1, ..., 7}.</li>
                                    <li><strong>Hexadecimal (Base 16):</strong> Uses 16 symbols {0, 1, ..., 9, A, B, C, D, E, F}.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Conversion Examples</h3>
                        <h4>Convert from Any Base to Decimal</h4>
                        <p>Rule: Multiply each digit by (base)<sup>position</sup> and sum the results.</p>
                        <pre><strong>Example 1: (11001)₂ to decimal</strong>
N = 1×2⁴ + 1×2³ + 0×2² + 0×2¹ + 1×2⁰
  = 16  +  8   +  0   +  0   +  1
  = 25₁₀

<strong>Example 2: (2AE)₁₆ to decimal (A=10, E=14)</strong>
N = 2×16² + 10×16¹ + 14×16⁰
  = 2×256 + 10×16  + 14×1
  = 512   + 160    + 14
  = 686₁₀</pre>
                        <h4>Convert from Decimal to Any Base (Integer Part)</h4>
                        <p>Rule: <span class="highlight">Repeatedly divide</span> by the new base, take the remainders in reverse order.</p>
                        <pre><strong>Example: 35₁₀ to binary (divide by 2)</strong>
35 / 2 = 17 rem 1  ↑
17 / 2 = 8  rem 1  |
 8 / 2 = 4  rem 0  | Read in reverse
 4 / 2 = 2  rem 0  | order
 2 / 2 = 1  rem 0  |
 1 / 2 = 0  rem 1  ↑
Result: (100011)₂</pre>
                        <h4>Quick Conversion between Binary ↔ Octal ↔ Hexadecimal</h4>
                        <p>Rule: Group <span class="highlight">3 bits</span> for Octal and <span class="highlight">4 bits</span> for Hexadecimal.</p>
                        <pre><strong>Example 1: (10011100010)₂ to Hexadecimal (group of 4)</strong>
   100  1110  0010   (Pad with two leading zeros)
→ 0100  1110  0010
    ↓     ↓     ↓
    4     E     2
Result: (4E2)₁₆

<strong>Example 2: (101110010)₂ to Octal (group of 3)</strong>
  101  110  010
   ↓    ↓    ↓
   5    6    2
Result: (562)₈</pre>
                    `
                },
                questions: [
                     { q: { vi: "Trong một hệ số vị (positional number system), radix (base) là gì?", en: "In a positional number system, what is the radix (base)?"}, o: [ {vi: "Giá trị lớn nhất có thể biểu diễn bằng một chữ số.", en: "The maximum value representable by a single digit."}, {vi: "Số chữ số tối đa cho biểu diễn số nguyên.", en: "The maximum number of digits for an integer representation."}, {vi: "Số kí hiệu (symbols) trong hệ (số lượng chữ số khác nhau).", en: "The number of symbols in the system (the count of different digits)."}, {vi: "Tổng các giá trị chữ số trong một số.", en: "The sum of the digit values in a number."}], a: 2, explanation: {vi: "Radix (base) định nghĩa số lượng ký hiệu duy nhất được sử dụng trong hệ đếm đó. Ví dụ, hệ thập phân có base 10 vì nó dùng 10 ký hiệu (0-9).", en: "The radix (base) defines the number of unique symbols used in that number system. For example, the decimal system has a base of 10 because it uses 10 symbols (0-9)."}},
                    { q: { vi: "Hệ thập phân (decimal) có base bằng bao nhiêu?", en: "What is the base of the decimal system?"}, o: [ {vi: "2", en: "2"}, {vi: "8", en: "8"}, {vi: "10", en: "10"}, {vi: "16", en: "16"}], a: 2, explanation: {vi: "Hệ thập phân (decimal) quen thuộc với chúng ta sử dụng 10 chữ số từ 0 đến 9, do đó cơ số (base) của nó là 10.", en: "The familiar decimal system uses 10 digits from 0 to 9, so its base is 10."}},
                    { q: { vi: "Trong hệ nhị phân (binary), mỗi chữ số gọi là gì?", en: "In the binary system, what is each digit called?"}, o: [ {vi: "nibble", en: "nibble"}, {vi: "digit", en: "digit"}, {vi: "byte", en: "byte"}, {vi: "bit", en: "bit"}], a: 3, explanation: {vi: "Một chữ số trong hệ nhị phân được gọi là 'bit', viết tắt của 'binary digit'.", en: "A digit in the binary system is called a 'bit', which is short for 'binary digit'."}},
                    { q: { vi: "Ký tự 'B' trong hệ thập lục phân (hex) tương đương với giá trị thập phân nào?", en: "The character 'B' in the hexadecimal system is equivalent to which decimal value?"}, o: [ {vi: "10", en: "10"}, {vi: "11", en: "11"}, {vi: "12", en: "12"}, {vi: "13", en: "13"}], a: 1, explanation: {vi: "Trong hệ thập lục phân, các chữ cái A, B, C, D, E, F lần lượt biểu diễn các giá trị 10, 11, 12, 13, 14, 15.", en: "In hexadecimal, the letters A, B, C, D, E, F represent the values 10, 11, 12, 13, 14, 15, respectively."}},
                    { q: { vi: "Giá trị thập phân của (11001)₂ là:", en: "The decimal value of (11001)₂ is:"}, o: [ {vi: "25", en: "25"}, {vi: "27", en: "27"}, {vi: "29", en: "29"}, {vi: "31", en: "31"}], a: 0, explanation: {vi: "Tính toán: (1 × 2⁴) + (1 × 2³) + (0 × 2²) + (0 × 2¹) + (1 × 2⁰) = 16 + 8 + 0 + 0 + 1 = 25.", en: "Calculation: (1 × 2⁴) + (1 × 2³) + (0 × 2²) + (0 × 2¹) + (1 × 2⁰) = 16 + 8 + 0 + 0 + 1 = 25."}},
                    { q: { vi: "Giá trị lớn nhất có thể biểu diễn bằng một số nguyên không dấu (unsigned) với 5 bit là:", en: "The largest value that can be represented by a 5-bit unsigned integer is:"}, o: [ {vi: "16", en: "16"}, {vi: "31", en: "31"}, {vi: "63", en: "63"}, {vi: "127", en: "127"}], a: 1, explanation: {vi: "Với n bit, giá trị lớn nhất của số nguyên không dấu là 2ⁿ - 1. Với 5 bit, giá trị lớn nhất là 2⁵ - 1 = 32 - 1 = 31.", en: "With n bits, the maximum value of an unsigned integer is 2ⁿ - 1. With 5 bits, the maximum value is 2⁵ - 1 = 32 - 1 = 31."}},
                    { q: { vi: "Số bit tối thiểu cần để biểu diễn số thập phân 234 là:", en: "The minimum number of bits needed to represent the decimal number 234 is:"}, o: [ {vi: "7", en: "7"}, {vi: "8", en: "8"}, {vi: "9", en: "9"}, {vi: "10", en: "10"}], a: 1, explanation: {vi: "Ta cần tìm n sao cho 2ⁿ⁻¹ ≤ 234 < 2ⁿ. Ta có 2⁷ = 128 và 2⁸ = 256. Vậy, cần 8 bit để biểu diễn số 234.", en: "We need to find n such that 2ⁿ⁻¹ ≤ 234 < 2ⁿ. We have 2⁷ = 128 and 2⁸ = 256. Therefore, 8 bits are needed to represent the number 234."}},
                    { q: { vi: "(2AE)₁₆ bằng bao nhiêu trong hệ thập phân?", en: "(2AE)₁₆ is equal to what in decimal?"}, o: [ {vi: "546", en: "546"}, {vi: "686", en: "686"}, {vi: "742", en: "742"}, {vi: "814", en: "814"}], a: 1, explanation: {vi: "Tính toán: (2 × 16²) + (10 × 16¹) + (14 × 16⁰) = 2 × 256 + 160 + 14 = 512 + 160 + 14 = 686.", en: "Calculation: (2 × 16²) + (10 × 16¹) + (14 × 16⁰) = 2 × 256 + 160 + 14 = 512 + 160 + 14 = 686."}},
                    { q: { vi: "(1256)₈ bằng bao nhiêu trong hệ thập phân?", en: "(1256)₈ is equal to what in decimal?"}, o: [ {vi: "342", en: "342"}, {vi: "512", en: "512"}, {vi: "686", en: "686"}, {vi: "732", en: "732"}], a: 2, explanation: {vi: "Tính toán: (1 × 8³) + (2 × 8²) + (5 × 8¹) + (6 × 8⁰) = 512 + 128 + 40 + 6 = 686.", en: "Calculation: (1 × 8³) + (2 × 8²) + (5 × 8¹) + (6 × 8⁰) = 512 + 128 + 40 + 6 = 686."}},
                    { q: { vi: "Một chữ số thập lục phân (hex digit) tương ứng với bao nhiêu bit?", en: "One hexadecimal digit corresponds to how many bits?"}, o: [ {vi: "2 bit", en: "2 bit"}, {vi: "3 bit", en: "3 bit"}, {vi: "4 bit", en: "4 bit"}, {vi: "8 bit", en: "8 bit"}], a: 2, explanation: {vi: "Vì 16 = 2⁴, mỗi chữ số thập lục phân có thể biểu diễn một tổ hợp duy nhất của 4 bit. Đây là cơ sở cho việc chuyển đổi nhanh.", en: "Because 16 = 2⁴, each hexadecimal digit can represent a unique combination of 4 bits. This is the basis for fast conversion."}},
                    { q: { vi: "Chuyển (01101)₂ sang hệ bát phân (octal) sẽ là:", en: "Converting (01101)₂ to octal would be:"}, o: [ {vi: "(13)₈", en: "(13)₈"}, {vi: "(15)₈", en: "(15)₈"}, {vi: "(11)₈", en: "(11)₈"}, {vi: "(7)₈", en: "(7)₈"}], a: 1, explanation: {vi: "Gom nhóm 3 bit từ phải sang: 01 101. Thêm 0 vào bên trái: 001 101. 001₂ = 1₈, 101₂ = 5₈. Kết quả: (15)₈.", en: "Group 3 bits from the right: 01 101. Pad with a leading zero: 001 101. 001₂ = 1₈, 101₂ = 5₈. Result: (15)₈."}},
                    { q: { vi: "(1011000)₂ trong hệ thập phân là:", en: "Converting (1011000)₂ to decimal is:"}, o: [ {vi: "72", en: "72"}, {vi: "80", en: "80"}, {vi: "88", en: "88"}, {vi: "96", en: "96"}], a: 2, explanation: {vi: "Tính toán: (1 × 2⁶) + (0 × 2⁵) + (1 × 2⁴) + (1 × 2³) + (0 × 2²) + (0 × 2¹) + (0 × 2⁰) = 64 + 0 + 16 + 8 + 0 + 0 + 0 = 88.", en: "Calculation: (1 × 2⁶) + (0 × 2⁵) + (1 × 2⁴) + (1 × 2³) + (0 × 2²) + (0 × 2¹) + (0 × 2⁰) = 64 + 0 + 16 + 8 + 0 + 0 + 0 = 88."}},
                    { q: { vi: "(011110.01)₂ = ? (thập phân)", en: "(011110.01)₂ = ? (decimal)"}, o: [ {vi: "30.125", en: "30.125"}, {vi: "30.25", en: "30.25"}, {vi: "30.5", en: "30.5"}, {vi: "30.75", en: "30.75"}], a: 1, explanation: {vi: "Phần nguyên: 011110₂ = 16+8+4+2=30. Phần thập phân: .01₂ = 0*0.5 + 1*0.25 = 0.25. Kết hợp lại là 30.25.", en: "Integer part: 011110₂ = 16+8+4+2=30. Fractional part: .01₂ = 0*0.5 + 1*0.25 = 0.25. Combined, it's 30.25."}},
                    { q: { vi: "(111111.111)₂ = ? (thập phân)", en: "(111111.111)₂ = ? (decimal)"}, o: [ {vi: "63.5", en: "63.5"}, {vi: "63.75", en: "63.75"}, {vi: "63.875", en: "63.875"}, {vi: "64.0", en: "64.0"}], a: 2, explanation: {vi: "Phần nguyên: 111111₂ = 63. Phần thập phân: .111₂ = 0.5 + 0.25 + 0.125 = 0.875. Kết hợp lại là 63.875.", en: "Integer part: 111111₂ = 63. Fractional part: .111₂ = 0.5 + 0.25 + 0.125 = 0.875. Combined, it's 63.875."}},
                    { q: { vi: "Phương pháp chuyển phần nguyên của số thập phân sang hệ khác là gì?", en: "What is the method for converting the integer part of a decimal number to another base?"}, o: [ {vi: "Phép nhân lặp (repetitive multiplication)", en: "Repetitive multiplication"}, {vi: "Phép chia lặp (repetitive division)", en: "Repetitive division"}, {vi: "Thay thế bằng bảng giá trị", en: "Substitution using a value table"}, {vi: "Sắp nhóm theo 3 hoặc 4 bit", en: "Grouping by 3 or 4 bits"}], a: 1, explanation: {vi: "Để chuyển đổi phần nguyên, ta liên tục chia số đó cho cơ số mới và thu thập các số dư theo thứ tự ngược lại.", en: "To convert the integer part, we repeatedly divide the number by the new base and collect the remainders in reverse order."}},
                    { q: { vi: "Phương pháp chuyển phần phân số (fractional part) của số thập phân sang hệ khác là gì?", en: "What is the method for converting the fractional part of a decimal number to another base?"}, o: [ {vi: "Phép nhân lặp (repetitive multiplication)", en: "Repetitive multiplication"}, {vi: "Phép chia lặp (repetitive division)", en: "Repetitive division"}, {vi: "Dùng logarit", en: "Using logarithms"}, {vi: "Dùng phép chia dư", en: "Using modulus"}], a: 0, explanation: {vi: "Để chuyển đổi phần thập phân, ta liên tục nhân phần thập phân đó với cơ số mới và thu thập các phần nguyên của kết quả.", en: "To convert the fractional part, we repeatedly multiply the fractional part by the new base and collect the integer parts of the results."}},
                    { q: { vi: "(101.11)₂ tương đương bao nhiêu trong hệ thập phân?", en: "(101.11)₂ is equivalent to what in decimal?"}, o: [ {vi: "5.5", en: "5.5"}, {vi: "5.75", en: "5.75"}, {vi: "6.25", en: "6.25"}, {vi: "6.5", en: "6.5"}], a: 1, explanation: {vi: "Phần nguyên: 101₂ = 4+1=5. Phần thập phân: .11₂ = 1*0.5 + 1*0.25 = 0.75. Kết hợp lại là 5.75.", en: "Integer part: 101₂ = 4+1=5. Fractional part: .11₂ = 1*0.5 + 1*0.25 = 0.75. Combined, it's 5.75."}},
                    { q: { vi: "Số 35 (thập phân) bằng gì trong hệ nhị phân?", en: "What is the decimal number 35 in binary?"}, o: [ {vi: "100011", en: "100011"}, {vi: "100111", en: "100111"}, {vi: "101011", en: "101011"}, {vi: "110011", en: "110011"}], a: 0, explanation: {vi: "Chia 35 cho 2 liên tiếp: 35/2=17 dư 1, 17/2=8 dư 1, 8/2=4 dư 0, 4/2=2 dư 0, 2/2=1 dư 0, 1/2=0 dư 1. Đọc ngược: 100011.", en: "Repeatedly divide 35 by 2: 35/2=17 R 1, 17/2=8 R 1, 8/2=4 R 0, 4/2=2 R 0, 2/2=1 R 0, 1/2=0 R 1. Read backwards: 100011."}},
                    { q: { vi: "Số 126 (thập phân) bằng bao nhiêu trong hệ thập lục phân?", en: "What is the decimal number 126 in hexadecimal?"}, o: [ {vi: "7C", en: "7C"}, {vi: "7D", en: "7D"}, {vi: "7E", en: "7E"}, {vi: "7F", en: "7F"}], a: 2, explanation: {vi: "Chia 126 cho 16: 126 / 16 = 7 dư 14. 14 trong hệ thập lục phân là E. Kết quả là 7E.", en: "Divide 126 by 16: 126 / 16 = 7 with a remainder of 14. 14 in hexadecimal is E. The result is 7E."}},
                    { q: { vi: "0.625 (thập phân) chuyển sang nhị phân phần phân là:", en: "Converting 0.625 (decimal) to a binary fraction is:"}, o: [ {vi: "0.011", en: "0.011"}, {vi: "0.101", en: "0.101"}, {vi: "0.110", en: "0.110"}, {vi: "0.1001", en: "0.1001"}], a: 1, explanation: {vi: "Nhân 0.625 với 2: 0.625*2=1.25 (lấy 1), 0.25*2=0.5 (lấy 0), 0.5*2=1.0 (lấy 1). Kết quả: 0.101.", en: "Multiply 0.625 by 2: 0.625*2=1.25 (take 1), 0.25*2=0.5 (take 0), 0.5*2=1.0 (take 1). Result: 0.101."}},
                    { q: { vi: "Số chữ số hexa cần thiết để biểu diễn giá trị thập phân 234 là:", en: "The number of hex digits needed to represent the decimal value 234 is:"}, o: [ {vi: "1", en: "1"}, {vi: "2", en: "2"}, {vi: "3", en: "3"}, {vi: "4", en: "4"}], a: 1, explanation: {vi: "234 chia 16 được 14 dư 10. 14 là E, 10 là A. Kết quả là EA, cần 2 chữ số.", en: "234 divided by 16 is 14 remainder 10. 14 is E, 10 is A. The result is EA, which requires 2 digits."}},
                    { q: { vi: "Giá trị thập phân của địa chỉ dotted-decimal 17.234.34.14 là:", en: "The decimal value of the dotted-decimal address 17.234.34.14 is:"}, o: [ {vi: "30,055,6814", en: "30,055,6814"}, {vi: "300,556,814", en: "300,556,814"}, {vi: "3,005,568,14", en: "3,005,568,14"}, {vi: "30,055,681", en: "30,055,681"}], a: 1, explanation: {vi: "Tính: 17 × 256³ + 234 × 256² + 34 × 256¹ + 14 × 256⁰ = 300,556,814.", en: "Calculate: 17 × 256³ + 234 × 256² + 34 × 256¹ + 14 × 256⁰ = 300,556,814."}},
                    { q: { vi: "(AB2)₁₆ bằng bao nhiêu (thập phân)?", en: "(AB2)₁₆ is equal to what (decimal)?"}, o: [ {vi: "2738", en: "2738"}, {vi: "2580", en: "2580"}, {vi: "2802", en: "2802"}, {vi: "2914", en: "2914"}], a: 0, explanation: {vi: "Tính toán: (10 × 16²) + (11 × 16¹) + (2 × 16⁰) = 10 × 256 + 176 + 2 = 2560 + 176 + 2 = 2738.", en: "Calculation: (10 × 16²) + (11 × 16¹) + (2 × 16⁰) = 10 × 256 + 176 + 2 = 2560 + 176 + 2 = 2738."}},
                    { q: { vi: "(123)₁₆ = ? (thập phân)", en: "(123)₁₆ = ? (decimal)"}, o: [ {vi: "291", en: "291"}, {vi: "274", en: "274"}, {vi: "315", en: "315"}, {vi: "299", en: "299"}], a: 0, explanation: {vi: "Tính toán: (1 × 16²) + (2 × 16¹) + (3 × 16⁰) = 256 + 32 + 3 = 291.", en: "Calculation: (1 × 16²) + (2 × 16¹) + (3 × 16⁰) = 256 + 32 + 3 = 291."}},
                    { q: { vi: "(ABB)₁₆ = ? (thập phân)", en: "(ABB)₁₆ = ? (decimal)"}, o: [ {vi: "2747", en: "2747"}, {vi: "2738", en: "2738"}, {vi: "2779", en: "2779"}, {vi: "2811", en: "2811"}], a: 0, explanation: {vi: "Tính toán: (10 × 16²) + (11 × 16¹) + (11 × 16⁰) = 2560 + 176 + 11 = 2747.", en: "Calculation: (10 × 16²) + (11 × 16¹) + (11 × 16⁰) = 2560 + 176 + 11 = 2747."}},
                    { q: { vi: "(35E.E1)₁₆ ≈ ? (thập phân, làm tròn thích hợp)", en: "(35E.E1)₁₆ ≈ ? (decimal, with appropriate rounding)"}, o: [ {vi: "862.75", en: "862.75"}, {vi: "862.875", en: "862.875"}, {vi: "862.8789", en: "862.8789"}, {vi: "862.9", en: "862.9"}], a: 2, explanation: {vi: "Phần nguyên: 3*256 + 5*16 + 14 = 862. Phần thập phân: 14/16 + 1/256 ≈ 0.875 + 0.0039 = 0.8789.", en: "Integer part: 3*256 + 5*16 + 14 = 862. Fractional part: 14/16 + 1/256 ≈ 0.875 + 0.0039 = 0.8789."}},
                    { q: { vi: "(237)₈ = ? (thập phân)", en: "(237)₈ = ? (decimal)"}, o: [ {vi: "159", en: "159"}, {vi: "175", en: "175"}, {vi: "191", en: "191"}, {vi: "143", en: "143"}], a: 0, explanation: {vi: "Tính toán: (2 × 8²) + (3 × 8¹) + (7 × 8⁰) = 2 × 64 + 24 + 7 = 128 + 24 + 7 = 159.", en: "Calculation: (2 × 8²) + (3 × 8¹) + (7 × 8⁰) = 2 × 64 + 24 + 7 = 128 + 24 + 7 = 159."}},
                    { q: { vi: "(2731)₈ = ? (thập phân)", en: "(2731)₈ = ? (decimal)"}, o: [ {vi: "1379", en: "1379"}, {vi: "1497", en: "1497"}, {vi: "1501", en: "1501"}, {vi: "1605", en: "1605"}], a: 1, explanation: {vi: "Tính toán: (2 × 8³) + (7 × 8²) + (3 × 8¹) + (1 × 8⁰) = 1024 + 448 + 24 + 1 = 1497.", en: "Calculation: (2 × 8³) + (7 × 8²) + (3 × 8¹) + (1 × 8⁰) = 1024 + 448 + 24 + 1 = 1497."}},
                    { q: { vi: "(617.7)₈ = ? (thập phân)", en: "(617.7)₈ = ? (decimal)"}, o: [ {vi: "399.5", en: "399.5"}, {vi: "399.75", en: "399.75"}, {vi: "399.875", en: "399.875"}, {vi: "400.0", en: "400.0"}], a: 2, explanation: {vi: "Phần nguyên: 6*64 + 1*8 + 7 = 399. Phần thập phân: 7/8 = 0.875. Kết hợp: 399.875.", en: "Integer part: 6*64 + 1*8 + 7 = 399. Fractional part: 7/8 = 0.875. Combined: 399.875."}},
                    { q: { vi: "(21.11)₈ = ? (thập phân)", en: "(21.11)₈ = ? (decimal)"}, o: [ {vi: "17.140625", en: "17.140625"}, {vi: "17.125", en: "17.125"}, {vi: "17.25", en: "17.25"}, {vi: "17.0625", en: "17.0625"}], a: 0, explanation: {vi: "Phần nguyên: 2*8 + 1 = 17. Phần thập phân: 1/8 + 1/64 = 0.125 + 0.015625 = 0.140625. Kết hợp: 17.140625.", en: "Integer part: 2*8 + 1 = 17. Fractional part: 1/8 + 1/64 = 0.125 + 0.015625 = 0.140625. Combined: 17.140625."}},
                    { q: { vi: "1234 (thập phân) sang nhị phân là:", en: "1234 (decimal) to binary is:"}, o: [ {vi: "10011010010", en: "10011010010"}, {vi: "10011000110", en: "10011000110"}, {vi: "10011101010", en: "10011101010"}, {vi: "10011100100", en: "10011100100"}], a: 0, explanation: {vi: "Đây là bài tập chuyển đổi cơ bản. Kết quả đúng sau khi chia lặp cho 2 là 10011010010.", en: "This is a basic conversion exercise. The correct result after repeated division by 2 is 10011010010."}},
                    { q: { vi: "1156 (thập phân) sang bát phân (octal) là:", en: "1156 (decimal) to octal is:"}, o: [ {vi: "2144", en: "2144"}, {vi: "2204", en: "2204"}, {vi: "2244", en: "2244"}, {vi: "2104", en: "2104"}], a: 1, explanation: {vi: "Chia 1156 cho 8 liên tiếp: 1156/8=144 dư 4, 144/8=18 dư 0, 18/8=2 dư 2, 2/8=0 dư 2. Đọc ngược: 2204.", en: "Repeatedly divide 1156 by 8: 1156/8=144 R 4, 144/8=18 R 0, 18/8=2 R 2, 2/8=0 R 2. Read backwards: 2204."}},
                    { q: { vi: "567 (thập phân) sang hexa là:", en: "567 (decimal) to hex is:"}, o: [ {vi: "237", en: "237"}, {vi: "245", en: "245"}, {vi: "2A7", en: "2A7"}, {vi: "22F", en: "22F"}], a: 3, explanation: {vi: "567 / 16 = 35 dư 7. 35 / 16 = 2 dư 3. 2 / 16 = 0 dư 2. Đọc ngược: 237. Lỗi đáp án. 567 = 2*256 + 3*16 + 7 = 567. Đáp án đúng là 237.", en: "567 / 16 = 35 rem 7. 35 / 16 = 2 rem 3. 2 / 16 = 0 rem 2. Read backwards: 237. The answer key is wrong. The correct answer is 237."}},
                    { q: { vi: "Chuyển (1011000)₂ sang hex được:", en: "Convert (1011000)₂ to hex:"}, o: [ {vi: "5C", en: "5C"}, {vi: "58", en: "58"}, {vi: "50", en: "50"}, {vi: "1B", en: "1B"}], a: 1, explanation: {vi: "Gom nhóm 4 bit từ phải qua: 0101 1000. 0101₂ = 5₁₀. 1000₂ = 8₁₀. Kết quả là 58₁₆.", en: "Group into 4 bits from the right: 0101 1000. 0101₂ = 5₁₀. 1000₂ = 8₁₀. The result is 58₁₆."}},
                    { q: { vi: "Chuyển (1011000)₂ sang octal được:", en: "Convert (1011000)₂ to octal:"}, o: [ {vi: "130", en: "130"}, {vi: "128", en: "128"}, {vi: "150", en: "150"}, {vi: "160", en: "160"}], a: 0, explanation: {vi: "Gom nhóm 3 bit từ phải qua: 001 011 000. 001₂=1, 011₂=3, 000₂=0. Kết quả là 130₈.", en: "Group into 3 bits from the right: 001 011 000. 001₂=1, 011₂=3, 000₂=0. The result is 130₈."}},
                    { q: { vi: "Trong chuyển đổi nhị phân ↔ octal, một chữ số octal tương ứng với bao nhiêu bit?", en: "In binary ↔ octal conversion, one octal digit corresponds to how many bits?"}, o: [ {vi: "1 bit", en: "1 bit"}, {vi: "2 bit", en: "2 bit"}, {vi: "3 bit", en: "3 bit"}, {vi: "4 bit", en: "4 bit"}], a: 2, explanation: {vi: "Vì 8 = 2³, nên mỗi 3 bit nhị phân sẽ tương ứng với một chữ số bát phân.", en: "Because 8 = 2³, each 3 binary bits correspond to one octal digit."}},
                    { q: { vi: "Số nguyên lớn nhất có thể biểu diễn với 6 chữ số ở hệ thập phân là:", en: "The largest integer representable with 6 decimal digits is:"}, o: [ {vi: "99999", en: "99999"}, {vi: "999999", en: "999999"}, {vi: "1000000", en: "1000000"}, {vi: "9999", en: "9999"}], a: 1, explanation: {vi: "Với 6 chữ số, số lớn nhất là 999,999. Công thức là 10⁶ - 1.", en: "With 6 digits, the largest number is 999,999. The formula is 10⁶ - 1."}},
                    { q: { vi: "Số lớn nhất có thể biểu diễn với 5 chữ số ở hệ bát phân (octal) là:", en: "The largest number representable with 5 octal digits is:"}, o: [ {vi: "32766", en: "32766"}, {vi: "32767", en: "32767"}, {vi: "32768", en: "32768"}, {vi: "32769", en: "32769"}], a: 1, explanation: {vi: "Giá trị lớn nhất là 8⁵ - 1 = 32768 - 1 = 32767.", en: "The largest value is 8⁵ - 1 = 32768 - 1 = 32767."}},
                    { q: { vi: "Số bit tối thiểu cần để lưu mọi số < 1000 là:", en: "The minimum number of bits needed to store any number < 1000 is:"}, o: [ {vi: "9", en: "9"}, {vi: "10", en: "10"}, {vi: "11", en: "11"}, {vi: "12", en: "12"}], a: 1, explanation: {vi: "Cần tìm n sao cho 2ⁿ ≥ 1000. 2⁹=512 (không đủ), 2¹⁰=1024 (đủ). Vậy cần 10 bit.", en: "We need to find n such that 2ⁿ ≥ 1000. 2⁹=512 (not enough), 2¹⁰=1024 (enough). So, 10 bits are needed."}},
                    { q: { vi: "Số bit tối thiểu để lưu mọi số < 100000 là:", en: "The minimum number of bits to store any number < 100000 is:"}, o: [ {vi: "16", en: "16"}, {vi: "17", en: "17"}, {vi: "18", en: "18"}, {vi: "19", en: "19"}], a: 1, explanation: {vi: "Cần ⌈log₂(100000)⌉ bits. log₂(100000) ≈ 16.6. Làm tròn lên là 17 bits.", en: "We need ⌈log₂(100000)⌉ bits. log₂(100000) ≈ 16.6. Rounding up gives 17 bits."}},
                    { q: { vi: "Số bit tối thiểu để lưu mọi số < 64 là:", en: "The minimum number of bits to store any number < 64 is:"}, o: [ {vi: "5", en: "5"}, {vi: "6", en: "6"}, {vi: "7", en: "7"}, {vi: "8", en: "8"}], a: 1, explanation: {vi: "Cần tìm n sao cho 2ⁿ ≥ 64. 2⁶=64. Vậy cần 6 bit để biểu diễn các số từ 0 đến 63.", en: "We need to find n such that 2ⁿ ≥ 64. 2⁶=64. So, 6 bits are needed to represent numbers from 0 to 63."}},
                    { q: { vi: "Số bit tối thiểu để lưu mọi số < 256 là:", en: "The minimum number of bits to store any number < 256 is:"}, o: [ {vi: "7", en: "7"}, {vi: "8", en: "8"}, {vi: "9", en: "9"}, {vi: "10", en: "10"}], a: 1, explanation: {vi: "Cần tìm n sao cho 2ⁿ ≥ 256. 2⁸=256. Vậy cần 8 bit để biểu diễn các số từ 0 đến 255.", en: "We need to find n such that 2ⁿ ≥ 256. 2⁸=256. So, 8 bits are needed to represent numbers from 0 to 255."}},
                    { q: { vi: "Chuyển 0.375 (thập phân) sang nhị phân (phần phân) là:", en: "Convert 0.375 (decimal) to a binary fraction:"}, o: [ {vi: "0.011", en: "0.011"}, {vi: "0.101", en: "0.101"}, {vi: "0.110", en: "0.110"}, {vi: "0.0110", en: "0.0110"}], a: 0, explanation: {vi: "Nhân lặp: 0.375*2=0.75 (lấy 0), 0.75*2=1.5 (lấy 1), 0.5*2=1.0 (lấy 1). Kết quả 0.011.", en: "Repeated multiplication: 0.375*2=0.75 (take 0), 0.75*2=1.5 (take 1), 0.5*2=1.0 (take 1). Result 0.011."}},
                    { q: { vi: "Số thập phân 7.1875 sang nhị phân là:", en: "The decimal number 7.1875 to binary is:"}, o: [ {vi: "111.0011", en: "111.0011"}, {vi: "111.001", en: "111.001"}, {vi: "111.00101", en: "111.00101"}, {vi: "111.0010", en: "111.0010"}], a: 0, explanation: {vi: "Phần nguyên: 7=111₂. Phần thập phân: 0.1875*2=0.375(0), 0.375*2=0.75(0), 0.75*2=1.5(1), 0.5*2=1.0(1) -> .0011. Kết quả 111.0011.", en: "Integer part: 7=111₂. Fractional part: 0.1875*2=0.375(0), 0.375*2=0.75(0), 0.75*2=1.5(1), 0.5*2=1.0(1) -> .0011. Result 111.0011."}},
                    { q: { vi: "Theo công thức trong chương, số chữ số K cần trong base b để biểu diễn số N là:", en: "According to the formula in the chapter, the number of digits K needed in base b to represent the number N is:"}, o: [ {vi: "K = ⌊log_b N⌋", en: "K = ⌊log_b N⌋"}, {vi: "K = ⌈log_b N⌉", en: "K = ⌈log_b N⌉"}, {vi: "K = log_b (N+1)", en: "K = log_b (N+1)"}, {vi: "K = N * log_b", en: "K = N * log_b"}], a: 1, explanation: {vi: "Công thức sử dụng hàm ceiling (làm tròn lên) của logarit cơ số b của N. Ví dụ: log₂1000 ≈ 9.96, làm tròn lên là 10 bit.", en: "The formula uses the ceiling function of the base-b logarithm of N. For example: log₂1000 ≈ 9.96, which rounds up to 10 bits."}},
                    { q: { vi: "Giá trị chữ số của Roman 'XIX' là:", en: "The value of the Roman numeral 'XIX' is:"}, o: [ {vi: "16", en: "16"}, {vi: "18", en: "18"}, {vi: "19", en: "19"}, {vi: "21", en: "21"}], a: 2, explanation: {vi: "XIX được đọc là 10 (X) + (10-1) (IX) = 10 + 9 = 19.", en: "XIX is read as 10 (X) + (10-1) (IX) = 10 + 9 = 19."}},
                    { q: { vi: "Roman numeral 'MMVII' tương đương với:", en: "The Roman numeral 'MMVII' is equivalent to:"}, o: [ {vi: "2005", en: "2005"}, {vi: "2006", en: "2006"}, {vi: "2007", en: "2007"}, {vi: "2010", en: "2010"}], a: 2, explanation: {vi: "MMVII = 1000 + 1000 + 5 + 1 + 1 = 2007.", en: "MMVII = 1000 + 1000 + 5 + 1 + 1 = 2007."}},
                    { q: { vi: "Việc thiếu ký số '0' trong một hệ (như một số hệ cổ) gây ra vấn đề gì chủ yếu?", en: "The lack of a '0' digit in a number system (like some ancient ones) primarily causes what issue?"}, o: [ {vi: "Không thể cộng hai số", en: "Cannot add two numbers"}, {vi: "Không thể biểu diễn số âm", en: "Cannot represent negative numbers"}, {vi: "Không phân biệt vị trí (place value) dẫn tới mơ hồ về trị giá các chữ số", en: "Ambiguity in place value, leading to confusion about digit values"}, {vi: "Không thể nhân hai số", en: "Cannot multiply two numbers"}], a: 2, explanation: {vi: "Nếu không có số 0, rất khó để phân biệt giữa các số như 25, 205, và 250 vì không có ký tự để giữ chỗ trống.", en: "Without a zero, it's difficult to distinguish between numbers like 25, 205, and 250 because there is no character to hold an empty place."}},
                    { q: { vi: "Trong số các hệ sau, hệ nào là không vị trí (nonpositional)?", en: "Among the following systems, which one is nonpositional?"}, o: [ {vi: "Decimal", en: "Decimal"}, {vi: "Binary", en: "Binary"}, {vi: "Roman numerals", en: "Roman numerals"}, {vi: "Hexadecimal", en: "Hexadecimal"}], a: 2, explanation: {vi: "Trong hệ La Mã, giá trị của một ký hiệu (ví dụ: X luôn là 10) không phụ thuộc hoàn toàn vào vị trí của nó, mà phụ thuộc vào các quy tắc cộng trừ với các ký hiệu bên cạnh.", en: "In the Roman system, the value of a symbol (e.g., X is always 10) doesn't strictly depend on its position, but on rules of addition/subtraction with adjacent symbols."}}
                ]
            },
            chapter3: {
                theory: {
                    vi: `
                        <h2>Chương 3: Lưu trữ Dữ liệu</h2>
                        <h3>1. Các kiểu dữ liệu cơ bản</h3>
                        <ul>
                            <li>Máy tính xử lý nhiều loại dữ liệu: Số (Numbers), Văn bản (Text), Âm thanh (Audio), Hình ảnh (Images), Video.</li>
                            <li>Tất cả các loại dữ liệu này đều được chuyển đổi thành một dạng duy nhất để lưu trữ: <span class="highlight">chuỗi bit (bit pattern)</span>.</li>
                        </ul>
                        <h3>2. Lưu trữ số nguyên (Storing Integers)</h3>
                        <ul>
                            <li><strong>Số nguyên không dấu (Unsigned Integers):</strong>
                                <ul><li>Chỉ biểu diễn số không âm (0 và các số dương). Một chuỗi n bit có thể biểu diễn các giá trị từ 0 đến 2ⁿ-1.</li></ul>
                            </li>
                            <li><strong>Số nguyên có dấu (Signed Integers):</strong>
                                <ul>
                                    <li><strong>Sign-and-Magnitude:</strong> Bit ngoài cùng bên trái dùng cho dấu (0 là +, 1 là -), các bit còn lại biểu diễn độ lớn. Nhược điểm: có hai giá trị zero (+0 và -0).</li>
                                    <li><span class="highlight">Two's Complement (Bù 2):</span> Phương pháp chuẩn hiện nay.
                                        <ul>
                                            <li>Số dương được biểu diễn như số không dấu (với bit dấu là 0).</li>
                                            <li>Số âm được biểu diễn bằng cách lấy bù 2 của số dương tương ứng. (Cách lấy bù 2: Đảo tất cả các bit rồi cộng 1).</li>
                                            <li>Ưu điểm: Chỉ có một giá trị zero, phép trừ có thể thực hiện bằng phép cộng, giúp đơn giản hóa mạch logic.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                             <li><strong>Tràn số (Overflow):</strong> Xảy ra khi kết quả của một phép toán vượt ra ngoài phạm vi biểu diễn cho phép. Ví dụ: cộng hai số 8-bit dương lớn ra kết quả có bit dấu là 1 (số âm).</li>
                        </ul>
                        <h3>3. Lưu trữ số thực (Storing Reals)</h3>
                        <ul>
                            <li>
                                <strong>Floating-Point (Dấu phẩy động) - Chuẩn IEEE 754:</strong>
                                <ul>
                                    <li>Biểu diễn một số dưới dạng khoa học: (Dấu) × (Định trị) × (Cơ số)<sup>Số mũ</sup>.</li>
                                    <li>Một số thực được lưu trữ thành 3 phần:
                                        <ol>
                                            <li><strong>Sign (S):</strong> 1 bit (0 cho dương, 1 cho âm).</li>
                                            <li><strong>Exponent (E):</strong> Số mũ, được lưu trữ bằng phương pháp <span class="highlight">Excess representation</span> (cộng một số bias để luôn là số dương).</li>
                                            <li><strong>Mantissa (M):</strong> Phần định trị (phần sau dấu chấm của số đã được chuẩn hóa).</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    `,
                    en: `
                        <h2>Chapter 3: Data Storage</h2>
                        <h3>1. Basic Data Types</h3>
                        <ul>
                            <li>Computers process various data types: Numbers, Text, Audio, Images, Video.</li>
                            <li>All these data types are converted into a single uniform representation for storage: the <span class="highlight">bit pattern</span>.</li>
                        </ul>
                        <h3>2. Storing Integers</h3>
                        <ul>
                            <li><strong>Unsigned Integers:</strong>
                                <ul><li>Represent only non-negative numbers (0 and positives). An n-bit pattern can represent values from 0 to 2ⁿ-1.</li></ul>
                            </li>
                            <li><strong>Signed Integers:</strong>
                                <ul>
                                    <li><strong>Sign-and-Magnitude:</strong> The leftmost bit is for the sign (0 for +, 1 for -), the rest represent the magnitude. Drawback: has two representations of zero (+0 and -0).</li>
                                    <li><span class="highlight">Two's Complement:</span> The standard method today.
                                        <ul>
                                            <li>Positive numbers are represented like unsigned integers (with a sign bit of 0).</li>
                                            <li>Negative numbers are represented by taking the two's complement of the corresponding positive number. (How to take two's complement: Invert all bits then add 1).</li>
                                            <li>Advantages: Only one representation of zero, subtraction can be performed by addition, simplifying logic circuits.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Overflow:</strong> Occurs when the result of an operation falls outside the representable range. E.g., adding two large positive 8-bit numbers results in a number with a sign bit of 1 (negative).</li>
                        </ul>
                        <h3>3. Storing Reals</h3>
                        <ul>
                            <li>
                                <strong>Floating-Point - IEEE 754 Standard:</strong>
                                <ul>
                                    <li>Represents a number in scientific notation: (Sign) × (Mantissa) × (Base)<sup>Exponent</sup>.</li>
                                    <li>A real number is stored in 3 parts:
                                        <ol>
                                            <li><strong>Sign (S):</strong> 1 bit (0 for positive, 1 for negative).</li>
                                            <li><strong>Exponent (E):</strong> Stored using <span class="highlight">Excess representation</span> (a bias is added to make it always positive).</li>
                                            <li><strong>Mantissa (M):</strong> The fractional part of the normalized number.</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    `
                },
                questions: [
                    { q: { vi: "Khi được lưu trữ trong máy tính, tất cả các loại dữ liệu đều được chuyển đổi thành một dạng biểu diễn thống nhất. Dạng biểu diễn chung này được gọi là gì?", en: "When stored in a computer, all data types are converted into a uniform representation. What is this common representation called?"}, o: [{vi: "Một byte (A byte)", en: "A byte"}, {vi: "Một mẫu bit (A bit pattern)", en: "A bit pattern"}, {vi: "Một từ (A word)", en: "A word"}, {vi: "Một con số (A number)", en: "A number"}], a: 1, explanation: {vi: "Dù là số, chữ, hay hình ảnh, tất cả đều được mã hóa thành các chuỗi 0 và 1, được gọi là mẫu bit.", en: "Whether it's a number, text, or image, everything is encoded into strings of 0s and 1s, known as a bit pattern."} },
                    { q: { vi: "Đơn vị dữ liệu nhỏ nhất có thể được lưu trữ trong máy tính là gì?", en: "What is the smallest unit of data that can be stored in a computer?"}, o: [{vi: "Byte", en: "Byte"}, {vi: "Bit", en: "Bit"}, {vi: "Word", en: "Word"}, {vi: "Nibble", en: "Nibble"}], a: 1, explanation: {vi: "Một bit (binary digit) là đơn vị cơ bản nhất, chỉ có thể có giá trị 0 hoặc 1.", en: "A bit (binary digit) is the most fundamental unit, capable of holding only a value of 0 or 1."} },
                    { q: { vi: "Theo quy ước, một mẫu bit gồm tám bit được gọi là một ________.", en: "By tradition, a bit pattern with eight bits is called a ________."}, o: [{vi: "Từ (Word)", en: "Word"}, {vi: "Bit", en: "Bit"}, {vi: "Số nguyên (Integer)", en: "Integer"}, {vi: "Byte", en: "Byte"}], a: 3, explanation: {vi: "8 bit được nhóm lại thành một đơn vị gọi là byte. Đây là đơn vị đo lường bộ nhớ phổ biến nhất.", en: "8 bits are grouped into a unit called a byte. It's the most common unit of memory measurement."} },
                    { q: { vi: "Theo giáo trình, loại nào sau đây KHÔNG được liệt kê là một trong năm loại dữ liệu chính?", en: "According to the textbook, which of the following is NOT listed as one of the five main data types?"}, o: [{vi: "Số (Numbers)", en: "Numbers"}, {vi: "Văn bản (Text)", en: "Text"}, {vi: "Chương trình (Programs)", en: "Programs"}, {vi: "Video", en: "Video"}], a: 2, explanation: {vi: "Năm loại dữ liệu chính là Số, Văn bản, Âm thanh, Hình ảnh, và Video. Chương trình là tập hợp các lệnh để xử lý dữ liệu, không phải là bản thân dữ liệu.", en: "The five main data types are Numbers, Text, Audio, Images, and Video. A program is a set of instructions that processes data, not the data itself."} },
                    { q: { vi: "Thuật ngữ 'multimedia' (đa phương tiện) được sử dụng để định nghĩa thông tin chứa những thành phần nào sau đây?", en: "'Multimedia' is a term used to define information that contains which of the following?"}, o: [{vi: "Chỉ âm thanh và video", en: "Only audio and video"}, {vi: "Chỉ hình ảnh và văn bản", en: "Only images and text"}, {vi: "Số, văn bản, âm thanh, hình ảnh và video", en: "Numbers, text, audio, images, and video"}, {vi: "Chỉ số và văn bản", en: "Only numbers and text"}], a: 2, explanation: {vi: "Multimedia là sự kết hợp của nhiều loại phương tiện truyền thông khác nhau, bao gồm tất cả các loại dữ liệu được liệt kê.", en: "Multimedia is a combination of various media types, encompassing all the listed data types."} },
                    { q: { vi: "Phương pháp biểu diễn nào thường được sử dụng để lưu trữ số nguyên trong bộ nhớ máy tính, trong đó dấu thập phân được giả định nhưng không được lưu trữ?", en: "Which representation is typically used to store integers in computer memory, where the decimal point is assumed but not stored?"}, o: [{vi: "Biểu diễn dấu phẩy động (Floating-point representation)", en: "Floating-point representation"}, {vi: "Ký hiệu khoa học (Scientific notation)", en: "Scientific notation"}, {vi: "Biểu diễn dấu phẩy tĩnh (Fixed-point representation)", en: "Fixed-point representation"}, {vi: "Biểu diễn dấu-lượng (Sign-and-magnitude representation)", en: "Sign-and-magnitude representation"}], a: 2, explanation: {vi: "Số nguyên được coi là có dấu phẩy ở cuối (ví dụ: 123.), vị trí này là cố định, do đó gọi là biểu diễn dấu phẩy tĩnh (fixed-point).", en: "An integer is considered to have a decimal point at the end (e.g., 123.). This position is fixed, hence the name fixed-point representation."} },
                    { q: { vi: "Một số nguyên không dấu (unsigned integer) là một số nguyên:", en: "An unsigned integer is an integer that:"}, o: [{vi: "Có thể là số dương hoặc số âm.", en: "Can be positive or negative."}, {vi: "Chỉ có thể là 0 hoặc số dương.", en: "Can only be 0 or positive."}, {vi: "Phải lớn hơn 0.", en: "Must be greater than 0."}, {vi: "Có phần thập phân cố định.", en: "Has a fixed fractional part."}], a: 1, explanation: {vi: "'Unsigned' có nghĩa là 'không có dấu', do đó nó không thể biểu diễn số âm. Nó bao gồm số 0 và tất cả các số dương.", en: "'Unsigned' means 'without a sign', therefore it cannot represent negative numbers. It includes 0 and all positive numbers."} },
                    { q: { vi: "Tình trạng nào xảy ra khi bạn cố gắng lưu trữ một số nguyên lớn hơn giá trị tối đa có thể chứa trong số bit được cấp phát?", en: "What condition occurs when you try to store an integer that is larger than the maximum value that can be held in the allocated number of bits?"}, o: [{vi: "Tràn dưới (Underflow)", en: "Underflow"}, {vi: "Tràn số (Overflow)", en: "Overflow"}, {vi: "Cắt cụt (Truncation)", en: "Truncation"}, {vi: "Sửa lỗi (Error correction)", en: "Error correction"}], a: 1, explanation: {vi: "Overflow (tràn số) xảy ra khi kết quả vượt quá giới hạn trên của phạm vi biểu diễn. Underflow xảy ra khi nó nhỏ hơn giới hạn dưới.", en: "Overflow occurs when a result exceeds the upper bound of the representable range. Underflow occurs when it goes below the lower bound."} },
                    { q: { vi: "Trong biểu diễn dấu-lượng (sign-and-magnitude), bit ngoài cùng bên trái biểu thị điều gì?", en: "In sign-and-magnitude representation, what does the leftmost bit represent?"}, o: [{vi: "Độ lớn của số", en: "The magnitude of the number"}, {vi: "Dấu của số", en: "The sign of the number"}, {vi: "Bit có trọng số thấp nhất", en: "The least significant bit"}, {vi: "Một phần giá trị của số", en: "Part of the number's value"}], a: 1, explanation: {vi: "Đúng như tên gọi, một bit được dành riêng cho 'dấu' (sign) (0 cho +, 1 cho -) và các bit còn lại dành cho 'độ lớn' (magnitude).", en: "As the name implies, one bit is dedicated to the 'sign' (0 for +, 1 for -) and the rest of the bits are for the 'magnitude'."} },
                    { q: { vi: "Nhược điểm đáng kể của biểu diễn dấu-lượng (sign-and-magnitude) là gì?", en: "What is a significant drawback of sign-and-magnitude representation?"}, o: [{vi: "Nó không thể biểu diễn số âm.", en: "It cannot represent negative numbers."}, {vi: "Khó thực hiện các phép toán số học.", en: "It is difficult to perform arithmetic operations."}, {vi: "Nó có hai cách biểu diễn khác nhau cho số không (+0 và -0).", en: "It has two different representations for zero (+0 and -0)."}, {vi: "Nó chỉ có thể biểu diễn một dải số nhỏ.", en: "It can only represent a small range of numbers."}], a: 2, explanation: {vi: "Việc có hai cách biểu diễn cho cùng một giá trị (số 0) là 0000... và 1000... gây ra sự phức tạp không cần thiết cho phần cứng và phần mềm.", en: "Having two representations for the same value (zero), 0000... and 1000..., causes unnecessary complexity for hardware and software."} },
                    { q: { vi: "Hầu hết các máy tính ngày nay sử dụng phương pháp biểu diễn số nguyên nào để lưu trữ số nguyên có dấu?", en: "Which integer representation do most computers today use to store signed integers?"}, o: [{vi: "Biểu diễn không dấu (Unsigned representation)", en: "Unsigned representation"}, {vi: "Biểu diễn dấu-lượng (Sign-and-magnitude representation)", en: "Sign-and-magnitude representation"}, {vi: "Biểu diễn bù hai (Two's complement representation)", en: "Two's complement representation"}, {vi: "Biểu diễn bù một (One's complement representation)", en: "One's complement representation"}], a: 2, explanation: {vi: "Bù hai (Two's complement) là tiêu chuẩn vì nó giải quyết vấn đề hai số 0 và đơn giản hóa mạch logic cho phép trừ (biến nó thành phép cộng).", en: "Two's complement is the standard because it solves the two-zeros problem and simplifies the logic circuit for subtraction (by turning it into addition)."}},
                    { q: { vi: "Trong biểu diễn bù hai (two's complement), dấu của một số nguyên được xác định như thế nào?", en: "In two's complement representation, how is the sign of an integer determined?"}, o: [{vi: "Bằng bit ngoài cùng bên phải.", en: "By the rightmost bit."}, {vi: "Bằng tổng của tất cả các bit.", en: "By the sum of all bits."}, {vi: "Nó được lưu trữ riêng biệt.", en: "It is stored separately."}, {vi: "Bằng bit ngoài cùng bên trái.", en: "By the leftmost bit."}], a: 3, explanation: {vi: "Giống như dấu-lượng, bit ngoài cùng bên trái (MSB) đóng vai trò là bit dấu (0 cho không âm, 1 cho âm). Tuy nhiên, nó cũng là một phần của giá trị.", en: "Like sign-and-magnitude, the leftmost bit (MSB) acts as the sign bit (0 for non-negative, 1 for negative). However, it is also part of the value."}},
                    { q: { vi: "Có bao nhiêu cách biểu diễn cho số không trong ký hiệu bù hai (two's complement)?", en: "How many representations for zero exist in two's complement notation?"}, o: [{vi: "Hai (+0 và -0)", en: "Two (+0 and -0)"}, {vi: "Chỉ có một", en: "Only one"}, {vi: "Không có, số không không thể được biểu diễn", en: "None, zero cannot be represented"}, {vi: "Tùy thuộc vào số lượng bit", en: "It depends on the number of bits"}], a: 1, explanation: {vi: "Đây là một trong những ưu điểm lớn nhất của bù hai. Chỉ có một mẫu bit duy nhất cho số 0 (tất cả các bit đều là 0).", en: "This is one of the biggest advantages of two's complement. There is only a single bit pattern for zero (all bits are 0)."}},
                    { q: { vi: "Sử dụng biểu diễn số nguyên không dấu 8-bit, giá trị thập phân của số nhị phân 00101011 là bao nhiêu?", en: "Using 8-bit unsigned integer representation, what is the decimal value of the binary number 00101011?"}, o: [{vi: "33", en: "33"}, {vi: "43", en: "43"}, {vi: "53", en: "53"}, {vi: "27", en: "27"}], a: 1, explanation: {vi: "Tính toán: 32 + 8 + 2 + 1 = 43. Đây là một phép chuyển đổi nhị phân sang thập phân đơn giản.", en: "Calculation: 32 + 8 + 2 + 1 = 43. This is a straightforward binary-to-decimal conversion."}},
                    { q: { vi: "Biểu diễn bù hai 8-bit của số thập phân -28 là gì?", en: "What is the 8-bit two's complement representation of the decimal number -28?"}, o: [{vi: "00011100", en: "00011100"}, {vi: "10011100", en: "10011100"}, {vi: "11100011", en: "11100011"}, {vi: "11100100", en: "11100100"}], a: 3, explanation: {vi: "Bước 1: +28 = 00011100. Bước 2: Đảo bit (bù một) -> 11100011. Bước 3: Cộng 1 -> 11100100.", en: "Step 1: +28 = 00011100. Step 2: Invert bits (one's complement) -> 11100011. Step 3: Add 1 -> 11100100."}},
                    { q: { vi: "Tại sao biểu diễn dấu phẩy tĩnh (fixed-point) không lý tưởng để lưu trữ các số thực có phần nguyên rất lớn hoặc phần thập phân rất nhỏ?", en: "Why is fixed-point representation not ideal for storing real numbers with very large integer parts or very small fractional parts?"}, o: [{vi: "Nó đòi hỏi quá nhiều bit.", en: "It requires too many bits."}, {vi: "Nó có thể dẫn đến mất độ chính xác hoặc độ chuẩn xác.", en: "It can lead to a loss of precision or accuracy."}, {vi: "Nó không thể biểu diễn số thực âm.", en: "It cannot represent negative real numbers."}, {vi: "Nó chậm hơn các phương pháp khác.", en: "It is slower than other methods."}], a: 1, explanation: {vi: "Vì vị trí của dấu phẩy là cố định, bạn phải chọn trước số bit cho phần nguyên và phần thập phân. Điều này giới hạn cả phạm vi (cho số lớn) và độ chính xác (cho số nhỏ).", en: "Because the point's position is fixed, you must pre-allocate bits for the integer and fractional parts. This limits both the range (for large numbers) and the precision (for small numbers)."}},
                    { q: { vi: "Một biểu diễn dấu phẩy động (floating-point) của một số bao gồm ba phần nào?", en: "A floating-point representation of a number consists of which three parts?"}, o: [{vi: "Dấu, phần nguyên và phần thập phân (Sign, integer, and fraction)", en: "Sign, integer, and fraction"}, {vi: "Dấu, số mũ và phần định trị (Sign, exponent, and mantissa)", en: "Sign, exponent, and mantissa"}, {vi: "Phần định trị, số mũ và dấu thập phân (Mantissa, exponent, and decimal point)", en: "Mantissa, exponent, and decimal point"}, {vi: "Phần nguyên, dấu thập phân và phần thập phân (Integer, decimal point, and fraction)", en: "Integer, decimal point, and fraction"}], a: 1, explanation: {vi: "Ghi nhớ 3 thành phần của ký hiệu khoa học: Dấu (+/-), Định trị (số chính), và Số mũ (lũy thừa của cơ số).", en: "Remember the 3 parts of scientific notation: Sign (+/-), Mantissa (the significant digits), and Exponent (the power of the base)."}},
                    { q: { vi: "Trong ngữ cảnh của số dấu phẩy động, 'chuẩn hóa' (normalization) là gì?", en: "In the context of floating-point numbers, what is 'normalization'?"}, o: [{vi: "Quá trình làm tròn một số đến số nguyên gần nhất.", en: "The process of rounding a number to the nearest integer."}, {vi: "Quá trình đảm bảo phần định trị chỉ có một chữ số khác không ở bên trái dấu chấm.", en: "The process of ensuring the mantissa has only one non-zero digit to the left of the point."}, {vi: "Quá trình chuyển đổi một số từ thập phân sang nhị phân.", en: "The process of converting a number from decimal to binary."}, {vi: "Quá trình cộng thêm một độ lệch (bias) vào số mũ.", en: "The process of adding a bias to the exponent."}], a: 1, explanation: {vi: "Chuẩn hóa tạo ra một định dạng duy nhất cho mỗi số, ví dụ, 123.45 được chuẩn hóa thành 1.2345 x 10². Điều này giúp việc lưu trữ và so sánh trở nên nhất quán.", en: "Normalization creates a unique format for every number, e.g., 123.45 is normalized to 1.2345 x 10². This makes storage and comparison consistent."}},
                    { q: { vi: "Trong một số dấu phẩy động nhị phân đã được chuẩn hóa, ba mẩu thông tin nào thực sự được lưu trữ?", en: "In a normalized binary floating-point number, which three pieces of information are actually stored?"}, o: [{vi: "Dấu, số mũ và tất cả các chữ số của số đó", en: "The sign, the exponent, and all the digits of the number"}, {vi: "Dấu, số mũ và phần định trị (mantissa)", en: "The sign, the exponent, and the mantissa"}, {vi: "Chữ số đầu tiên, dấu thập phân và số mũ", en: "The first digit, the decimal point, and the exponent"}, {vi: "Dấu, phần định trị và cơ số", en: "The sign, the mantissa, and the base"}], a: 1, explanation: {vi: "Ba thành phần này đủ để tái tạo lại số ban đầu. Cơ số (luôn là 2) và dấu chấm được ngầm hiểu.", en: "These three components are sufficient to reconstruct the original number. The base (always 2) and the point are implied."}},
                    { q: { vi: "Chuẩn IEEE cho số dấu phẩy động đơn chính xác (single-precision) sử dụng tổng cộng bao nhiêu bit?", en: "The IEEE standard for single-precision floating-point numbers uses how many total bits?"}, o: [{vi: "16 bit", en: "16 bits"}, {vi: "32 bit", en: "32 bits"}, {vi: "64 bit", en: "64 bits"}, {vi: "128 bit", en: "128 bits"}], a: 1, explanation: {vi: "Đơn chính xác (single-precision) là 32 bit, trong khi chính xác kép (double-precision) là 64 bit.", en: "Single-precision is 32 bits, while double-precision is 64 bits."}},
                    { q: { vi: "Trong định dạng đơn chính xác của IEEE (Excess_127), có bao nhiêu bit được phân bổ cho số mũ (exponent)?", en: "In the IEEE single-precision format (Excess_127), how many bits are allocated for the exponent?"}, o: [{vi: "1 bit", en: "1 bit"}, {vi: "8 bit", en: "8 bits"}, {vi: "23 bit", en: "23 bits"}, {vi: "32 bit", en: "32 bits"}], a: 1, explanation: {vi: "Phân bổ là: 1 bit cho dấu, 8 bit cho số mũ, và 23 bit cho phần định trị. Tổng cộng 1 + 8 + 23 = 32 bit.", en: "The allocation is: 1 bit for the sign, 8 bits for the exponent, and 23 bits for the mantissa. Total 1 + 8 + 23 = 32 bits."}},
                    { q: { vi: "Mục đích của việc sử dụng 'Hệ thống Excess' (biểu diễn lệch - biased) để lưu trữ số mũ trong số dấu phẩy động là gì?", en: "What is the purpose of using the 'Excess System' (biased representation) to store the exponent in floating-point numbers?"}, o: [{vi: "Để làm cho số mũ luôn dương nhằm so sánh dễ dàng hơn.", en: "To make the exponent always positive for easier comparison."}, {vi: "Để tăng phạm vi của số mũ.", en: "To increase the range of the exponent."}, {vi: "Để tiết kiệm không gian lưu trữ.", en: "To save storage space."}, {vi: "Để biểu diễn dấu của số.", en: "To represent the number's sign."}], a: 0, explanation: {vi: "Bằng cách thêm một độ lệch (bias), cả số mũ dương và âm đều trở thành các số không dấu. Điều này cho phép phần cứng so sánh hai số mũ một cách đơn giản như so sánh hai số nguyên không dấu.", en: "By adding a bias, both positive and negative exponents become unsigned numbers. This allows hardware to compare two exponents simply by comparing them as unsigned integers."}},
                    { q: { vi: "Lỗi cắt cụt (truncation error) trong biểu diễn dấu phẩy động là gì?", en: "What is a truncation error in floating-point representation?"}, o: [{vi: "Lỗi xảy ra khi một số quá lớn không thể lưu trữ được (tràn số).", en: "An error that occurs when a number is too large to be stored (overflow)."}, {vi: "Lỗi xảy ra khi một số quá nhỏ không thể lưu trữ được (tràn dưới).", en: "An error that occurs when a number is too small to be stored (underflow)."}, {vi: "Sự khác biệt giữa số ban đầu và giá trị được lưu trữ do phần định trị (mantissa) bị rút ngắn.", en: "The difference between the original number and the stored value due to the shortening of the mantissa."}, {vi: "Lỗi ở bit dấu.", en: "An error in the sign bit."}], a: 2, explanation: {vi: "Khi một số có nhiều chữ số ở phần định trị hơn số bit cho phép, các bit cuối cùng sẽ bị 'cắt đi', gây ra một sai số nhỏ gọi là lỗi cắt cụt.", en: "When a number has more digits in its mantissa than the available bits allow, the final bits are 'truncated', causing a small error known as a truncation error."}},
                    { q: { vi: "Trong định dạng đơn chính xác của IEEE, giá trị độ lệch (bias) là bao nhiêu?", en: "In the IEEE single-precision format, what is the bias value?"}, o: [{vi: "7", en: "7"}, {vi: "64", en: "64"}, {vi: "127", en: "127"}, {vi: "1023", en: "1023"}], a: 2, explanation: {vi: "Định dạng này còn được gọi là Excess-127, chính vì giá trị bias của nó là 127.", en: "This format is also known as Excess-127, precisely because its bias value is 127."}},
                    { q: { vi: "Giá trị được lưu trữ của số mũ (E) cho số thập phân 5.75 trong định dạng Excess_127 là bao nhiêu? (Chuẩn hóa: 5.75 = 1.0111₂ x 2²)", en: "What is the stored value of the exponent (E) for the decimal number 5.75 in Excess_127 format? (Normalization: 5.75 = 1.0111₂ x 2²)"}, o: [{vi: "2", en: "2"}, {vi: "127", en: "127"}, {vi: "129", en: "129"}, {vi: "125", en: "125"}], a: 2, explanation: {vi: "Giá trị được lưu trữ E = Số mũ thực + Bias. Ở đây, E = 2 + 127 = 129. 129 ở dạng nhị phân là 10000001.", en: "The stored value E = Actual Exponent + Bias. Here, E = 2 + 127 = 129. 129 in binary is 10000001."}},
                    { q: { vi: "Quá trình biểu diễn các ký hiệu văn bản bằng các mẫu bit được gọi là:", en: "The process of representing text symbols with bit patterns is called:"}, o: [{vi: "Lượng tử hóa (Quantization)", en: "Quantization"}, {vi: "Lấy mẫu (Sampling)", en: "Sampling"}, {vi: "Mã hóa (Coding)", en: "Coding"}, {vi: "Chuẩn hóa (Normalization)", en: "Normalization"}], a: 2, explanation: {vi: "Mã hóa (coding) là quá trình gán một mã (một mẫu bit) duy nhất cho mỗi ký hiệu trong một tập hợp.", en: "Coding is the process of assigning a unique code (a bit pattern) to each symbol in a set."}},
                    { q: { vi: "Chuẩn Unicode có thể sử dụng tới 32 bit cho mỗi ký hiệu. Ưu điểm chính của việc này so với ASCII 7-bit là gì?", en: "The Unicode standard can use up to 32 bits per symbol. What is the main advantage of this over 7-bit ASCII?"}, o: [{vi: "Nó được nén tốt hơn.", en: "It is better compressed."}, {vi: "Nó có thể biểu diễn các ký hiệu từ nhiều ngôn ngữ hơn.", en: "It can represent symbols from many more languages."}, {vi: "Nó xử lý nhanh hơn.", en: "It processes faster."}, {vi: "Nó tự động bao gồm việc sửa lỗi.", en: "It automatically includes error correction."}], a: 1, explanation: {vi: "ASCII chỉ có 128 ký tự, đủ cho tiếng Anh. Unicode có một không gian mã khổng lồ, cho phép nó bao gồm các ký tự từ hầu hết các ngôn ngữ viết trên thế giới.", en: "ASCII has only 128 characters, enough for English. Unicode has a vast codespace, allowing it to include characters from almost all written languages in the world."}},
                    { q: { vi: "Dữ liệu âm thanh là một ví dụ về dữ liệu _________, trong khi văn bản là một ví dụ về dữ liệu _________.", en: "Audio data is an example of _________ data, whereas text is an example of _________ data."}, o: [{vi: "Số (Digital); Tương tự (Analog)", en: "Digital; Analog"}, {vi: "Thực (Real); Nguyên (Integer)", en: "Real; Integer"}, {vi: "Tương tự (Analog); Số (Digital)", en: "Analog; Digital"}, {vi: "Liên tục (Continuous); Rời rạc (Discrete)", en: "Continuous; Discrete"}], a: 2, explanation: {vi: "Sóng âm thanh trong thế giới thực là liên tục (analog). Văn bản bao gồm các ký tự riêng biệt, có thể đếm được (digital).", en: "Sound waves in the real world are continuous (analog). Text consists of distinct, countable characters (digital)."}},
                    { q: { vi: "Trong bối cảnh lưu trữ âm thanh, 'lấy mẫu' (sampling) là gì?", en: "In the context of audio storage, what is 'sampling'?"}, o: [{vi: "Làm tròn giá trị của một tín hiệu đến số nguyên gần nhất.", en: "Rounding a signal's value to the nearest integer."}, {vi: "Chọn một số hữu hạn các điểm trên một tín hiệu tương tự để đo và ghi lại.", en: "Selecting a finite number of points on an analog signal to measure and record."}, {vi: "Nén dữ liệu âm thanh để giảm kích thước tệp.", en: "Compressing audio data to reduce file size."}, {vi: "Chuyển đổi dữ liệu âm thanh thành một mẫu bit.", en: "Converting audio data into a bit pattern."}], a: 1, explanation: {vi: "Lấy mẫu là bước đầu tiên để số hóa một tín hiệu tương tự: chúng ta đo 'ảnh chụp nhanh' của tín hiệu tại các khoảng thời gian đều đặn.", en: "Sampling is the first step in digitizing an analog signal: we take 'snapshots' of the signal's value at regular time intervals."}},
                    { q: { vi: "'Lượng tử hóa' (quantization) trong quá trình số hóa âm thanh đề cập đến điều gì?", en: "What does 'quantization' refer to in the audio digitization process?"}, o: [{vi: "Số lượng mẫu được lấy mỗi giây.", en: "The number of samples taken per second."}, {vi: "Quá trình làm tròn giá trị mẫu đã đo đến giá trị nguyên gần nhất.", en: "The process of rounding the measured sample value to the nearest integer value."}, {vi: "Số lượng bit được sử dụng để lưu trữ mỗi mẫu.", en: "The number of bits used to store each sample."}, {vi: "Việc mã hóa các giá trị mẫu thành các mẫu bit.", en: "The encoding of sample values into bit patterns."}], a: 1, explanation: {vi: "Sau khi lấy mẫu, mỗi giá trị đo được (thường là một số thực) được làm tròn hoặc ánh xạ tới một trong một tập hợp các giá trị nguyên hữu hạn. Đây là lượng tử hóa.", en: "After sampling, each measured value (which is often a real number) is rounded or mapped to one of a finite set of integer values. This is quantization."}},
                    { q: { vi: "Trong âm thanh kỹ thuật số, 'tốc độ bit' (bit rate) được tính bằng cách:", en: "In digital audio, the 'bit rate' is calculated by:"}, o: [{vi: "Tần số lấy mẫu / Độ sâu bit", en: "Sampling rate / Bit depth"}, {vi: "Tần số lấy mẫu + Độ sâu bit", en: "Sampling rate + Bit depth"}, {vi: "Tần số lấy mẫu x Độ sâu bit", en: "Sampling rate x Bit depth"}, {vi: "(Tần số lấy mẫu + Độ sâu bit) / 2", en: "(Sampling rate + Bit depth) / 2"}], a: 2, explanation: {vi: "Tốc độ bit là tổng số bit cần thiết để lưu trữ một giây âm thanh. Nó bằng số mẫu mỗi giây nhân với số bit cho mỗi mẫu.", en: "The bit rate is the total number of bits required to store one second of audio. It equals the number of samples per second multiplied by the number of bits per sample."}},
                    { q: { vi: "Trong đồ họa raster, một hình ảnh được chia thành một lưới các phần tử nhỏ. Những phần tử này được gọi là gì?", en: "In raster graphics, an image is divided into a grid of small elements. What are these elements called?"}, o: [{vi: "Vector", en: "Vectors"}, {vi: "Pixel", en: "Pixels"}, {vi: "Khung hình (Frame)", en: "Frames"}, {vi: "Bảng màu (Palette)", en: "Palettes"}], a: 1, explanation: {vi: "Pixel là viết tắt của 'picture element'. Đồ họa raster (hoặc bitmap) lưu trữ hình ảnh dưới dạng một lưới các pixel màu.", en: "Pixel is short for 'picture element'. Raster (or bitmap) graphics store an image as a grid of colored pixels."}},
                    { q: { vi: "'Độ sâu màu' (color depth) trong bối cảnh lưu trữ hình ảnh là gì?", en: "What is 'color depth' in the context of image storage?"}, o: [{vi: "Kích thước vật lý của hình ảnh.", en: "The physical dimensions of the image."}, {vi: "Số lượng màu sắc khác nhau trong bảng màu của hình ảnh.", en: "The number of different colors in the image's palette."}, {vi: "Số lượng bit được sử dụng để biểu diễn màu sắc của một pixel duy nhất.", en: "The number of bits used to represent the color of a single pixel."}, {vi: "Độ phân giải của hình ảnh.", en: "The resolution of the image."}], a: 2, explanation: {vi: "Độ sâu màu càng cao (nhiều bit hơn cho mỗi pixel), càng có nhiều màu sắc có thể được biểu diễn, dẫn đến hình ảnh trông chân thực hơn.", en: "A higher color depth (more bits per pixel) means more colors can be represented, resulting in a more realistic-looking image."}},
                    { q: { vi: "Hệ màu True-Color sử dụng 24 bit để mã hóa một pixel. Các bit này thường được phân chia như thế nào?", en: "The True-Color scheme uses 24 bits to encode a pixel. How are these bits typically divided?"}, o: [{vi: "24 bit cho cường độ sáng.", en: "24 bits for luminance."}, {vi: "12 bit cho màu đỏ, 12 bit cho màu xanh lá.", en: "12 bits for red, 12 bits for green."}, {vi: "8 bit cho màu đỏ, 8 bit cho màu xanh lá, và 8 bit cho màu xanh dương.", en: "8 bits for red, 8 bits for green, and 8 bits for blue."}, {vi: "16 bit cho màu sắc, 8 bit cho độ sáng.", en: "16 bits for color, 8 bits for brightness."}], a: 2, explanation: {vi: "True-Color sử dụng mô hình màu RGB, phân bổ 8 bit cho mỗi kênh trong số ba kênh màu cơ bản (Đỏ, Xanh lá, Xanh dương), cho phép hơn 16 triệu màu.", en: "True-Color uses the RGB color model, allocating 8 bits for each of the three primary color channels (Red, Green, Blue), allowing for over 16 million colors."}},
                    { q: { vi: "Nhược điểm chính của việc phóng to một hình ảnh đồ họa raster là gì?", en: "What is the main drawback of enlarging a raster graphics image?"}, o: [{vi: "Kích thước tệp trở nên quá lớn.", en: "The file size becomes too large."}, {vi: "Màu sắc bị biến dạng.", en: "The colors get distorted."}, {vi: "Hình ảnh trông bị răng cưa hoặc vỡ hạt (pixelated).", en: "The image looks jagged or pixelated."}, {vi: "Nó đòi hỏi phần mềm đặc biệt.", en: "It requires special software."}], a: 2, explanation: {vi: "Vì hình ảnh raster được tạo thành từ một lưới pixel cố định, việc phóng to nó chỉ đơn giản là làm cho mỗi pixel lớn hơn, dẫn đến hiệu ứng 'bậc thang' hoặc 'vỡ hạt'.", en: "Since a raster image is made of a fixed grid of pixels, enlarging it simply makes each pixel bigger, resulting in a 'blocky' or 'pixelated' effect."}},
                    { q: { vi: "Đồ họa vector lưu trữ một hình ảnh như thế nào?", en: "How does vector graphics store an image?"}, o: [{vi: "Dưới dạng một lưới các pixel.", en: "As a grid of pixels."}, {vi: "Dưới dạng một chuỗi các công thức toán học biểu diễn các hình dạng hình học.", en: "As a series of mathematical formulas representing geometric shapes."}, {vi: "Dưới dạng một mẫu bit đã được nén.", en: "As a compressed bit pattern."}, {vi: "Dưới dạng một chuỗi các khung hình.", en: "As a sequence of frames."}], a: 1, explanation: {vi: "Đồ họa vector không lưu trữ các pixel. Thay vào đó, nó lưu trữ các chỉ thị để vẽ các đối tượng (như 'vẽ một đường thẳng từ điểm A đến điểm B' hoặc 'vẽ một vòng tròn tại tâm C với bán kính R').", en: "Vector graphics don't store pixels. Instead, they store instructions to draw objects (like 'draw a line from point A to point B' or 'draw a circle at center C with radius R')."}},
                    { q: { vi: "Ưu điểm chính của đồ họa vector so với đồ họa raster là gì?", en: "What is a major advantage of vector graphics over raster graphics?"}, o: [{vi: "Chúng có thể biểu diễn hình ảnh nhiếp ảnh một cách chân thực hơn.", en: "They can represent photographic images more realistically."}, {vi: "Chúng có kích thước tệp nhỏ hơn đối với các hình ảnh đơn giản.", en: "They have smaller file sizes for simple images."}, {vi: "Chúng có thể được thay đổi kích thước bất kỳ mà không làm mất chất lượng.", en: "They can be resized to any dimension without loss of quality."}, {vi: "Chúng được hỗ trợ bởi nhiều ứng dụng hơn.", en: "They are supported by more applications."}], a: 2, explanation: {vi: "Vì hình ảnh vector được định nghĩa bằng toán học, việc thay đổi kích thước chỉ đơn giản là tính toán lại các công thức với các giá trị mới, dẫn đến một hình ảnh sắc nét hoàn hảo ở mọi kích thước.", en: "Because a vector image is mathematically defined, resizing it simply involves recalculating the formulas with new values, resulting in a perfectly sharp image at any size."}},
                    { q: { vi: "Video là sự biểu diễn của hình ảnh theo thời gian. Các hình ảnh riêng lẻ trong một video được gọi là gì?", en: "Video is the representation of images over time. What are the individual images in a video called?"}, o: [{vi: "Pixel", en: "Pixels"}, {vi: "Mẫu (Sample)", en: "Samples"}, {vi: "Vector", en: "Vectors"}, {vi: "Khung hình (Frame)", en: "Frames"}], a: 3, explanation: {vi: "Video tạo ra ảo giác về chuyển động bằng cách hiển thị một chuỗi các hình ảnh tĩnh, được gọi là khung hình, một cách nhanh chóng.", en: "Video creates the illusion of motion by displaying a sequence of still images, called frames, in rapid succession."}},
                    { q: { vi: "Tiêu chuẩn thống trị để lưu trữ âm thanh ngày nay, được đề cập trong giáo trình, là:", en: "The dominant standard for storing audio today, mentioned in the textbook, is:"}, o: [{vi: "WAV", en: "WAV"}, {vi: "MIDI", en: "MIDI"}, {vi: "MP3", en: "MP3"}, {vi: "MPEG", en: "MPEG"}], a: 2, explanation: {vi: "MP3 (MPEG Layer 3) đã trở thành tiêu chuẩn de facto cho việc phân phối âm thanh kỹ thuật số do khả năng nén hiệu quả của nó.", en: "MP3 (MPEG Layer 3) became the de facto standard for digital audio distribution due to its efficient compression capabilities."}},
                    { q: { vi: "Chuẩn mã hóa hình ảnh nào sử dụng hệ màu chỉ mục (indexed color)?", en: "Which image encoding standard uses the indexed color scheme?"}, o: [{vi: "JPEG", en: "JPEG"}, {vi: "GIF", en: "GIF"}, {vi: "BMP", en: "BMP"}, {vi: "TIFF", en: "TIFF"}], a: 1, explanation: {vi: "GIF (Graphic Interchange Format) nổi tiếng với việc sử dụng bảng màu chỉ mục, giới hạn ở 256 màu, làm cho nó phù hợp với các hình ảnh có màu sắc đơn giản như logo và hình vẽ.", en: "GIF (Graphic Interchange Format) is known for its use of an indexed palette, limited to 256 colors, making it suitable for images with simple colors like logos and drawings."}},
                    { q: { vi: "Mẫu bit 01000001 có thể biểu diễn số 65 hoặc ký tự 'A'. Điều gì quyết định cách máy tính diễn giải mẫu bit này?", en: "The bit pattern 01000001 can represent the number 65 or the character 'A'. What determines how the computer interprets this bit pattern?"}, o: [{vi: "Kích thước của bộ nhớ", en: "The size of the memory"}, {vi: "Tốc độ của bộ xử lý", en: "The speed of the processor"}, {vi: "Chương trình hoặc ứng dụng đang sử dụng dữ liệu", en: "The program or application using the data"}, {vi: "Hệ điều hành", en: "The operating system"}], a: 2, explanation: {vi: "Bản thân mẫu bit không có ý nghĩa. Ngữ cảnh do chương trình cung cấp (ví dụ: một chương trình máy tính so với một trình soạn thảo văn bản) sẽ quyết định cách diễn giải nó.", en: "The bit pattern itself is meaningless. The context provided by the program (e.g., a calculator program vs. a text editor) determines how it is interpreted."}},
                    { q: { vi: "Một vị trí bộ nhớ 4-bit có thể lưu trữ một số nguyên không dấu từ 0 đến 15. Phạm vi cho một số nguyên có dấu bù hai trong cùng một vị trí 4-bit là bao nhiêu?", en: "A 4-bit memory location can store an unsigned integer from 0 to 15. What is the range for a two's complement signed integer in the same 4-bit location?"}, o: [{vi: "-7 đến +7", en: "-7 to +7"}, {vi: "-8 đến +7", en: "-8 to +7"}, {vi: "-8 đến +8", en: "-8 to +8"}, {vi: "-7 đến +8", en: "-7 to +8"}], a: 1, explanation: {vi: "Với n bit, phạm vi bù hai là từ -2ⁿ⁻¹ đến +2ⁿ⁻¹-1. Với n=4, phạm vi là từ -2³ đến +2³-1, tức là -8 đến +7.", en: "For n bits, the two's complement range is from -2ⁿ⁻¹ to +2ⁿ⁻¹-1. For n=4, the range is from -2³ to +2³-1, which is -8 to +7."}},
                    { q: { vi: "Tại sao việc chuẩn hóa số dấu phẩy động lại quan trọng?", en: "Why is normalizing a floating-point number important?"}, o: [{vi: "Nó làm cho số nhỏ hơn và dễ lưu trữ hơn.", en: "It makes the number smaller and easier to store."}, {vi: "Nó cung cấp một biểu diễn duy nhất và tiêu chuẩn cho mỗi số.", en: "It provides a unique, standard representation for each number."}, {vi: "Nó loại bỏ sự cần thiết của bit dấu.", en: "It eliminates the need for a sign bit."}, {vi: "Nó ngăn ngừa lỗi tràn số.", en: "It prevents overflow errors."}], a: 1, explanation: {vi: "Chuẩn hóa đảm bảo rằng mọi số thực chỉ có một cách biểu diễn duy nhất trong hệ thống dấu phẩy động, loại bỏ sự mơ hồ và làm cho các phép so sánh trở nên đơn giản.", en: "Normalization ensures that every real number has only one unique representation in the floating-point system, removing ambiguity and making comparisons straightforward."}},
                    { q: { vi: "Một tín hiệu âm thanh được lấy mẫu 8.000 lần mỗi giây, và mỗi mẫu được biểu diễn bằng 8 bit. Tốc độ bit là bao nhiêu?", en: "An audio signal is sampled 8,000 times per second, and each sample is represented by 8 bits. What is the bit rate?"}, o: [{vi: "1,000 bps", en: "1,000 bps"}, {vi: "8,000 bps", en: "8,000 bps"}, {vi: "64,000 bps", en: "64,000 bps"}, {vi: "8,008 bps", en: "8,008 bps"}], a: 2, explanation: {vi: "Tốc độ bit = Tần số lấy mẫu × Độ sâu bit. Vậy, 8,000 mẫu/giây × 8 bit/mẫu = 64,000 bit mỗi giây (bps).", en: "Bit rate = Sampling Rate × Bit Depth. Thus, 8,000 samples/sec × 8 bits/sample = 64,000 bits per second (bps)."}},
                    { q: { vi: "Mục đích chính của việc nén dữ liệu là gì?", en: "What is the primary purpose of data compression?"}, o: [{vi: "Để tăng độ chính xác của dữ liệu.", en: "To increase the accuracy of the data."}, {vi: "Để chiếm ít không gian bộ nhớ hơn.", en: "To occupy less memory space."}, {vi: "Để làm cho dữ liệu dễ xử lý hơn.", en: "To make the data easier to process."}, {vi: "Để mã hóa dữ liệu.", en: "To encrypt the data."}], a: 1, explanation: {vi: "Nén dữ liệu là quá trình mã hóa thông tin để nó sử dụng ít bit hơn, do đó làm giảm kích thước tệp và tiết kiệm không gian lưu trữ.", en: "Data compression is the process of encoding information so that it uses fewer bits, thereby reducing file size and saving storage space."}},
                    { q: { vi: "Ứng dụng nào sau đây phù hợp nhất để sử dụng đồ họa vector?", en: "Which of the following applications is best suited for using vector graphics?"}, o: [{vi: "Chỉnh sửa một bức ảnh phong cảnh có độ phân giải cao.", en: "Editing a high-resolution landscape photograph."}, {vi: "Lưu trữ một đoạn video ngắn.", en: "Storing a short video clip."}, {vi: "Tạo logo công ty cần được sử dụng ở nhiều kích cỡ khác nhau.", en: "Creating a company logo that needs to be used at various sizes."}, {vi: "Ghi lại một buổi biểu diễn âm nhạc.", en: "Recording a music performance."}], a: 2, explanation: {vi: "Đồ họa vector lý tưởng cho các hình ảnh được tạo từ các hình dạng hình học cần thay đổi kích thước mà không làm mất chất lượng, như logo.", en: "Vector graphics are ideal for images made of geometric shapes that need to be resized without quality loss, such as logos."}},
                    { q: { vi: "Giá trị thập phân của số dấu-lượng (sign-and-magnitude) 8-bit 10100001 là bao nhiêu?", en: "What is the decimal value of the 8-bit sign-and-magnitude number 10100001?"}, o: [{vi: "161", en: "161"}, {vi: "-33", en: "-33"}, {vi: "-161", en: "-161"}, {vi: "33", en: "33"}], a: 1, explanation: {vi: "Bit ngoài cùng bên trái '1' cho biết số này là âm. 7 bit còn lại '0100001' chuyển đổi sang thập phân là 33 (32 + 1). Do đó, số đó là -33.", en: "The leftmost bit '1' indicates the number is negative. The remaining 7 bits '0100001' convert to decimal 33 (32 + 1). Therefore, the number is -33."}},
                    { q: { vi: "Hệ màu chỉ mục (indexed color) làm giảm số bit cần thiết cho mỗi pixel so với True-Color. Sự đánh đổi là gì?", en: "The indexed color scheme reduces the number of bits needed per pixel compared to True-Color. What is the trade-off?"}, o: [{vi: "Độ phân giải hình ảnh thấp hơn.", en: "Lower image resolution."}, {vi: "Số lượng màu có thể hiển thị đồng thời bị giới hạn.", en: "The number of simultaneously displayable colors is limited."}, {vi: "Tệp không thể được nén.", en: "The file cannot be compressed."}, {vi: "Hình ảnh chỉ có thể được hiển thị trên các màn hình cụ thể.", en: "The image can only be shown on specific monitors."}], a: 1, explanation: {vi: "Hệ màu chỉ mục hoạt động bằng cách chọn một bảng màu giới hạn (ví dụ: 256 màu) từ dải màu True-Color đầy đủ. Điều này có nghĩa là trong khi kích thước tệp nhỏ hơn, hình ảnh chỉ có thể sử dụng các màu từ bảng màu cụ thể đó.", en: "The indexed color scheme works by selecting a limited palette (e.g., 256 colors) from the full True-Color range. This means that while the file size is smaller, the image can only use colors from that specific palette."}},
                    { q: { vi: "Trong cách biểu diễn số nguyên nào, hiện tượng tràn số sẽ chuyển từ số dương lớn nhất sang số âm nhỏ nhất?", en: "In which integer representation does an overflow wrap from the largest positive number to the most negative number?"}, o: [{vi: "Số nguyên không dấu (Unsigned integer)", en: "Unsigned integer"}, {vi: "Dấu-lượng (Sign-and-magnitude)", en: "Sign-and-magnitude"}, {vi: "Bù hai (Two's complement)", en: "Two's complement"}, {vi: "Tất cả các phương án trên", en: "All of the above"}], a: 2, explanation: {vi: "Do cấu trúc vòng tròn của biểu diễn bù hai, khi vượt quá số dương lớn nhất (ví dụ: 0111...111), nó sẽ 'quay vòng' về số âm nhỏ nhất (1000...000).", en: "Due to the circular nature of the two's complement representation, exceeding the largest positive number (e.g., 0111...111) 'wraps around' to the most negative number (1000...000)."}},
                    { q: { vi: "Điều nào sau đây là một ví dụ về dữ liệu tương tự (analog)?", en: "Which of the following is an example of analog data?"}, o: [{vi: "Văn bản trong một cuốn sách.", en: "The text in a book."}, {vi: "Số lượng sinh viên trong một lớp học.", en: "The number of students in a class."}, {vi: "Âm thanh của một cây đàn violin.", en: "The sound of a violin."}, {vi: "Kết quả của một lần tung đồng xu (sấp hoặc ngửa).", en: "The result of a coin toss (heads or tails)."}], a: 2, explanation: {vi: "Dữ liệu tương tự là liên tục. Âm thanh của một cây đàn violin có vô số giá trị cường độ theo thời gian. Các lựa chọn khác đều là rời rạc (có thể đếm được), đó là đặc điểm của dữ liệu số.", en: "Analog data is continuous. The sound of a violin has an infinite number of intensity values over time. The other options are all discrete (countable), which is characteristic of digital data."}}
                ]
            },
            chapter4: {
                 theory: {
                    vi: `
                        <h2>Chương 4: Các Phép toán trên Dữ liệu</h2>
                        <h3>1. Phép toán Logic (Logic Operations)</h3>
                        <ul>
                            <li>Thực hiện trên từng bit của một hoặc hai chuỗi bit. Các toán tử chính:
                                <ul>
                                    <li><strong>NOT:</strong> Đảo bit (0 thành 1, 1 thành 0).</li>
                                    <li><strong>AND:</strong> Kết quả là 1 chỉ khi cả hai bit đầu vào đều là 1.</li>
                                    <li><strong>OR:</strong> Kết quả là 1 nếu ít nhất một trong hai bit đầu vào là 1.</li>
                                    <li><strong>XOR (Exclusive OR):</strong> Kết quả là 1 chỉ khi hai bit đầu vào khác nhau.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Ứng dụng: Dùng mặt nạ (Masking)</strong>
                                <ul>
                                    <li><span class="highlight">Unsetting (Xóa bit về 0):</span> Dùng phép <strong>AND</strong> với mặt nạ có bit 0 tại vị trí cần xóa.</li>
                                    <li><span class="highlight">Setting (Bật bit lên 1):</span> Dùng phép <strong>OR</strong> với mặt nạ có bit 1 tại vị trí cần bật.</li>
                                    <li><span class="highlight">Flipping (Lật bit):</span> Dùng phép <strong>XOR</strong> với mặt nạ có bit 1 tại vị trí cần lật.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Ví dụ về Masking</h3>
                        <pre><strong>Ví dụ: Xóa (unset) 5 bit ngoài cùng bên trái của 10100110</strong>
  1010 0110   (Dữ liệu gốc)
& 0000 0111   (Mặt nạ AND - 0 ở vị trí cần xóa)
-----------
  0000 0110   (Kết quả)

<strong>Ví dụ: Lật (flip) 5 bit ngoài cùng bên trái của 10100110</strong>
  1010 0110   (Dữ liệu gốc)
^ 1111 1000   (Mặt nạ XOR - 1 ở vị trí cần lật)
-----------
  0101 1110   (Kết quả)</pre>
                        <h3>3. Phép toán Dịch chuyển (Shift Operations)</h3>
                        <ul>
                             <li><strong>Dịch logic (Logical Shift):</strong> Dịch chuyển các bit, chèn số 0 vào chỗ trống. Dùng cho số không dấu.</li>
                             <li><strong>Dịch số học (Arithmetic Shift):</strong> Dùng cho số bù 2. Khi dịch phải, bit dấu được giữ nguyên để bảo toàn giá trị âm/dương. Dịch trái tương đương nhân 2, dịch phải tương đương chia 2.</li>
                        </ul>
                        <h3>4. Phép toán Số học (Arithmetic Operations)</h3>
                        <ul>
                            <li>Phép cộng số Bù 2 được thực hiện như cộng nhị phân thông thường, bit nhớ cuối cùng (nếu có) sẽ bị bỏ đi.</li>
                            <li><span class="highlight">Phép trừ A - B được thực hiện bằng phép cộng: A + (Bù 2 của B)</span>.</li>
                        </ul>
                         <pre><strong>Ví dụ: (+24) + (-17) dùng số bù 2 8-bit</strong>
+24       = 0001 1000
-17       = 1110 1111  (Bù 2 của 17)
-------------------
Kết quả: (1)0000 0111  (Bỏ bit nhớ cuối)
          = 7₁₀ (Đúng)</pre>
                    `,
                    en: `
                        <h2>Chapter 4: Operations on Data</h2>
                        <h3>1. Logic Operations</h3>
                        <ul>
                            <li>Performed on individual bits of one or two bit patterns. Main operators:
                                <ul>
                                    <li><strong>NOT:</strong> Inverts the bit (0 becomes 1, 1 becomes 0).</li>
                                    <li><strong>AND:</strong> The result is 1 only if both input bits are 1.</li>
                                    <li><strong>OR:</strong> The result is 1 if at least one of the input bits is 1.</li>
                                    <li><strong>XOR (Exclusive OR):</strong> The result is 1 only if the input bits are different.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Application: Masking</strong>
                                <ul>
                                    <li><span class="highlight">Unsetting a bit (to 0):</span> Use <strong>AND</strong> with a mask that has a 0 at the desired position.</li>
                                    <li><span class="highlight">Setting a bit (to 1):</span> Use <strong>OR</strong> with a mask that has a 1 at the desired position.</li>
                                    <li><span class="highlight">Flipping a bit:</span> Use <strong>XOR</strong> with a mask that has a 1 at the desired position.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Masking Examples</h3>
                        <pre><strong>Example: Unset the five leftmost bits of 10100110</strong>
  1010 0110   (Original Data)
& 0000 0111   (AND Mask - 0s where you want to clear)
-----------
  0000 0110   (Result)

<strong>Example: Flip the five leftmost bits of 10100110</strong>
  1010 0110   (Original Data)
^ 1111 1000   (XOR Mask - 1s where you want to flip)
-----------
  0101 1110   (Result)</pre>
                        <h3>3. Shift Operations</h3>
                        <ul>
                             <li><strong>Logical Shift:</strong> Shifts bits and inserts a 0 into the empty spot. Used for unsigned numbers.</li>
                             <li><strong>Arithmetic Shift:</strong> Used for two's complement numbers. A right shift preserves the sign bit. Left shift is equivalent to multiplying by 2, right shift is equivalent to dividing by 2.</li>
                        </ul>
                        <h3>4. Arithmetic Operations</h3>
                        <ul>
                            <li>Two's Complement addition is performed like normal binary addition, and the final carry bit (if any) is discarded.</li>
                            <li><span class="highlight">Subtraction A - B is performed as an addition: A + (Two's complement of B)</span>.</li>
                        </ul>
                         <pre><strong>Example: (+24) + (-17) using 8-bit two's complement</strong>
+24       = 0001 1000
-17       = 1110 1111  (Two's complement of 17)
-------------------
Result: (1)0000 0111  (Discard final carry)
          = 7₁₀ (Correct)</pre>
                    `
                },
                questions: [
                    { q: { vi: "Các thao tác trên dữ liệu (Operations on Data) được chia thành ba loại chính là:", en: "Operations on data are divided into which three main categories?" }, o: [{ vi: "Logic operations, Shift operations, Arithmetic operations", en: "Logic operations, Shift operations, Arithmetic operations" }, { vi: "Input operations, Output operations, Storage operations", en: "Input operations, Output operations, Storage operations" }, { vi: "Unary operations, Binary operations, Ternary operations", en: "Unary operations, Binary operations, Ternary operations" }, { vi: "Bit operations, Pattern operations, Mask operations", en: "Bit operations, Pattern operations, Mask operations" }], a: 0, explanation: { vi: "Chương này tập trung vào 3 loại phép toán cơ bản ở mức thấp: Logic, Dịch chuyển và Số học.", en: "This chapter focuses on 3 fundamental low-level operation types: Logic, Shift, and Arithmetic." } },
                    { q: { vi: "Phép toán nào sau đây là một phép toán một ngôi (unary operator)?", en: "Which of the following is a unary operator?" }, o: [{ vi: "AND", en: "AND" }, { vi: "OR", en: "OR" }, { vi: "XOR", en: "XOR" }, { vi: "NOT", en: "NOT" }], a: 3, explanation: { vi: "NOT là toán tử một ngôi vì nó chỉ hoạt động trên một toán hạng (một đầu vào). AND, OR, XOR là toán tử hai ngôi (cần hai đầu vào).", en: "NOT is a unary operator because it operates on only one operand (one input). AND, OR, and XOR are binary operators (requiring two inputs)." } },
                    { q: { vi: "Trong các phép toán logic, giá trị 1 và 0 thường được diễn giải tương ứng là:", en: "In logical operations, the values 1 and 0 are often interpreted as:"}, o: [ {vi: "True và False", en: "True and False"}, {vi: "False và True", en: "False and True"}, {vi: "Positive và Negative", en: "Positive and Negative"}, {vi: "Start và Stop", en: "Start and Stop"}], a: 0, explanation: {vi: "Đây là quy ước cơ bản trong đại số Boolean và logic máy tính: 1 đại diện cho True (Đúng), 0 đại diện cho False (Sai).", en: "This is the fundamental convention in Boolean algebra and computer logic: 1 represents True, and 0 represents False."}},
                    { q: { vi: "Kết quả của phép toán X AND 1 sẽ là gì?", en: "What is the result of the operation X AND 1?"}, o: [ {vi: "Luôn là 1", en: "Always 1"}, {vi: "Luôn là 0", en: "Always 0"}, {vi: "Bằng X", en: "Equals X"}, {vi: "Bằng bù của X (NOT X)", en: "Equals the complement of X (NOT X)"}], a: 2, explanation: {vi: "Nếu X=0, 0 AND 1 = 0. Nếu X=1, 1 AND 1 = 1. Kết quả luôn bằng X. Đây là thuộc tính 'identity' của AND với 1.", en: "If X=0, 0 AND 1 = 0. If X=1, 1 AND 1 = 1. The result is always X. This is the 'identity' property of AND with 1."}},
                    { q: { vi: "Kết quả của phép toán X OR 0 sẽ là gì?", en: "What is the result of the operation X OR 0?"}, o: [ {vi: "Luôn là 1", en: "Always 1"}, {vi: "Luôn là 0", en: "Always 0"}, {vi: "Bằng X", en: "Equals X"}, {vi: "Bằng bù của X (NOT X)", en: "Equals the complement of X (NOT X)"}], a: 2, explanation: {vi: "Nếu X=0, 0 OR 0 = 0. Nếu X=1, 1 OR 0 = 1. Kết quả luôn bằng X. Đây là thuộc tính 'identity' của OR với 0.", en: "If X=0, 0 OR 0 = 0. If X=1, 1 OR 0 = 1. The result is always X. This is the 'identity' property of OR with 0."}},
                    { q: { vi: "Phép toán XOR (Exclusive OR) trả về giá trị 1 khi nào?", en: "When does the XOR (Exclusive OR) operation return a value of 1?"}, o: [ {vi: "Khi cả hai đầu vào đều là 1.", en: "When both inputs are 1."}, {vi: "Khi cả hai đầu vào đều là 0.", en: "When both inputs are 0."}, {vi: "Khi hai đầu vào giống nhau.", en: "When the two inputs are the same."}, {vi: "Khi hai đầu vào khác nhau.", en: "When the two inputs are different."}], a: 3, explanation: {vi: "XOR là phép 'hoặc loại trừ', nó chỉ đúng (1) khi một trong hai đầu vào là đúng, nhưng không phải cả hai.", en: "XOR is the 'exclusive or', it's true (1) only when one of the inputs is true, but not both."}},
                    { q: { vi: "Để 'unset' (tắt) một hoặc nhiều bit cụ thể trong một chuỗi bit (buộc chúng về 0), ta nên sử dụng phép toán nào kết hợp với một mặt nạ (mask)?", en: "To 'unset' (turn off) one or more specific bits in a bit string (forcing them to 0), which operation should be used with a mask?"}, o: [ {vi: "OR", en: "OR"}, {vi: "AND", en: "AND"}, {vi: "XOR", en: "XOR"}, {vi: "NOT", en: "NOT"}], a: 1, explanation: {vi: "Ghi nhớ: AND với 0 sẽ luôn cho kết quả là 0. Vì vậy, ta tạo một mặt nạ có bit 0 ở vị trí cần xóa và bit 1 ở các vị trí khác.", en: "Remember: ANDing with 0 always results in 0. Therefore, we create a mask with a 0 at the position to be cleared and 1s elsewhere."}},
                    { q: { vi: "Để 'set' (bật) một hoặc nhiều bit cụ thể trong một chuỗi bit (buộc chúng về 1), ta nên sử dụng phép toán nào kết hợp với một mặt nạ (mask)?", en: "To 'set' (turn on) one or more specific bits in a bit string (forcing them to 1), which operation should be used with a mask?"}, o: [ {vi: "OR", en: "OR"}, {vi: "AND", en: "AND"}, {vi: "NOT", en: "NOT"}, {vi: "NAND", en: "NAND"}], a: 0, explanation: {vi: "Ghi nhớ: OR với 1 sẽ luôn cho kết quả là 1. Vì vậy, ta tạo một mặt nạ có bit 1 ở vị trí cần bật và bit 0 ở các vị trí khác.", en: "Remember: ORing with 1 always results in 1. Therefore, we create a mask with a 1 at the position to be set and 0s elsewhere."}},
                    { q: { vi: "Để 'flip' (đảo) một hoặc nhiều bit cụ thể trong một chuỗi bit, ta nên sử dụng phép toán nào kết hợp với một mặt nạ (mask)?", en: "To 'flip' (invert) one or more specific bits in a bit string, which operation should be used with a mask?"}, o: [ {vi: "OR", en: "OR"}, {vi: "AND", en: "AND"}, {vi: "XOR", en: "XOR"}, {vi: "NOT", en: "NOT"}], a: 2, explanation: {vi: "Ghi nhớ: XOR với 1 sẽ đảo bit (0 XOR 1 = 1, 1 XOR 1 = 0). XOR với 0 sẽ giữ nguyên bit.", en: "Remember: XORing with 1 flips the bit (0 XOR 1 = 1, 1 XOR 1 = 0). XORing with 0 preserves the bit."}},
                    { q: { vi: "Sự khác biệt cơ bản giữa phép toán NOT và ứng dụng 'flipping bits' của XOR là gì?", en: "What is the fundamental difference between the NOT operation and the 'flipping bits' application of XOR?"}, o: [ {vi: "Không có sự khác biệt.", en: "There is no difference."}, {vi: "NOT đảo tất cả các bit, trong khi XOR chỉ đảo các bit được chỉ định bởi mặt nạ.", en: "NOT inverts all bits, while XOR only inverts the bits specified by the mask."}, {vi: "NOT chỉ hoạt động trên một bit, XOR hoạt động trên chuỗi bit.", en: "NOT only works on a single bit, XOR works on a bit string."}, {vi: "XOR nhanh hơn NOT.", en: "XOR is faster than NOT."}], a: 1, explanation: {vi: "NOT là một phép toán toàn cục, không chọn lọc. XOR với mặt nạ cho phép chúng ta 'lật' một cách có chọn lọc chỉ những bit chúng ta muốn.", en: "NOT is a global, non-selective operation. XOR with a mask allows us to selectively 'flip' only the bits we want."}},
                    { q: { vi: "Thao tác dịch chuyển (Shift Operations) được chia thành hai loại chính là:", en: "Shift Operations are divided into which two main categories?"}, o: [ {vi: "Left shift và Right shift", en: "Left shift and Right shift"}, {vi: "Simple shift và Circular shift", en: "Simple shift and Circular shift"}, {vi: "Logical shift và Arithmetic shift", en: "Logical shift and Arithmetic shift"}, {vi: "Bit shift và Pattern shift", en: "Bit shift and Pattern shift"}], a: 2, explanation: {vi: "Hai loại chính được phân biệt bởi mục đích: Dịch logic (Logical) dùng cho dữ liệu không dấu, trong khi dịch số học (Arithmetic) dùng cho dữ liệu có dấu (bù hai).", en: "The two main types are distinguished by their purpose: Logical shift is for unsigned data, while Arithmetic shift is for signed (two's complement) data."}},
                    { q: { vi: "Trong phép dịch logic sang phải (logical right shift), bit ở vị trí ngoài cùng bên trái sẽ được điền bằng giá trị nào?", en: "In a logical right shift, what value is filled into the leftmost bit position?"}, o: [ {vi: "0", en: "0"}, {vi: "1", en: "1"}, {vi: "Bit ngoài cùng bên phải ban đầu", en: "The original rightmost bit"}, {vi: "Bit dấu (sign bit)", en: "The sign bit"}], a: 0, explanation: {vi: "Phép dịch logic luôn chèn bit 0 vào vị trí trống, bất kể là dịch trái hay phải.", en: "A logical shift always inserts a 0 into the vacant position, regardless of whether it's a left or right shift."}},
                    { q: { vi: "Phép dịch vòng (circular shift hay rotate) khác với phép dịch đơn giản (simple shift) ở điểm nào?", en: "How does a circular shift (or rotate) differ from a simple shift?"}, o: [ {vi: "Dịch vòng không làm mất bit nào.", en: "A circular shift does not lose any bits."}, {vi: "Dịch vòng nhanh hơn dịch đơn giản.", en: "A circular shift is faster than a simple shift."}, {vi: "Dịch vòng chỉ áp dụng cho số có dấu.", en: "A circular shift only applies to signed numbers."}, {vi: "Dịch vòng chỉ có thể dịch sang trái.", en: "A circular shift can only shift to the left."}], a: 0, explanation: {vi: "Trong dịch đơn giản, bit bị đẩy ra sẽ mất. Trong dịch vòng, bit bị đẩy ra ở một đầu sẽ được đưa trở lại vào đầu kia.", en: "In a simple shift, the bit that is pushed out is lost. In a circular shift, the bit that is pushed out from one end is brought back in on the other end."}},
                    { q: { vi: "Phép dịch số học (arithmetic shift) được thiết kế để hoạt động trên loại dữ liệu nào?", en: "Arithmetic shift operations are designed to work on which type of data?"}, o: [ {vi: "Số nguyên không dấu (unsigned integers).", en: "Unsigned integers."}, {vi: "Số nguyên có dấu ở dạng bù hai (two's complement integers).", en: "Signed two's complement integers."}, {vi: "Số thực (floating-point numbers).", en: "Floating-point numbers."}, {vi: "Ký tự ASCII.", en: "ASCII characters."}], a: 1, explanation: {vi: "Phép dịch số học được tạo ra đặc biệt để thực hiện phép nhân/chia 2 trên các số bù hai mà vẫn giữ đúng dấu của chúng.", en: "Arithmetic shift was created specifically to perform multiplication/division by 2 on two's complement numbers while preserving their correct sign."}},
                    { q: { vi: "Phép dịch số học sang phải (arithmetic right shift) tương đương với phép toán số học nào?", en: "An arithmetic right shift is equivalent to which arithmetic operation?"}, o: [ {vi: "Nhân cho 2", en: "Multiplication by 2"}, {vi: "Chia cho 2 (làm tròn xuống)", en: "Division by 2 (floored)"}, {vi: "Cộng thêm 2", en: "Adding 2"}, {vi: "Trừ đi 2", en: "Subtracting 2"}], a: 1, explanation: {vi: "Mỗi lần dịch phải một bit tương đương với việc chia số đó cho 2. Việc bảo toàn bit dấu đảm bảo kết quả làm tròn đúng cho cả số dương và âm.", en: "Each single-bit right shift is equivalent to dividing the number by 2. Preserving the sign bit ensures correct rounding for both positive and negative numbers."}}
                ]
            },
            chapter5: {
                 theory: {
                    vi: `
                        <h2>Chương 5: Tổ chức Máy tính</h2>
                        <h3>1. Các thành phần chính</h3>
                        <ul>
                            <li><strong>CPU (Central Processing Unit):</strong> "Bộ não" của máy tính. Gồm 3 phần: ALU (tính toán), Control Unit (điều khiển), và Registers (thanh ghi).</li>
                            <li><strong>Bộ nhớ chính (Main Memory):</strong> Thường là RAM, lưu trữ chương trình và dữ liệu đang chạy.</li>
                        </ul>
                        <h3>2. Phân cấp bộ nhớ (Memory Hierarchy)</h3>
                        <p>Tốc độ và giá thành giảm dần, dung lượng tăng dần:</p>
                        <p><span class="highlight">Registers → Cache → Main Memory → Storage (Ổ cứng)</span></p>
                        <h3>3. Chu kỳ máy (Machine Cycle)</h3>
                        <ul>
                             <li>Quá trình CPU thực thi một lệnh. Gồm 3 bước cơ bản:
                                <ol>
                                    <li><span class="highlight">Fetch (Nạp lệnh):</span> Lấy lệnh từ bộ nhớ.</li>
                                    <li><span class="highlight">Decode (Giải mã):</span> Hiểu xem lệnh yêu cầu làm gì.</li>
                                    <li><span class="highlight">Execute (Thực thi):</span> Thực hiện lệnh đó.</li>
                                </ol>
                            </li>
                        </ul>
                    `,
                    en: `
                        <h2>Chapter 5: Computer Organization</h2>
                        <h3>1. Main Components</h3>
                        <ul>
                           <li><strong>CPU (Central Processing Unit):</strong> The "brain" of the computer. Contains 3 parts: ALU (calculation), Control Unit (control), and Registers.</li>
                            <li><strong>Main Memory:</strong> Usually RAM, stores currently running programs and data.</li>
                        </ul>
                        <h3>2. Memory Hierarchy</h3>
                        <p>Speed and cost decrease, while capacity increases:</p>
                        <p><span class="highlight">Registers → Cache → Main Memory → Storage (Hard Drive)</span></p>
                        <h3>3. Machine Cycle</h3>
                        <ul>
                             <li>The repetitive process by which the CPU executes one instruction. Consists of 3 basic steps:
                                <ol>
                                    <li><span class="highlight">Fetch:</span> Get the instruction from memory.</li>
                                    <li><span class="highlight">Decode:</span> Understand what the instruction wants to do.</li>
                                    <li><span class="highlight">Execute:</span> Perform the instruction.</li>
                                </ol>
                            </li>
                        </ul>
                    `
                },
                questions: [
                    { q: { vi: "Ba thành phần chính của CPU là gì?", en: "What are the three main components of a CPU?" }, o: [{ vi: "RAM, ROM, và Cache", en: "RAM, ROM, and Cache" }, { vi: "ALU, Control Unit, và Registers", en: "ALU, Control Unit, and Registers" }, { vi: "Data Bus, Address Bus, và Control Bus", en: "Data Bus, Address Bus, and Control Bus" }], a: 1, explanation: { vi: "CPU có bộ phận tính toán (ALU), bộ phận chỉ huy (Control Unit), và bộ nhớ siêu nhanh tại chỗ (Registers).", en: "The CPU has a calculation part (ALU), a command part (Control Unit), and super-fast local memory (Registers)." } },
                    { q: { vi: "Trong phân cấp bộ nhớ, thành phần nào nhanh nhất?", en: "In the memory hierarchy, which component is the fastest?" }, o: [{ vi: "Main Memory", en: "Main Memory"}, { vi: "Cache", en: "Cache"}, { vi: "Registers", en: "Registers"}, { vi: "Hard Drive", en: "Hard Drive"}], a: 2, explanation: { vi: "Thanh ghi (Registers) nằm ngay trong CPU, có tốc độ truy cập nhanh nhất.", en: "Registers are located inside the CPU and have the fastest access speed."}},
                    { q: { vi: "Chu kỳ máy (machine cycle) bao gồm những bước nào?", en: "What are the steps of a machine cycle?"}, o: [{vi: "Fetch, Decode, Execute", en: "Fetch, Decode, Execute"}, {vi: "Input, Process, Output", en: "Input, Process, Output"}, {vi: "Read, Write, Erase", en: "Read, Write, Erase"}], a: 0, explanation: {vi: "Chu kỳ máy cơ bản gồm 3 bước: Nạp lệnh, Giải mã lệnh, và Thực thi lệnh.", en: "The basic machine cycle consists of 3 steps: Fetch, Decode, and Execute."}}
                ]
            }
        };
        // --- END: NGÂN HÀNG CÂU HỎI VÀ LÝ THUYẾT ---

        // --- START: JAVASCRIPT LOGIC (HOÀN CHỈNH) ---
        let currentLang = 'vi';
        let currentChapter = 'chapter1';
        let quizState = {};

        document.addEventListener('DOMContentLoaded', () => {
            renderAllContent();
        });

        function renderAllContent() {
            const tabContent = document.querySelector('.tab-content');
            tabContent.innerHTML = '';
            let isFirstChapter = true;
            for (const chapterId in contentData) {
                const chapterDiv = document.createElement('div');
                chapterDiv.id = chapterId;
                chapterDiv.className = isFirstChapter ? 'tab-pane active' : 'tab-pane';
                isFirstChapter = false;

                chapterDiv.innerHTML = `
                    <div class="theory-view">
                        <div class="theory-content"></div>
                        <div class="button-group">
                            <button class="primary-button" onclick="showQuizSetup('${chapterId}')" data-lang-key="startQuiz"></button>
                            <button class="info-button" onclick="askAI()" data-lang-key="askAI"></button>
                        </div>
                    </div>
                    <div class="quiz-view">
                        <div class="quiz-setup">
                            <h3 data-lang-key="quizSetupTitle"></h3>
                            <div>
                                <label data-lang-key="numQuestions"></label>
                                <input type="number" id="num-questions-${chapterId}" value="10" min="1" max="${contentData[chapterId].questions.length}">
                            </div>
                            <div>
                                <button class="primary-button" onclick="startQuiz('${chapterId}')" data-lang-key="start"></button>
                                <button class="secondary-button" onclick="showTheory('${chapterId}')" data-lang-key="backToTheory"></button>
                            </div>
                        </div>
                        <div class="quiz-container" style="display:none;">
                            <div id="question-text-${chapterId}" class="quiz-question"></div>
                            <div id="quiz-options-${chapterId}" class="quiz-options"></div>
                            <div id="explanation-${chapterId}"></div>
                            <div class="button-group">
                                <button onclick="nextQuestion('${chapterId}')" id="next-btn-${chapterId}" class="primary-button" data-lang-key="nextQuestion" style="display:none;"></button>
                            </div>
                        </div>
                        <div class="quiz-results" style="display:none;">
                            <h3 data-lang-key="resultsTitle"></h3>
                            <p id="score-${chapterId}"></p>
                            <button class="secondary-button" onclick="showTheory('${chapterId}')" data-lang-key="backToTheory"></button>
                            <button class="primary-button" onclick="showQuizSetup('${chapterId}')" data-lang-key="retakeQuiz"></button>
                        </div>
                    </div>
                `;
                tabContent.appendChild(chapterDiv);
            }
            updateAllVisibleText();
        }

        function switchTab(chapterId) {
            currentChapter = chapterId;
            document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
            document.getElementById(chapterId).classList.add('active');
            
            document.querySelectorAll('.tab-link').forEach(l => l.classList.remove('active'));
            document.querySelector(`.tab-link[onclick="switchTab('${chapterId}')"]`).classList.add('active');
        }

        function switchLanguage(lang) {
            if (currentLang === lang) return;
            currentLang = lang;
            document.querySelectorAll('.lang-switcher button').forEach(b => b.classList.remove('active'));
            document.querySelector(`.lang-switcher button[onclick="switchLanguage('${lang}')"]`).classList.add('active');
            updateAllVisibleText();
        }
        
        const translations = {
            vi: {
                title: "CSI FPTU - Công cụ Ôn tập Nâng cao",
                subtitle: "Chọn chương để học lý thuyết hoặc làm bài tập trắc nghiệm.",
                vietnamese: "Tiếng Việt", english: "English",
                ch1: "Chương 1", ch2: "Chương 2", ch3: "Chương 3", ch4: "Chương 4", ch5: "Chương 5",
                startQuiz: "Làm bài tập", quizSetupTitle: "Thiết lập bài trắc nghiệm",
                numQuestions: "Số lượng câu hỏi:", start: "Bắt đầu",
                backToTheory: "Quay lại Lý thuyết", nextQuestion: "Câu tiếp theo",
                resultsTitle: "Kết quả", scoreText: "Bạn đã trả lời đúng",
                retakeQuiz: "Làm lại bài", askAI: "Hỏi AI"
            },
            en: {
                title: "CSI FPTU - Advanced Study Tool",
                subtitle: "Select a chapter to study theory or take a multiple-choice quiz.",
                vietnamese: "Vietnamese", english: "English",
                ch1: "Chapter 1", ch2: "Chapter 2", ch3: "Chapter 3", ch4: "Chapter 4", ch5: "Chapter 5",
                startQuiz: "Start Quiz", quizSetupTitle: "Quiz Setup",
                numQuestions: "Number of questions:", start: "Start",
                backToTheory: "Back to Theory", nextQuestion: "Next Question",
                resultsTitle: "Results", scoreText: "You answered correctly",
                retakeQuiz: "Retake Quiz", askAI: "Ask AI"
            }
        };

        function updateAllVisibleText() {
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.getAttribute('data-lang-key');
                if (translations[currentLang][key]) {
                    el.textContent = translations[currentLang][key];
                }
            });

            for (const chapterId in contentData) {
                const theoryDiv = document.querySelector(`#${chapterId} .theory-content`);
                if (theoryDiv) {
                    theoryDiv.innerHTML = contentData[chapterId].theory[currentLang];
                }
            }

            if (quizState[currentChapter] && quizState[currentChapter].isActive) {
                redisplayCurrentQuestion();
            }
        }

        function redisplayCurrentQuestion() {
            const state = quizState[currentChapter];
            if (!state || !state.isActive || state.currentQuestionIndex >= state.questions.length) return;

            const question = state.questions[state.currentQuestionIndex];
            document.getElementById(`question-text-${currentChapter}`).textContent = `(${state.currentQuestionIndex + 1}/${state.questions.length}) ${question.q[currentLang]}`;
            
            const options = document.querySelectorAll(`#quiz-options-${currentChapter} button`);
            options.forEach((button, index) => {
                button.textContent = question.o[index][currentLang];
            });

            const explanationDiv = document.getElementById(`explanation-${currentChapter}`);
            if (explanationDiv.innerHTML !== '') {
                const explanationText = question.explanation ? question.explanation[currentLang] : '';
                explanationDiv.innerHTML = `<div class="explanation-box"><strong>💡 ${currentLang === 'vi' ? 'Giải thích' : 'Explanation'}:</strong> ${explanationText}</div>`;
            }
        }
        
        function showQuizSetup(chapterId) {
            document.querySelector(`#${chapterId} .theory-view`).style.display = 'none';
            document.querySelector(`#${chapterId} .quiz-view`).style.display = 'block';
            document.querySelector(`#${chapterId} .quiz-setup`).style.display = 'block';
            document.querySelector(`#${chapterId} .quiz-container`).style.display = 'none';
            document.querySelector(`#${chapterId} .quiz-results`).style.display = 'none';
        }

        function showTheory(chapterId) {
            if(quizState[chapterId]) quizState[chapterId].isActive = false;
            document.querySelector(`#${chapterId} .theory-view`).style.display = 'block';
            document.querySelector(`#${chapterId} .quiz-view`).style.display = 'none';
        }

        function startQuiz(chapterId) {
            const allQuestions = contentData[chapterId].questions;
            const numQuestionsInput = document.getElementById(`num-questions-${chapterId}`);
            let numQuestions = parseInt(numQuestionsInput.value);
            if (isNaN(numQuestions) || numQuestions <= 0 || numQuestions > allQuestions.length) {
                numQuestions = Math.min(10, allQuestions.length);
                numQuestionsInput.value = numQuestions;
            }
            
            const questions = [...allQuestions].sort(() => 0.5 - Math.random()).slice(0, numQuestions);

            quizState[chapterId] = { questions, currentQuestionIndex: 0, score: 0, isActive: true };

            document.querySelector(`#${chapterId} .quiz-setup`).style.display = 'none';
            document.querySelector(`#${chapterId} .quiz-container`).style.display = 'block';
            document.querySelector(`#${chapterId} .quiz-results`).style.display = 'none';
            
            displayQuestion(chapterId);
        }

        function displayQuestion(chapterId) {
            const state = quizState[chapterId];
            if (state.currentQuestionIndex >= state.questions.length) {
                showResults(chapterId);
                return;
            }

            const question = state.questions[state.currentQuestionIndex];
            document.getElementById(`question-text-${chapterId}`).textContent = `(${state.currentQuestionIndex + 1}/${state.questions.length}) ${question.q[currentLang]}`;
            
            const optionsDiv = document.getElementById(`quiz-options-${chapterId}`);
            optionsDiv.innerHTML = '';
            question.o.forEach((option, index) => {
                const button = document.createElement('button');
                button.textContent = option[currentLang];
                button.onclick = () => selectAnswer(chapterId, index);
                optionsDiv.appendChild(button);
            });

            document.getElementById(`explanation-${chapterId}`).innerHTML = '';
            document.getElementById(`next-btn-${chapterId}`).style.display = 'none';
        }

        function selectAnswer(chapterId, selectedIndex) {
            const state = quizState[chapterId];
            const question = state.questions[state.currentQuestionIndex];
            const correctIndex = question.a;
            
            const options = document.querySelectorAll(`#${chapterId} .quiz-options button`);
            options.forEach(button => button.disabled = true);

            if (selectedIndex === correctIndex) {
                options[selectedIndex].classList.add('correct');
                state.score++;
            } else {
                options[selectedIndex].classList.add('incorrect');
                options[correctIndex].classList.add('correct');
                const explanationDiv = document.getElementById(`explanation-${chapterId}`);
                if(question.explanation) {
                    explanationDiv.innerHTML = `<div class="explanation-box"><strong>💡 ${currentLang === 'vi' ? 'Giải thích' : 'Explanation'}:</strong> ${question.explanation[currentLang]}</div>`;
                }
            }
            document.getElementById(`next-btn-${chapterId}`).style.display = 'inline-block';
        }

        function nextQuestion(chapterId) {
            quizState[chapterId].currentQuestionIndex++;
            displayQuestion(chapterId);
        }

        function showResults(chapterId) {
            const state = quizState[chapterId];
            state.isActive = false;
            document.querySelector(`#${chapterId} .quiz-container`).style.display = 'none';
            const resultsDiv = document.querySelector(`#${chapterId} .quiz-results`);
            resultsDiv.style.display = 'block';
            
            const scoreText = translations[currentLang].scoreText;
            document.getElementById(`score-${chapterId}`).textContent = `${scoreText} ${state.score} / ${state.questions.length} câu.`;
        }

        /**
         * UPDATED askAI function
         * This function now opens Google Gemini with a pre-filled, detailed prompt.
         */
        function askAI() {
            const activeChapter = document.querySelector('.tab-pane.active');
            const titleElement = activeChapter.querySelector('.theory-content h2');
            if (titleElement) {
                let topic = titleElement.textContent.trim();
                // Remove chapter number for a more natural query
                topic = topic.replace(/Chapter \d+:|Chương \d+:/i, '').trim();

                // Create a specific, detailed prompt for the AI
                const promptText = currentLang === 'vi' 
                    ? `Hãy giải thích chi tiết về chủ đề sau trong môn Khoa học máy tính: "${topic}". Vui lòng giải thích các khái niệm cốt lõi, cho ví dụ minh họa và nêu bật những điểm quan trọng nhất mà sinh viên cần nắm vững.`
                    : `Please provide a detailed explanation of the following topic in Computer Science: "${topic}". Explain the core concepts, provide illustrative examples, and highlight the most important points a student needs to master.`;

                const encodedPrompt = encodeURIComponent(promptText);
                
                // Construct the URL for Google Gemini with the pre-filled prompt
                const url = `https://gemini.google.com/app?prompt=${encodedPrompt}`;
                
                window.open(url, '_blank');
            }
        }
    </script>
</body>
</html>
