<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSI FPTU - Công cụ Ôn tập Nâng cao</title>
    <style>
        :root {
            --fpt-blue: #0055a5;
            --fpt-orange: #f26f21;
            --info-blue: #007bff;
            --text-color: #333;
            --bg-color: #f8f9fa;
            --container-bg: #ffffff;
            --highlight-bg: #fff3cd;
            --highlight-text: #856404;
            --correct-bg: #d4edda;
            --correct-border: #c3e6cb;
            --incorrect-bg: #f8d7da;
            --incorrect-border: #f5c6cb;
            --explanation-bg: #e2e3e5;
        }
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            line-height: 1.7;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        .container {
            max-width: 960px;
            margin: auto;
            background: var(--container-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        header {
            text-align: center;
            border-bottom: 3px solid var(--fpt-blue);
            padding-bottom: 15px;
            margin-bottom: 25px;
        }
        header h1 {
            color: var(--fpt-blue);
            margin: 0 0 5px 0;
        }
        .lang-switcher {
            margin-top: 15px;
        }
        .lang-switcher button {
            padding: 6px 12px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            cursor: pointer;
            margin: 0 5px;
            border-radius: 5px;
            font-size: 14px;
        }
        .lang-switcher button.active {
            background-color: var(--fpt-blue);
            color: white;
            border-color: var(--fpt-blue);
        }
        .tab-nav {
            display: flex;
            margin-bottom: 25px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .tab-link {
            flex: 1;
            padding: 15px;
            cursor: pointer;
            border: none;
            background-color: #e9ecef;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.3s, color 0.3s;
            text-align: center;
        }
        .tab-link.active {
            background-color: var(--fpt-orange);
            color: white;
        }
        .tab-link:hover:not(.active) {
            background-color: #dee2e6;
        }
        .tab-pane { display: none; }
        .tab-pane.active { display: block; }
        
        .theory-content h2 { color: var(--fpt-blue); border-bottom: 2px solid var(--fpt-orange); padding-bottom: 5px; }
        .theory-content h3 { color: #333; margin-top: 25px; }
        .theory-content h4 { color: #555; margin-top: 20px; }
        .theory-content ul { list-style-type: none; padding-left: 0; }
        .theory-content li { background: #f8f9fa; margin-bottom: 10px; padding: 15px; border-left: 4px solid var(--fpt-blue); border-radius: 5px; }
        .theory-content ul ul { margin-top: 10px; }
        .theory-content li li { background: #e9ecef; border-left-color: var(--fpt-orange); }
        .theory-content code, .theory-content pre {
            font-family: Consolas, 'Courier New', monospace;
            background-color: #e9ecef;
            padding: 2px 5px;
            border-radius: 4px;
        }
        .theory-content pre {
            padding: 15px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            border-left: 4px solid #ccc;
        }

        .highlight {
            background-color: var(--highlight-bg);
            padding: 3px 6px;
            border-radius: 4px;
            font-weight: bold;
            color: var(--highlight-text);
        }
        .quiz-view, .quiz-setup, .quiz-results { display: none; }
        .quiz-container, .quiz-setup, .quiz-results {
            border: 1px solid #dee2e6;
            padding: 25px;
            margin-top: 25px;
            border-radius: 8px;
            background-color: #fafafa;
        }
        .quiz-question {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .quiz-options button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 14px;
            margin: 8px 0;
            border: 1px solid #ccc;
            background-color: var(--container-bg);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            font-size: 16px;
        }
        .quiz-options button:hover:not([disabled]) {
            background-color: #e9e9e9;
            border-color: #aaa;
        }
        .quiz-options button.correct {
            background-color: var(--correct-bg);
            border-color: var(--correct-border);
            font-weight: bold;
        }
        .quiz-options button.incorrect {
            background-color: var(--incorrect-bg);
            border-color: var(--incorrect-border);
        }
        .explanation-box {
            margin-top: 15px;
            padding: 15px;
            background-color: var(--explanation-bg);
            border-radius: 6px;
            border: 1px solid #ced4da;
        }
        .button-group button, .quiz-setup button, .quiz-results button, .quiz-setup input {
            padding: 12px 22px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 6px;
            margin: 10px 5px 10px 0;
            border: none;
            font-weight: 500;
        }
        .quiz-setup input {
            width: 80px;
            border: 1px solid #ccc;
            border-radius: 6px;
            text-align: center;
        }
        .primary-button { background-color: var(--fpt-blue); color: white; }
        .secondary-button { background-color: #6c757d; color: white; }
        .info-button { background-color: var(--info-blue); color: white; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 data-lang-key="title">CSI FPTU - Công cụ Ôn tập Nâng cao</h1>
            <p data-lang-key="subtitle">Chọn chương để học lý thuyết hoặc làm bài tập trắc nghiệm.</p>
            <div class="lang-switcher">
                <button onclick="switchLanguage('vi')" class="active" data-lang-key="vietnamese">Tiếng Việt</button>
                <button onclick="switchLanguage('en')" data-lang-key="english">English</button>
            </div>
        </header>

        <div class="tab-nav">
            <button class="tab-link active" onclick="switchTab('chapter1')" data-lang-key="ch1">Chương 1</button>
            <button class="tab-link" onclick="switchTab('chapter2')" data-lang-key="ch2">Chương 2</button>
            <button class="tab-link" onclick="switchTab('chapter3')" data-lang-key="ch3">Chương 3</button>
            <button class="tab-link" onclick="switchTab('chapter4')" data-lang-key="ch4">Chương 4</button>
            <button class="tab-link" onclick="switchTab('chapter5')" data-lang-key="ch5">Chương 5</button>
        </div>

        <div class="tab-content">
            <!-- Content will be generated by JavaScript -->
        </div>
    </div>

    <script>
        // --- START: NGÂN HÀNG CÂU HỎI VÀ LÝ THUYẾT ---
        const contentData = {
            chapter1: {
                theory: {
                    vi: `
                        <h2>Chương 1: Giới thiệu Tổng quan</h2>
                        <h3>1. Các mô hình máy tính cơ bản</h3>
                        <ul>
                            <li>
                                <strong>Mô hình Turing (Turing Model):</strong>
                                <ul>
                                    <li>Định nghĩa máy tính như một <span class="highlight">bộ xử lý dữ liệu có thể lập trình được (programmable data processor)</span>.</li>
                                    <li>Đây là một mô hình lý thuyết, toán học, không phải kiến trúc vật lý.</li>
                                    <li>Công thức cốt lõi: <strong>Dữ liệu đầu vào + Chương trình -> Máy tính -> Dữ liệu đầu ra</strong>.</li>
                                    <li>Ý nghĩa: Cùng một dữ liệu đầu vào, nếu thay đổi chương trình, ta sẽ có kết quả đầu ra khác nhau. Điều này định nghĩa nên một máy tính đa năng (general-purpose).</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Mô hình von Neumann (von Neumann Model):</strong>
                                <ul>
                                    <li>Mô hình kiến trúc cho hầu hết các máy tính hiện đại.</li>
                                    <li><span class="highlight">Khái niệm đột phá: Chương trình được lưu trong bộ nhớ (Stored Program Concept)</span>. Cả chương trình (tập lệnh) và dữ liệu đều được lưu trữ trong cùng một bộ nhớ và có cùng định dạng (nhị phân).</li>
                                    <li>Kiến trúc bao gồm 4 hệ thống con (subsystems):
                                        <ol>
                                            <li><strong>Bộ nhớ (Memory):</strong> Lưu trữ chương trình và dữ liệu.</li>
                                            <li><strong>Đơn vị Số học & Logic (Arithmetic Logic Unit - ALU):</strong> Thực hiện các phép tính và so sánh logic.</li>
                                            <li><strong>Đơn vị Điều khiển (Control Unit):</strong> Điều phối hoạt động của tất cả các thành phần khác.</li>
                                            <li><strong>Hệ thống Vào/Ra (Input/Output Subsystem):</strong> Giao tiếp với thế giới bên ngoài (bàn phím, màn hình, ổ cứng...).</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Ba thành phần của máy tính</h3>
                        <ul>
                            <li><strong>Phần cứng (Hardware):</strong> Các thành phần vật lý của máy tính (CPU, RAM, ổ đĩa, ...).</li>
                            <li><strong>Dữ liệu (Data):</strong> Các thông tin thô (số, văn bản, hình ảnh) được máy tính xử lý. Dữ liệu được biểu diễn dưới dạng nhị phân.</li>
                            <li><strong>Phần mềm (Software):</strong> Tập hợp các chương trình (tập lệnh) hướng dẫn phần cứng phải làm gì. Phần mềm là cầu nối giữa người dùng và phần cứng.</li>
                        </ul>
                    `,
                    en: `
                        <h2>Chapter 1: Introduction</h2>
                        <h3>1. Basic Computer Models</h3>
                        <ul>
                            <li>
                                <strong>Turing Model:</strong>
                                <ul>
                                    <li>Defines a computer as a <span class="highlight">programmable data processor</span>.</li>
                                    <li>This is a theoretical, mathematical model, not a physical architecture.</li>
                                    <li>Core formula: <strong>Input Data + Program -> Computer -> Output Data</strong>.</li>
                                    <li>Significance: With the same input data, changing the program yields a different output. This defines a general-purpose computer.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>von Neumann Model:</strong>
                                <ul>
                                    <li>The architectural model for most modern computers.</li>
                                    <li><span class="highlight">Breakthrough concept: The Stored Program Concept</span>. Both the program (instructions) and data are stored in the same memory and share the same format (binary).</li>
                                    <li>The architecture consists of four subsystems:
                                        <ol>
                                            <li><strong>Memory:</strong> Stores programs and data.</li>
                                            <li><strong>Arithmetic Logic Unit (ALU):</strong> Performs calculations and logical comparisons.</li>
                                            <li><strong>Control Unit:</strong> Coordinates the operations of all other components.</li>
                                            <li><strong>Input/Output (I/O) Subsystem:</strong> Communicates with the outside world (keyboard, monitor, drives...).</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Three Components of a Computer</h3>
                        <ul>
                            <li><strong>Hardware:</strong> The physical parts of the computer (CPU, RAM, disk drive, etc.).</li>
                            <li><strong>Data:</strong> Raw information (numbers, text, images) that the computer processes. Data is represented in binary format.</li>
                            <li><strong>Software:</strong> A collection of programs (sets of instructions) that tells the hardware what to do. Software is the bridge between the user and the hardware.</li>
                        </ul>
                    `
                },
                questions: [
                    { q: { vi: "Thành phần nào sau đây KHÔNG phải là một hệ thống con trong mô hình von Neumann?", en: "Which of the following is NOT a subsystem in the von Neumann model?" }, o: [{ vi: "Memory (Bộ nhớ)", en: "Memory" }, { vi: "ALU", en: "ALU" }, { vi: "Compiler (Trình biên dịch)", en: "Compiler" }, { vi: "Control Unit (Đơn vị điều khiển)", en: "Control Unit" }], a: 2, explanation: { vi: "Trình biên dịch (Compiler) là phần mềm, không phải là một hệ thống con phần cứng trong kiến trúc von Neumann.", en: "A Compiler is a piece of software, not a hardware subsystem in the von Neumann architecture." } },
                    { q: { vi: "Chức năng chính của ALU là gì?", en: "What is the main function of the ALU?" }, o: [{ vi: "Lưu trữ lệnh", en: "Store instructions" }, { vi: "Thực hiện các phép toán số học và logic", en: "Perform arithmetic and logical operations" }, { vi: "Điều khiển thiết bị I/O", en: "Control I/O devices" }, { vi: "Dịch chương trình", en: "Translate programs" }], a: 1, explanation: { vi: "ALU (Arithmetic Logic Unit) chịu trách nhiệm thực hiện tất cả các phép tính toán (cộng, trừ) và so sánh logic (AND, OR).", en: "The ALU (Arithmetic Logic Unit) is responsible for performing all calculations (addition, subtraction) and logical comparisons (AND, OR)." } },
                    { q: { vi: "Thành phần nào chỉ đạo luồng thực thi của các lệnh trong máy tính?", en: "Which component directs the flow of instructions in a computer?" }, o: [{ vi: "ALU", en: "ALU" }, { vi: "Control Unit (Đơn vị điều khiển)", en: "Control Unit" }, { vi: "Memory (Bộ nhớ)", en: "Memory" }, { vi: "Input/Output (Vào/Ra)", en: "Input/Output" }], a: 1, explanation: { vi: "Đơn vị điều khiển (Control Unit) hoạt động như 'cảnh sát giao thông' của CPU, điều phối hoạt động của tất cả các thành phần khác.", en: "The Control Unit acts as the 'traffic cop' of the CPU, coordinating the actions of all other components." } },
                    { q: { vi: "Mục đích của bộ nhớ (memory) trong mô hình von Neumann là gì?", en: "What is the purpose of memory in the von Neumann model?" }, o: [{ vi: "Thực hiện tính toán", en: "Perform calculations" }, { vi: "Lưu trữ chương trình và dữ liệu", en: "Store programs and data" }, { vi: "Điều khiển việc thực thi", en: "Control execution" }, { vi: "Nhập dữ liệu từ người dùng", en: "Input data from users" }], a: 1, explanation: { vi: "Bộ nhớ chính (Main Memory) được sử dụng để chứa cả các lệnh của chương trình và dữ liệu mà chương trình đó đang thao tác.", en: "Main Memory is used to hold both the program's instructions and the data it operates on." } },
                    { q: { vi: "Khái niệm “chương trình được lưu trữ” (stored-program concept) có nghĩa là gì?", en: "What does 'stored-program concept' mean?" }, o: [{ vi: "Chương trình được lưu trữ trong các công tắc phần cứng", en: "Programs stored in hardware switches" }, { vi: "Chương trình được lưu trữ trong bộ nhớ cùng với dữ liệu", en: "Programs stored in memory along with data" }, { vi: "Chương trình chỉ chạy từ các thiết bị bên ngoài", en: "Programs only run from external devices" }, { vi: "Chương trình được nối cứng vào CPU", en: "Programs hardwired into CPU" }], a: 1, explanation: { vi: "Đây là ý tưởng đột phá của von Neumann: cả chương trình và dữ liệu đều là các chuỗi bit và được lưu trong cùng một bộ nhớ.", en: "This was von Neumann's breakthrough idea: both programs and data are bit patterns and are stored in the same memory." } },
                    { q: { vi: "Ai là người đã giới thiệu khái niệm Máy Turing Phổ quát (Universal Turing Machine)?", en: "Who introduced the concept of a Universal Turing Machine?" }, o: [{ vi: "Charles Babbage", en: "Charles Babbage" }, { vi: "Alan Turing", en: "Alan Turing" }, { vi: "John von Neumann", en: "John von Neumann" }, { vi: "Blaise Pascal", en: "Blaise Pascal" }], a: 1, explanation: { vi: "Alan Turing đã đưa ra mô hình lý thuyết về một máy tính có thể lập trình để mô phỏng bất kỳ máy tính nào khác.", en: "Alan Turing introduced the theoretical model of a programmable computer that could simulate any other computer." } },
                    { q: { vi: "Máy nào sau đây được thiết kế bởi Charles Babbage?", en: "Which of the following machines was designed by Charles Babbage?" }, o: [{ vi: "Pascaline", en: "Pascaline" }, { vi: "ENIAC", en: "ENIAC" }, { vi: "Analytical Engine (Máy giải tích)", en: "Analytical Engine" }, { vi: "Jacquard Loom (Máy dệt Jacquard)", en: "Jacquard Loom" }], a: 2, explanation: { vi: "Máy giải tích (Analytical Engine) là một thiết kế máy tính cơ học đa năng của Charles Babbage, được coi là tiền thân của máy tính hiện đại.", en: "The Analytical Engine was a design for a general-purpose mechanical computer by Charles Babbage, considered a precursor to modern computers." } },
                    { q: { vi: "Máy nào đã sử dụng thẻ đục lỗ để tạo ra các mẫu dệt?", en: "Which machine used punch cards for weaving patterns?" }, o: [{ vi: "Hollerith Tabulator (Máy lập bảng Hollerith)", en: "Hollerith Tabulator" }, { vi: "Jacquard Loom (Máy dệt Jacquard)", en: "Jacquard Loom" }, { vi: "ENIAC", en: "ENIAC" }, { vi: "Pascaline", en: "Pascaline" }], a: 1, explanation: { vi: "Máy dệt Jacquard là một ví dụ sớm về việc sử dụng thẻ đục lỗ để lưu trữ một chương trình (mẫu dệt).", en: "The Jacquard Loom is an early example of using punched cards to store a program (the weaving pattern)." } },
                    { q: { vi: "Máy tính điện tử đa năng đầu tiên là gì?", en: "What was the first general-purpose electronic computer?" }, o: [{ vi: "ENIAC", en: "ENIAC" }, { vi: "EDVAC", en: "EDVAC" }, { vi: "Colossus", en: "Colossus" }, { vi: "Mark I", en: "Mark I" }], a: 0, explanation: { vi: "ENIAC (Electronic Numerical Integrator And Computer) được công nhận rộng rãi là máy tính điện tử đa năng đầu tiên.", en: "ENIAC (Electronic Numerical Integrator And Computer) is widely recognized as the first general-purpose electronic computer." } },
                    { q: { vi: "Máy tính nào là máy đầu tiên thực thi khái niệm chương trình được lưu trữ?", en: "Which was the first computer to implement the stored-program concept?" }, o: [{ vi: "ENIAC", en: "ENIAC" }, { vi: "EDSAC", en: "EDSAC" }, { vi: "Jacquard Loom (Máy dệt Jacquard)", en: "Jacquard Loom" }, { vi: "Hollerith Tabulator (Máy lập bảng Hollerith)", en: "Hollerith Tabulator" }], a: 1, explanation: { vi: "EDSAC (Electronic Delay Storage Automatic Calculator) là một trong những máy tính đầu tiên được chế tạo theo kiến trúc von Neumann.", en: "EDSAC (Electronic Delay Storage Automatic Calculator) was one of the first computers built based on the von Neumann architecture." } },
                    { q: { vi: "Thế hệ máy tính nào sử dụng đèn chân không (vacuum tubes)?", en: "Which generation of computers used vacuum tubes?" }, o: [{ vi: "Thế hệ thứ nhất", en: "First" }, { vi: "Thế hệ thứ hai", en: "Second" }, { vi: "Thế hệ thứ ba", en: "Third" }, { vi: "Thế hệ thứ tư", en: "Fourth" }], a: 0, explanation: { vi: "Máy tính thế hệ đầu tiên rất lớn, đắt tiền và không đáng tin cậy vì chúng dựa vào công nghệ đèn chân không.", en: "First-generation computers were large, expensive, and unreliable because they relied on vacuum tube technology." } },
                    { q: { vi: "Thế hệ máy tính nào đã giới thiệu bóng bán dẫn (transistors)?", en: "Which generation of computers introduced transistors?" }, o: [{ vi: "Thế hệ thứ nhất", en: "First" }, { vi: "Thế hệ thứ hai", en: "Second" }, { vi: "Thế hệ thứ ba", en: "Third" }, { vi: "Thế hệ thứ tư", en: "Fourth" }], a: 1, explanation: { vi: "Sự ra đời của bóng bán dẫn trong thế hệ thứ hai đã làm cho máy tính nhỏ hơn, nhanh hơn, rẻ hơn và đáng tin cậy hơn.", en: "The advent of the transistor in the second generation made computers smaller, faster, cheaper, and more reliable." } },
                    { q: { vi: "Thế hệ máy tính nào đã giới thiệu mạch tích hợp (integrated circuits)?", en: "Which generation of computers introduced integrated circuits?" }, o: [{ vi: "Thế hệ thứ nhất", en: "First" }, { vi: "Thế hệ thứ hai", en: "Second" }, { vi: "Thế hệ thứ ba", en: "Third" }, { vi: "Thế hệ thứ tư", en: "Fourth" }], a: 2, explanation: { vi: "Mạch tích hợp (IC) cho phép đặt nhiều bóng bán dẫn lên một con chip duy nhất, đánh dấu sự khởi đầu của thế hệ thứ ba.", en: "Integrated circuits (ICs) allowed many transistors to be placed on a single chip, marking the beginning of the third generation." } },
                    { q: { vi: "Thế hệ máy tính nào đã giới thiệu bộ vi xử lý (microprocessors)?", en: "Which generation of computers introduced microprocessors?" }, o: [{ vi: "Thế hệ thứ nhất", en: "First" }, { vi: "Thế hệ thứ hai", en: "Second" }, { vi: "Thế hệ thứ ba", en: "Third" }, { vi: "Thế hệ thứ tư", en: "Fourth" }], a: 3, explanation: { vi: "Thế hệ thứ tư được định nghĩa bởi sự phát minh ra bộ vi xử lý, tích hợp toàn bộ CPU lên một con chip duy nhất.", en: "The fourth generation is defined by the invention of the microprocessor, which integrated an entire CPU onto a single chip." } },
                    { q: { vi: "Thiết bị nào sau đây KHÔNG phải là thiết bị đầu vào (input device)?", en: "Which of the following is NOT an input device?" }, o: [{ vi: "Bàn phím", en: "Keyboard" }, { vi: "Chuột", en: "Mouse" }, { vi: "Máy in", en: "Printer" }, { vi: "Máy quét", en: "Scanner" }], a: 2, explanation: { vi: "Máy in là một thiết bị đầu ra (output) vì nó nhận dữ liệu từ máy tính và tạo ra bản cứng.", en: "A printer is an output device because it receives data from the computer and produces a hard copy." } },
                    { q: { vi: "Thiết bị nào sau đây là một thiết bị đầu ra (output device)?", en: "Which of the following is an output device?" }, o: [{ vi: "Màn hình", en: "Monitor" }, { vi: "Bàn phím", en: "Keyboard" }, { vi: "Chuột", en: "Mouse" }, { vi: "Máy quét", en: "Scanner" }], a: 0, explanation: { vi: "Màn hình hiển thị thông tin từ máy tính cho người dùng, làm cho nó trở thành một thiết bị đầu ra.", en: "A monitor displays information from the computer to the user, making it an output device." } },
                    { q: { vi: "Thành phần nào chịu trách nhiệm thực hiện các phép so sánh logic?", en: "Which component is responsible for performing logical comparisons?" }, o: [{ vi: "Đơn vị điều khiển", en: "Control Unit" }, { vi: "Bộ nhớ", en: "Memory" }, { vi: "ALU", en: "ALU" }, { vi: "Hệ thống con I/O", en: "I/O Subsystem" }], a: 2, explanation: { vi: "Chữ 'L' trong ALU là viết tắt của Logic, và nó xử lý các phép so sánh như bằng, lớn hơn, hoặc nhỏ hơn.", en: "The 'L' in ALU stands for Logic, and it handles comparisons like equal to, greater than, or less than." } },
                    { q: { vi: "Máy nào đã sử dụng thẻ đục lỗ để xử lý dữ liệu điều tra dân số?", en: "Which machine used punch cards for census data processing?" }, o: [{ vi: "Máy dệt Jacquard", en: "Jacquard Loom" }, { vi: "Máy lập bảng Hollerith", en: "Hollerith Tabulator" }, { vi: "ENIAC", en: "ENIAC" }, { vi: "EDSAC", en: "EDSAC" }], a: 1, explanation: { vi: "Máy lập bảng của Herman Hollerith đã tự động hóa việc kiểm đếm dữ liệu từ cuộc điều tra dân số Hoa Kỳ năm 1890, giảm đáng kể thời gian xử lý.", en: "Herman Hollerith's tabulating machine automated the counting of data from the 1890 U.S. Census, drastically reducing processing time." } },
                    { q: { vi: "Ngôn ngữ nào đã được giới thiệu trong thế hệ máy tính thứ hai?", en: "Which language was introduced in the second generation of computers?" }, o: [{ vi: "Ngôn ngữ máy", en: "Machine Language" }, { vi: "Hợp ngữ", en: "Assembly" }, { vi: "FORTRAN", en: "FORTRAN" }, { vi: "Java", en: "Java" }], a: 2, explanation: { vi: "FORTRAN và COBOL là hai trong số các ngôn ngữ lập trình bậc cao đầu tiên được phát triển trong thế hệ thứ hai.", en: "FORTRAN and COBOL were two of the first high-level programming languages developed during the second generation." } },
                    { q: { vi: "COBOL chủ yếu được thiết kế cho loại ứng dụng nào?", en: "COBOL was mainly designed for which type of applications?" }, o: [{ vi: "Khoa học", en: "Scientific" }, { vi: "Kinh doanh", en: "Business" }, { vi: "Trí tuệ nhân tạo", en: "Artificial Intelligence" }, { vi: "Đồ họa", en: "Graphics" }], a: 1, explanation: { vi: "COBOL (COmmon Business-Oriented Language) được tạo ra đặc biệt để xử lý dữ liệu trong các ứng dụng kinh doanh, tài chính và hành chính.", en: "COBOL (COmmon Business-Oriented Language) was created specifically for data processing in business, finance, and administrative applications." } },
                    { q: { vi: "Thuật ngữ nào sau đây gần nhất với định nghĩa của một thuật toán (algorithm)?", en: "Which of the following is closest to the definition of an algorithm?" }, o: [{ vi: "Chuỗi lệnh ngẫu nhiên", en: "Random sequence of instructions" }, { vi: "Quy trình từng bước để giải quyết một vấn đề", en: "Step-by-step procedure to solve a problem" }, { vi: "Thiết kế phần cứng máy tính", en: "Computer hardware design" }, { vi: "Hệ điều hành", en: "Operating system" }], a: 1, explanation: { vi: "Một thuật toán là một tập hợp hữu hạn các chỉ thị được định nghĩa rõ ràng để giải quyết một vấn đề cụ thể.", en: "An algorithm is a finite set of well-defined instructions for solving a specific problem." } },
                    { q: { vi: "Thuật ngữ nào sau đây định nghĩa tốt nhất một lệnh (instruction)?", en: "Which of the following best defines an instruction?" }, o: [{ vi: "Một chương trình", en: "A program" }, { vi: "Một lệnh duy nhất được CPU thực thi", en: "A single command executed by the CPU" }, { vi: "Một gói phần mềm", en: "A software package" }, { vi: "Một thành phần phần cứng", en: "A hardware component" }], a: 1, explanation: { vi: "Một chương trình được tạo thành từ nhiều lệnh; mỗi lệnh là một hành động đơn lẻ mà CPU có thể thực hiện.", en: "A program is made up of many instructions; each instruction is a single action the CPU can perform." } },
                    { q: { vi: "Ví dụ nào sau đây là dữ liệu đầu ra (output data)?", en: "Which of the following is an example of output data?" }, o: [{ vi: "Người dùng gõ mật khẩu", en: "User typing a password" }, { vi: "CPU thực hiện phép cộng", en: "CPU performing addition" }, { vi: "Hiển thị kết quả trên màn hình", en: "Displaying a result on the screen" }, { vi: "Nạp chương trình vào bộ nhớ", en: "Loading a program into memory" }], a: 2, explanation: { vi: "Dữ liệu đầu ra là thông tin được gửi từ máy tính ra thế giới bên ngoài, chẳng hạn như hiển thị trên màn hình.", en: "Output data is information sent from the computer to the outside world, such as being displayed on a screen." } },
                    { q: { vi: "Kiến trúc von Neumann lưu trữ cả chương trình và dữ liệu trong:", en: "The von Neumann architecture stores both program and data in:" }, o: [{ vi: "ALU", en: "ALU" }, { vi: "Bộ nhớ", en: "Memory" }, { vi: "Thiết bị I/O", en: "I/O devices" }, { vi: "Chỉ bộ nhớ cache", en: "Cache only" }], a: 1, explanation: { vi: "Đặc điểm xác định của kiến trúc von Neumann là một bộ nhớ duy nhất được chia sẻ cho cả lệnh và dữ liệu.", en: "The defining characteristic of the von Neumann architecture is a single, shared memory for both instructions and data." } },
                    { q: { vi: "CPU là viết tắt của từ gì?", en: "What does CPU stand for?" }, o: [{ vi: "Central Processing Unit", en: "Central Processing Unit" }, { vi: "Central Programming Unit", en: "Central Programming Unit" }, { vi: "Control Processing Utility", en: "Control Processing Utility" }, { vi: "Computer Power Unit", en: "Computer Power Unit" }], a: 0, explanation: { vi: "CPU là viết tắt của Central Processing Unit, bộ não của máy tính.", en: "CPU stands for Central Processing Unit, the brain of the computer." } },
                    { q: { vi: "Thuật ngữ nào sau đây mô tả tốt nhất phần mềm (software)?", en: "Which of the following best describes software?" }, o: [{ vi: "Các thành phần vật lý", en: "Physical components" }, { vi: "Các mạch điện", en: "Electrical circuits" }, { vi: "Các chương trình và chỉ thị", en: "Programs and instructions" }, { vi: "Các thiết bị vào/ra", en: "Input/Output devices" }], a: 2, explanation: { vi: "Phần mềm là một thuật ngữ chung cho các chương trình, chỉ thị và dữ liệu hướng dẫn phần cứng phải làm gì.", en: "Software is a general term for the programs, instructions, and data that tell the hardware what to do." } },
                    { q: { vi: "Cái nào sau đây KHÔNG phải là một ví dụ về dữ liệu?", en: "Which of the following is NOT an example of data?" }, o: [{ vi: "Số", en: "Numbers" }, { vi: "Văn bản", en: "Text" }, { vi: "Thuật toán", en: "Algorithms" }, { vi: "Hình ảnh", en: "Images" }], a: 2, explanation: { vi: "Dữ liệu là thông tin thô (số, văn bản). Một thuật toán là một quy trình để xử lý dữ liệu, không phải là bản thân dữ liệu.", en: "Data is raw information (numbers, text). An algorithm is a procedure for processing data, not the data itself." } },
                    { q: { vi: "Cái nào sau đây được coi là phần cứng (hardware)?", en: "Which of the following is considered hardware?" }, o: [{ vi: "Hệ điều hành", en: "Operating System" }, { vi: "Cơ sở dữ liệu", en: "Database" }, { vi: "Đơn vị điều khiển", en: "Control Unit" }, { vi: "Trình biên dịch", en: "Compiler" }], a: 2, explanation: { vi: "Đơn vị điều khiển (Control Unit) là một thành phần vật lý bên trong CPU, do đó nó là phần cứng.", en: "The Control Unit is a physical component inside the CPU, therefore it is hardware." } },
                    { q: { vi: "Hệ thống con nào giao tiếp với thế giới bên ngoài?", en: "Which subsystem communicates with the outside world?" }, o: [{ vi: "Bộ nhớ", en: "Memory" }, { vi: "Đơn vị điều khiển", en: "Control Unit" }, { vi: "ALU", en: "ALU" }, { vi: "Hệ thống con I/O", en: "I/O Subsystem" }], a: 3, explanation: { vi: "Hệ thống con I/O (Vào/Ra) bao gồm tất cả các thiết bị được sử dụng để đưa thông tin vào và lấy thông tin ra khỏi máy tính.", en: "The I/O (Input/Output) subsystem includes all devices used to get information into and out of the computer." } },
                    { q: { vi: "Loại ngôn ngữ nào gần nhất với ngôn ngữ máy?", en: "Which type of language is closest to machine language?" }, o: [{ vi: "Hợp ngữ", en: "Assembly" }, { vi: "Ngôn ngữ bậc cao", en: "High-level language" }, { vi: "Ngôn ngữ tự nhiên", en: "Natural language" }, { vi: "Ngôn ngữ hướng đối tượng", en: "Object-oriented language" }], a: 0, explanation: { vi: "Hợp ngữ (Assembly) là một biểu diễn dạng văn bản, có thể đọc được của ngôn ngữ máy, với sự tương ứng gần như một-một giữa các lệnh.", en: "Assembly language is a textual, human-readable representation of machine language, with a near one-to-one correspondence between instructions." } },
                    { q: { vi: "Máy Turing Phổ quát (Universal Turing Machine) có thể:", en: "The Universal Turing Machine can:" }, o: [{ vi: "Giải quyết mọi vấn đề có thể có", en: "Solve every possible problem" }, { vi: "Mô phỏng bất kỳ máy Turing nào khác", en: "Simulate any other Turing machine" }, { vi: "Thực hiện các tác vụ song song vô hạn", en: "Perform infinite parallel tasks" }, { vi: "Thực thi chương trình mà không cần bộ nhớ", en: "Execute programs without memory" }], a: 1, explanation: { vi: "Ý tưởng chính của Máy Turing Phổ quát là nó là một máy có thể lập trình để thực hiện công việc của bất kỳ máy Turing chuyên dụng nào khác.", en: "The key idea of the Universal Turing Machine is that it's one machine that can be programmed to do the job of any other specialized Turing machine." } },
                    { q: { vi: "Điều nào sau đây là ĐÚNG về ENIAC?", en: "Which is TRUE about ENIAC?" }, o: [{ vi: "Nó có thể lập trình bằng thẻ đục lỗ", en: "It was programmable by punch cards" }, { vi: "Nó sử dụng đèn chân không", en: "It used vacuum tubes" }, { vi: "Nó có bộ vi xử lý", en: "It had microprocessors" }, { vi: "Nó là một máy tính có chương trình được lưu trữ", en: "It was a stored-program computer" }], a: 1, explanation: { vi: "ENIAC là một máy tính thuộc thế hệ thứ nhất và được xây dựng bằng hàng nghìn đèn chân không.", en: "ENIAC was a first-generation computer and was built using thousands of vacuum tubes." } },
                    { q: { vi: "Điều nào giải thích tốt nhất tại sao hệ nhị phân được sử dụng trong máy tính?", en: "Which best explains why binary is used in computers?" }, o: [{ vi: "Con người hiểu nó dễ dàng", en: "Humans understand it easily" }, { vi: "Chỉ hai trạng thái dễ dàng biểu diễn bằng điện tử", en: "Only two states are easy to represent electronically" }, { vi: "Nó nhanh hơn cho toán học", en: "It is faster for math" }, { vi: "Nó giảm việc sử dụng bộ nhớ", en: "It reduces memory usage" }], a: 1, explanation: { vi: "Các mạch điện tử có thể dễ dàng được thiết kế để ở một trong hai trạng thái (bật/tắt, cao/thấp), tương ứng hoàn hảo với 1 và 0.", en: "Electronic circuits can easily be designed to be in one of two states (on/off, high/low), which corresponds perfectly to 1s and 0s." } },
                    { q: { vi: "Cái nào sau đây là một ngôn ngữ bậc cao?", en: "Which of the following is a high-level language?" }, o: [{ vi: "Hợp ngữ", en: "Assembly" }, { vi: "Mã máy", en: "Machine code" }, { vi: "COBOL", en: "COBOL" }, { vi: "Vi mã (Microcode)", en: "Microcode" }], a: 2, explanation: { vi: "COBOL là một ngôn ngữ bậc cao vì các lệnh của nó gần với ngôn ngữ của con người hơn và trừu tượng hóa các chi tiết của phần cứng.", en: "COBOL is a high-level language because its instructions are closer to human language and abstract away the hardware details." } },
                    { q: { vi: "Lợi thế chính của khái niệm chương trình được lưu trữ là gì?", en: "Which of the following was the main advantage of the stored-program concept?" }, o: [{ vi: "In nhanh hơn", en: "Faster printing" }, { vi: "Các chương trình có thể được sửa đổi trong bộ nhớ", en: "Programs can be modified in memory" }, { vi: "Màn hình lớn hơn", en: "Larger monitors" }, { vi: "Bàn phím tốt hơn", en: "Better keyboards" }], a: 1, explanation: { vi: "Việc lưu trữ chương trình trong bộ nhớ cho phép chúng dễ dàng được thay đổi hoặc thay thế, làm cho máy tính trở nên đa năng.", en: "Storing programs in memory allows them to be easily changed or replaced, making the computer general-purpose." } },
                    { q: { vi: "Vai trò chính của Đơn vị Điều khiển (Control Unit) là gì?", en: "What is the main role of the Control Unit?" }, o: [{ vi: "Lưu trữ dữ liệu", en: "Store data" }, { vi: "Thực hiện các phép toán số học", en: "Perform arithmetic operations" }, { vi: "Chỉ đạo việc thực thi chương trình", en: "Direct program execution" }, { vi: "Nhập lệnh của người dùng", en: "Input user commands" }], a: 2, explanation: { vi: "Đơn vị điều khiển tìm nạp, giải mã và chỉ đạo việc thực thi các lệnh của chương trình.", en: "The Control Unit fetches, decodes, and directs the execution of program instructions." } },
                    { q: { vi: "Thế hệ nào đã giới thiệu hệ điều hành?", en: "Which generation introduced operating systems?" }, o: [{ vi: "Thế hệ thứ nhất", en: "First" }, { vi: "Thế hệ thứ hai", en: "Second" }, { vi: "Thế hệ thứ ba", en: "Third" }, { vi: "Thế hệ thứ tư", en: "Fourth" }], a: 2, explanation: { vi: "Các hệ điều hành phức tạp đã trở nên phổ biến trong thế hệ thứ ba để quản lý các máy tính mạnh hơn dựa trên mạch tích hợp.", en: "Complex operating systems became common in the third generation to manage the more powerful integrated circuit-based computers." } },
                    { q: { vi: "Thế hệ nào đã giới thiệu mạng và các hệ thống phân tán?", en: "Which generation introduced networking and distributed systems?" }, o: [{ vi: "Thế hệ thứ nhất", en: "First" }, { vi: "Thế hệ thứ hai", en: "Second" }, { vi: "Thế hệ thứ ba", en: "Third" }, { vi: "Thế hệ thứ tư", en: "Fourth" }], a: 3, explanation: { vi: "Thế hệ thứ tư, với sự ra đời của máy tính cá nhân, đã dẫn đến sự phát triển của mạng máy tính và Internet.", en: "The fourth generation, with the advent of personal computers, led to the development of computer networks and the Internet." } },
                    { q: { vi: "I/O là viết tắt của từ gì?", en: "What does I/O stand for?" }, o: [{ vi: "Information/Operation", en: "Information/Operation" }, { vi: "Input/Output", en: "Input/Output" }, { vi: "Internal/Outside", en: "Internal/Outside" }, { vi: "Instruction/Operand", en: "Instruction/Operand" }], a: 1, explanation: { vi: "I/O là viết tắt của Input/Output, đề cập đến việc giao tiếp giữa máy tính và thế giới bên ngoài.", en: "I/O stands for Input/Output, referring to the communication between a computer and the outside world." } },
                    { q: { vi: "Cái nào sau đây là một ví dụ về bộ nhớ thứ cấp (secondary storage)?", en: "Which of the following is an example of secondary storage?" }, o: [{ vi: "RAM", en: "RAM" }, { vi: "Cache", en: "Cache" }, { vi: "Đĩa cứng", en: "Hard Disk" }, { vi: "Thanh ghi", en: "Registers" }], a: 2, explanation: { vi: "Bộ nhớ thứ cấp là bộ nhớ không khả biến (non-volatile) được sử dụng để lưu trữ lâu dài, chẳng hạn như đĩa cứng.", en: "Secondary storage is non-volatile memory used for long-term storage, such as a hard disk." } },
                    { q: { vi: "Cái nào sau đây KHÔNG phải là bộ nhớ khả biến (volatile memory)?", en: "Which of the following is NOT volatile memory?" }, o: [{ vi: "RAM", en: "RAM" }, { vi: "Cache", en: "Cache" }, { vi: "Đĩa cứng", en: "Hard Disk" }, { vi: "Thanh ghi", en: "Registers" }], a: 2, explanation: { vi: "Bộ nhớ khả biến mất nội dung khi mất điện. Đĩa cứng giữ lại dữ liệu, do đó nó không khả biến.", en: "Volatile memory loses its contents when power is removed. A hard disk retains its data, so it is non-volatile." } },
                    { q: { vi: "Cái nào sau đây là một ví dụ về bộ nhớ khả biến (volatile memory)?", en: "Which of the following is an example of volatile memory?" }, o: [{ vi: "Đĩa cứng", en: "Hard Disk" }, { vi: "ROM", en: "ROM" }, { vi: "RAM", en: "RAM" }, { vi: "CD-ROM", en: "CD-ROM" }], a: 2, explanation: { vi: "RAM (Random-Access Memory) là khả biến; nội dung của nó sẽ bị mất khi máy tính bị tắt.", en: "RAM (Random-Access Memory) is volatile; its contents are lost when the computer is turned off." } },
                    { q: { vi: "Thuật ngữ nào mô tả đơn vị dữ liệu nhỏ nhất trong máy tính?", en: "Which term describes the smallest unit of data in a computer?" }, o: [{ vi: "Byte", en: "Byte" }, { vi: "Word", en: "Word" }, { vi: "Bit", en: "Bit" }, { vi: "Instruction", en: "Instruction" }], a: 2, explanation: { vi: "Một bit là đơn vị dữ liệu cơ bản nhất, có thể giữ giá trị 0 hoặc 1.", en: "A bit is the most fundamental unit of data, capable of holding a value of 0 or 1." } },
                    { q: { vi: "Có bao nhiêu bit trong 1 byte?", en: "How many bits are in 1 byte?" }, o: [{ vi: "2", en: "2" }, { vi: "4", en: "4" }, { vi: "8", en: "8" }, { vi: "16", en: "16" }], a: 2, explanation: { vi: "Theo quy ước, một byte bao gồm 8 bit.", en: "By convention, one byte consists of 8 bits." } },
                    { q: { vi: "Hạn chế chính của ENIAC là gì?", en: "What was the main limitation of ENIAC?" }, o: [{ vi: "Nó không thể lập trình được", en: "It was not programmable" }, { vi: "Nó quá nhỏ", en: "It was too small" }, { vi: "Nó tiêu thụ quá ít điện", en: "It consumed too little power" }, { vi: "Nó có thể di động", en: "It was portable" }], a: 0, explanation: { vi: "ENIAC phải được lập trình lại bằng cách cắm lại dây và đặt lại công tắc một cách thủ công, một quá trình rất tẻ nhạt. Nó không phải là một máy tính có chương trình được lưu trữ.", en: "ENIAC had to be reprogrammed by manually replugging wires and resetting switches, a very tedious process. It was not a stored-program computer." } },
                    { q: { vi: "Cái nào KHÔNG phải là đặc điểm của máy tính thế hệ thứ ba?", en: "Which is NOT a characteristic of third generation computers?" }, o: [{ vi: "Sử dụng mạch tích hợp", en: "Use of integrated circuits" }, { vi: "Giới thiệu các ngôn ngữ bậc cao", en: "Introduction of high-level languages" }, { vi: "Giảm kích thước và chi phí", en: "Reduced size and cost" }, { vi: "Sử dụng đèn chân không", en: "Use of vacuum tubes" }], a: 3, explanation: { vi: "Đèn chân không là đặc trưng của thế hệ thứ nhất. Thế hệ thứ ba sử dụng mạch tích hợp.", en: "Vacuum tubes are characteristic of the first generation. The third generation used integrated circuits." } },
                    { q: { vi: "Ai được coi là 'cha đẻ của kiến trúc máy tính hiện đại'?", en: "Who is considered the 'father of modern computing architecture'?" }, o: [{ vi: "Alan Turing", en: "Alan Turing" }, { vi: "John von Neumann", en: "John von Neumann" }, { vi: "Blaise Pascal", en: "Blaise Pascal" }, { vi: "Charles Babbage", en: "Charles Babbage" }], a: 1, explanation: { vi: "John von Neumann được ghi công với việc mô tả kiến trúc máy tính có chương trình được lưu trữ, hiện là nền tảng cho hầu hết các máy tính.", en: "John von Neumann is credited with describing the stored-program computer architecture that is now the basis for most computers." } },
                    { q: { vi: "Thuật ngữ nào đề cập đến các chỉ thị từng bước được CPU thực thi?", en: "Which term refers to step-by-step instructions executed by the CPU?" }, o: [{ vi: "Thuật toán", en: "Algorithm" }, { vi: "Lệnh", en: "Instruction" }, { vi: "Dữ liệu", en: "Data" }, { vi: "Chương trình", en: "Program" }], a: 1, explanation: { vi: "Một lệnh (instruction) là một hoạt động cơ bản duy nhất mà CPU có thể thực hiện.", en: "An instruction is a single basic operation that the CPU can perform." } },
                    { q: { vi: "Loại máy tính nào thường là lớn nhất và mạnh nhất?", en: "Which type of computer is typically the largest and most powerful?" }, o: [{ vi: "Máy vi tính", en: "Microcomputer" }, { vi: "Máy tính mini", en: "Minicomputer" }, { vi: "Máy tính lớn", en: "Mainframe" }, { vi: "Siêu máy tính", en: "Supercomputer" }], a: 3, explanation: { vi: "Siêu máy tính được thiết kế cho các nhiệm vụ tính toán chuyên sâu và là loại máy tính mạnh nhất.", en: "Supercomputers are designed for computationally intensive tasks and are the most powerful type of computer." } },
                    { q: { vi: "Điều nào sau đây là ĐÚNG về 'nút cổ chai von Neumann' (von Neumann bottleneck)?", en: "Which is TRUE about the von Neumann bottleneck?" }, o: [{ vi: "Nó làm tăng tốc độ CPU", en: "It increases CPU speed" }, { vi: "Nó giới hạn tốc độ truyền dữ liệu giữa CPU và bộ nhớ", en: "It limits data transfer between CPU and memory" }, { vi: "Nó cho phép thực thi song song", en: "It allows parallel execution" }, { vi: "Nó loại bỏ việc tìm nạp lệnh", en: "It eliminates instruction fetch" }], a: 1, explanation: { vi: "Nút cổ chai von Neumann đề cập đến việc CPU thường phải chờ đợi dữ liệu từ bộ nhớ do đường dẫn chung, làm hạn chế hiệu suất tổng thể.", en: "The von Neumann bottleneck refers to the fact that the CPU often has to wait for data from memory due to the shared bus, limiting overall performance." } }
                ]
            },
            chapter2: {
                theory: {
                     vi: `
                        <h2>Chương 2: Hệ thống Số</h2>
                        <h3>1. Các hệ đếm cơ bản (Positional Number Systems)</h3>
                        <ul>
                            <li><strong>Khái niệm:</strong> Giá trị của một chữ số phụ thuộc vào <span class="highlight">vị trí (position)</span> của nó trong chuỗi số. Mỗi vị trí có một trọng số (place value) là lũy thừa của cơ số (base/radix).</li>
                            <li><strong>Các hệ đếm chính:</strong>
                                <ul>
                                    <li><strong>Thập phân (Decimal - Base 10):</strong> Dùng 10 ký tự {0, 1, ..., 9}.</li>
                                    <li><strong>Nhị phân (Binary - Base 2):</strong> Dùng 2 ký tự {0, 1}. Đây là <span class="highlight">ngôn ngữ tự nhiên của máy tính</span>.</li>
                                    <li><strong>Bát phân (Octal - Base 8):</strong> Dùng 8 ký tự {0, 1, ..., 7}.</li>
                                    <li><strong>Thập lục phân (Hexadecimal - Base 16):</strong> Dùng 16 ký tự {0, 1, ..., 9, A, B, C, D, E, F}.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Ví dụ về Chuyển đổi</h3>
                        <h4>Chuyển từ hệ bất kỳ sang Thập phân</h4>
                        <p>Quy tắc: Lấy từng chữ số nhân với (cơ số)<sup>vị trí</sup> rồi cộng tất cả lại.</p>
                        <pre><strong>Ví dụ 1: (11001)₂ sang thập phân</strong>
N = 1×2⁴ + 1×2³ + 0×2² + 0×2¹ + 1×2⁰ = 25₁₀
<strong>Ví dụ 2: (2AE)₁₆ sang thập phân (A=10, E=14)</strong>
N = 2×16² + 10×16¹ + 14×16⁰ = 686₁₀</pre>
                        <h4>Chuyển từ Thập phân sang hệ bất kỳ (Phần nguyên)</h4>
                        <p>Quy tắc: <span class="highlight">Chia liên tiếp</span> cho cơ số mới, lấy phần dư theo thứ tự ngược lại.</p>
                        <pre><strong>Ví dụ: 35₁₀ sang nhị phân (chia cho 2)</strong>
35 / 2 = 17 dư 1; 17 / 2 = 8 dư 1; 8 / 2 = 4 dư 0; 4 / 2 = 2 dư 0; 2 / 2 = 1 dư 0; 1 / 2 = 0 dư 1.
Kết quả (đọc ngược): (100011)₂</pre>
                        <h4>Chuyển đổi nhanh giữa Binary ↔ Octal ↔ Hexadecimal</h4>
                        <p>Quy tắc: Gom nhóm <span class="highlight">3 bits</span> cho Octal và <span class="highlight">4 bits</span> cho Hexadecimal.</p>
                        <pre><strong>Ví dụ: (10011100010)₂ sang Hexadecimal (gom nhóm 4)</strong>
→ 0100 1110 0010 → (4E2)₁₆</pre>
                    `,
                    en: `
                        <h2>Chapter 2: Number Systems</h2>
                        <h3>1. Positional Number Systems</h3>
                        <ul>
                            <li><strong>Concept:</strong> The value of a digit depends on its <span class="highlight">position</span> within the number string. Each position has a place value, which is a power of the base (radix).</li>
                            <li><strong>Main Systems:</strong>
                                <ul>
                                    <li><strong>Decimal (Base 10):</strong> Uses 10 symbols {0, 1, ..., 9}.</li>
                                    <li><strong>Binary (Base 2):</strong> Uses 2 symbols {0, 1}. This is the <span class="highlight">natural language of computers</span>.</li>
                                    <li><strong>Octal (Base 8):</strong> Uses 8 symbols {0, 1, ..., 7}.</li>
                                    <li><strong>Hexadecimal (Base 16):</strong> Uses 16 symbols {0, 1, ..., 9, A, B, C, D, E, F}.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Conversion Examples</h3>
                        <h4>Convert from Any Base to Decimal</h4>
                        <p>Rule: Multiply each digit by (base)<sup>position</sup> and sum the results.</p>
                        <pre><strong>Example 1: (11001)₂ to decimal</strong>
N = 1×2⁴ + 1×2³ + 0×2² + 0×2¹ + 1×2⁰ = 25₁₀
<strong>Example 2: (2AE)₁₆ to decimal (A=10, E=14)</strong>
N = 2×16² + 10×16¹ + 14×16⁰ = 686₁₀</pre>
                        <h4>Convert from Decimal to Any Base (Integer Part)</h4>
                        <p>Rule: <span class="highlight">Repeatedly divide</span> by the new base, take the remainders in reverse order.</p>
                        <pre><strong>Example: 35₁₀ to binary (divide by 2)</strong>
35 / 2 = 17 rem 1; 17 / 2 = 8 rem 1; 8 / 2 = 4 rem 0; 4 / 2 = 2 rem 0; 2 / 2 = 1 rem 0; 1 / 2 = 0 rem 1.
Result (read backwards): (100011)₂</pre>
                        <h4>Quick Conversion between Binary ↔ Octal ↔ Hexadecimal</h4>
                        <p>Rule: Group <span class="highlight">3 bits</span> for Octal and <span class="highlight">4 bits</span> for Hexadecimal.</p>
                        <pre><strong>Example: (10011100010)₂ to Hexadecimal (group of 4)</strong>
→ 0100 1110 0010 → (4E2)₁₆</pre>
                    `
                },
                questions: [
                    { q: { vi: "Trong một hệ số vị (positional number system), radix (base) là gì?", en: "In a positional number system, what is the radix (base)?" }, o: [{ vi: "Giá trị lớn nhất có thể biểu diễn bằng một chữ số.", en: "The maximum value representable by a single digit." }, { vi: "Số chữ số tối đa cho biểu diễn số nguyên.", en: "The maximum number of digits for an integer representation." }, { vi: "Số kí hiệu (symbols) trong hệ (số lượng chữ số khác nhau).", en: "The number of symbols in the system (the count of different digits)." }, { vi: "Tổng các giá trị chữ số trong một số.", en: "The sum of the digit values in a number." }], a: 2, explanation: { vi: "Base (cơ số hay radix) định nghĩa tổng số ký hiệu duy nhất được sử dụng trong hệ đếm.", en: "The base (or radix) defines the total number of unique symbols used in the number system." } },
                    { q: { vi: "Hệ thập phân (decimal) có base bằng bao nhiêu?", en: "What is the base of the decimal system?" }, o: [{ vi: "2", en: "2" }, { vi: "8", en: "8" }, { vi: "10", en: "10" }, { vi: "16", en: "16" }], a: 2, explanation: { vi: "Hệ thập phân sử dụng 10 chữ số (0-9), do đó cơ số của nó là 10.", en: "The decimal system uses 10 digits (0-9), so its base is 10." } },
                    { q: { vi: "Trong hệ nhị phân (binary), mỗi chữ số gọi là gì?", en: "In the binary system, what is each digit called?" }, o: [{ vi: "nibble", en: "nibble" }, { vi: "digit", en: "digit" }, { vi: "byte", en: "byte" }, { vi: "bit", en: "bit" }], a: 3, explanation: { vi: "Mỗi chữ số trong hệ nhị phân được gọi là bit, viết tắt của 'binary digit'.", en: "Each digit in the binary system is called a bit, short for 'binary digit'." } },
                    { q: { vi: "Ký tự 'B' trong hệ thập lục phân (hex) tương đương với giá trị thập phân nào?", en: "The character 'B' in the hexadecimal system is equivalent to which decimal value?" }, o: [{ vi: "10", en: "10" }, { vi: "11", en: "11" }, { vi: "12", en: "12" }, { vi: "13", en: "13" }], a: 1, explanation: { vi: "Trong hệ thập lục phân, A=10, B=11, C=12, D=13, E=14, F=15.", en: "In hexadecimal, A=10, B=11, C=12, D=13, E=14, F=15." } },
                    { q: { vi: "Giá trị thập phân của (11001)₂ là:", en: "The decimal value of (11001)₂ is:" }, o: [{ vi: "25", en: "25" }, { vi: "27", en: "27" }, { vi: "29", en: "29" }, { vi: "31", en: "31" }], a: 0, explanation: { vi: "1*16 + 1*8 + 0*4 + 0*2 + 1*1 = 16+8+1 = 25.", en: "1*16 + 1*8 + 0*4 + 0*2 + 1*1 = 16+8+1 = 25." } },
                    { q: { vi: "Giá trị lớn nhất có thể biểu diễn bằng một số nguyên không dấu (unsigned) với 5 bit là:", en: "The largest value that can be represented by a 5-bit unsigned integer is:" }, o: [{ vi: "16", en: "16" }, { vi: "31", en: "31" }, { vi: "63", en: "63" }, { vi: "127", en: "127" }], a: 1, explanation: { vi: "Giá trị lớn nhất của số không dấu n-bit là 2^n - 1. Với n=5, giá trị là 2^5 - 1 = 31.", en: "The largest value of an n-bit unsigned integer is 2^n - 1. For n=5, the value is 2^5 - 1 = 31." } },
                    { q: { vi: "Số bit tối thiểu cần để biểu diễn số thập phân 234 là:", en: "The minimum number of bits needed to represent the decimal number 234 is:" }, o: [{ vi: "7", en: "7" }, { vi: "8", en: "8" }, { vi: "9", en: "9" }, { vi: "10", en: "10" }], a: 1, explanation: { vi: "2^7 = 128 (không đủ), 2^8 = 256 (đủ). Do đó, cần 8 bit.", en: "2^7 = 128 (not enough), 2^8 = 256 (enough). Therefore, 8 bits are needed." } },
                    { q: { vi: "(2AE)₁₆ bằng bao nhiêu trong hệ thập phân?", en: "(2AE)₁₆ is equal to what in decimal?" }, o: [{ vi: "546", en: "546" }, { vi: "686", en: "686" }, { vi: "742", en: "742" }, { vi: "814", en: "814" }], a: 1, explanation: { vi: "2*16^2 + 10*16^1 + 14*16^0 = 512 + 160 + 14 = 686.", en: "2*16^2 + 10*16^1 + 14*16^0 = 512 + 160 + 14 = 686." } },
                    { q: { vi: "(1256)₈ bằng bao nhiêu trong hệ thập phân?", en: "(1256)₈ is equal to what in decimal?" }, o: [{ vi: "342", en: "342" }, { vi: "512", en: "512" }, { vi: "686", en: "686" }, { vi: "732", en: "732" }], a: 2, explanation: { vi: "1*8^3 + 2*8^2 + 5*8^1 + 6*8^0 = 512 + 128 + 40 + 6 = 686.", en: "1*8^3 + 2*8^2 + 5*8^1 + 6*8^0 = 512 + 128 + 40 + 6 = 686." } },
                    { q: { vi: "Một chữ số thập lục phân (hex digit) tương ứng với bao nhiêu bit?", en: "One hexadecimal digit corresponds to how many bits?" }, o: [{ vi: "2 bit", en: "2 bits" }, { vi: "3 bit", en: "3 bits" }, { vi: "4 bit", en: "4 bits" }, { vi: "8 bit", en: "8 bits" }], a: 2, explanation: { vi: "Vì 16 = 2^4, mỗi chữ số thập lục phân biểu diễn một nhóm 4 bit.", en: "Because 16 = 2^4, each hexadecimal digit represents a group of 4 bits." } },
                    { q: { vi: "Chuyển (01101)₂ sang hệ bát phân (octal) sẽ là:", en: "Converting (01101)₂ to octal would be:" }, o: [{ vi: "(13)₈", en: "(13)₈" }, { vi: "(15)₈", en: "(15)₈" }, { vi: "(11)₈", en: "(11)₈" }, { vi: "(7)₈", en: "(7)₈" }], a: 1, explanation: { vi: "Gom nhóm 3 bit từ phải sang: 01 101. Thêm 0 vào bên trái: 001 101. 001₂ = 1, 101₂ = 5. Kết quả: (15)₈.", en: "Group 3 bits from right to left: 01 101. Pad with a leading zero: 001 101. 001₂ = 1, 101₂ = 5. Result: (15)₈." } },
                    { q: { vi: "(1011000)₂ trong hệ thập phân là:", en: "Converting (1011000)₂ to decimal is:" }, o: [{ vi: "72", en: "72" }, { vi: "80", en: "80" }, { vi: "88", en: "88" }, { vi: "96", en: "96" }], a: 2, explanation: { vi: "64 + 16 + 8 = 88.", en: "64 + 16 + 8 = 88." } },
                    { q: { vi: "(011110.01)₂ = ? (thập phân)", en: "(011110.01)₂ = ? (decimal)" }, o: [{ vi: "30.125", en: "30.125" }, { vi: "30.25", en: "30.25" }, { vi: "30.5", en: "30.5" }, { vi: "30.75", en: "30.75" }], a: 1, explanation: { vi: "Phần nguyên: 16+8+4+2=30. Phần thập phân: 0/2 + 1/4 = 0.25. Kết quả: 30.25.", en: "Integer part: 16+8+4+2=30. Fractional part: 0/2 + 1/4 = 0.25. Result: 30.25." } },
                    { q: { vi: "(111111.111)₂ = ? (thập phân)", en: "(111111.111)₂ = ? (decimal)" }, o: [{ vi: "63.5", en: "63.5" }, { vi: "63.75", en: "63.75" }, { vi: "63.875", en: "63.875" }, { vi: "64.0", en: "64.0" }], a: 2, explanation: { vi: "Phần nguyên: 63. Phần thập phân: 1/2 + 1/4 + 1/8 = 0.5 + 0.25 + 0.125 = 0.875. Kết quả: 63.875.", en: "Integer part: 63. Fractional part: 1/2 + 1/4 + 1/8 = 0.5 + 0.25 + 0.125 = 0.875. Result: 63.875." } },
                    { q: { vi: "Phương pháp chuyển phần nguyên của số thập phân sang hệ khác là gì?", en: "What is the method for converting the integer part of a decimal number to another base?" }, o: [{ vi: "Phép nhân lặp", en: "Repetitive multiplication" }, { vi: "Phép chia lặp", en: "Repetitive division" }, { vi: "Thay thế bằng bảng giá trị", en: "Substitution using a value table" }, { vi: "Sắp nhóm theo 3 hoặc 4 bit", en: "Grouping by 3 or 4 bits" }], a: 1, explanation: { vi: "Để chuyển đổi phần nguyên, ta liên tục chia số đó cho cơ số mới và thu thập các số dư theo thứ tự ngược lại.", en: "To convert the integer part, we repeatedly divide the number by the new base and collect the remainders in reverse order." } },
                    { q: { vi: "Phương pháp chuyển phần phân số (fractional part) của số thập phân sang hệ khác là gì?", en: "What is the method for converting the fractional part of a decimal number to another base?" }, o: [{ vi: "Phép nhân lặp", en: "Repetitive multiplication" }, { vi: "Phép chia lặp", en: "Repetitive division" }, { vi: "Dùng logarit", en: "Using logarithms" }, { vi: "Dùng phép chia dư", en: "Using modulus" }], a: 0, explanation: { vi: "Để chuyển đổi phần thập phân, ta liên tục nhân phần thập phân đó với cơ số mới và thu thập các phần nguyên của kết quả.", en: "To convert the fractional part, we repeatedly multiply it by the new base and collect the integer parts of the results." } },
                    { q: { vi: "(101.11)₂ tương đương bao nhiêu trong hệ thập phân?", en: "(101.11)₂ is equivalent to what in decimal?" }, o: [{ vi: "5.5", en: "5.5" }, { vi: "5.75", en: "5.75" }, { vi: "6.25", en: "6.25" }, { vi: "6.5", en: "6.5" }], a: 1, explanation: { vi: "Phần nguyên: 4+1=5. Phần thập phân: 1/2 + 1/4 = 0.75. Kết quả: 5.75.", en: "Integer part: 4+1=5. Fractional part: 1/2 + 1/4 = 0.75. Result: 5.75." } },
                    { q: { vi: "Số 35 (thập phân) bằng gì trong hệ nhị phân?", en: "What is the decimal number 35 in binary?" }, o: [{ vi: "100011", en: "100011" }, { vi: "100111", en: "100111" }, { vi: "101011", en: "101011" }, { vi: "110011", en: "110011" }], a: 0, explanation: { vi: "35 chia 2 được 17 dư 1, 17 chia 2 được 8 dư 1, v.v. Đọc ngược các số dư ta được 100011.", en: "35 divided by 2 is 17 remainder 1, 17 divided by 2 is 8 remainder 1, etc. Reading the remainders backwards gives 100011." } },
                    { q: { vi: "Số 126 (thập phân) bằng bao nhiêu trong hệ thập lục phân?", en: "What is the decimal number 126 in hexadecimal?" }, o: [{ vi: "7C", en: "7C" }, { vi: "7D", en: "7D" }, { vi: "7E", en: "7E" }, { vi: "7F", en: "7F" }], a: 2, explanation: { vi: "126 chia 16 được 7 dư 14. 14 trong hệ thập lục phân là E. Kết quả: 7E.", en: "126 divided by 16 is 7 with a remainder of 14. 14 in hexadecimal is E. Result: 7E." } },
                    { q: { vi: "0.625 (thập phân) chuyển sang nhị phân phần phân là:", en: "Converting 0.625 (decimal) to a binary fraction is:" }, o: [{ vi: "0.011", en: "0.011" }, { vi: "0.101", en: "0.101" }, { vi: "0.110", en: "0.110" }, { vi: "0.1001", en: "0.1001" }], a: 1, explanation: { vi: "0.625*2=1.25 (lấy 1), 0.25*2=0.5 (lấy 0), 0.5*2=1.0 (lấy 1). Kết quả: 0.101.", en: "0.625*2=1.25 (take 1), 0.25*2=0.5 (take 0), 0.5*2=1.0 (take 1). Result: 0.101." } },
                    { q: { vi: "Số chữ số hexa cần thiết để biểu diễn giá trị thập phân 234 là:", en: "The number of hex digits needed to represent the decimal value 234 is:" }, o: [{ vi: "1", en: "1" }, { vi: "2", en: "2" }, { vi: "3", en: "3" }, { vi: "4", en: "4" }], a: 1, explanation: { vi: "234 chia 16 được 14 (E) dư 10 (A). Kết quả là EA, cần 2 chữ số.", en: "234 divided by 16 is 14 (E) with a remainder of 10 (A). The result is EA, which requires 2 digits." } },
                    { q: { vi: "Giá trị thập phân của địa chỉ dotted-decimal 17.234.34.14 là:", en: "The decimal value of the dotted-decimal address 17.234.34.14 is:" }, o: [{ vi: "30,055,6814", en: "30,055,6814" }, { vi: "300,556,814", en: "300,556,814" }, { vi: "3,005,568,14", en: "3,005,568,14" }, { vi: "30,055,681", en: "30,055,681" }], a: 1, explanation: { vi: "Tính: 17 * 256^3 + 234 * 256^2 + 34 * 256^1 + 14 * 256^0 = 300,556,814.", en: "Calculate: 17 * 256^3 + 234 * 256^2 + 34 * 256^1 + 14 * 256^0 = 300,556,814." } },
                    { q: { vi: "(AB2)₁₆ bằng bao nhiêu (thập phân)?", en: "(AB2)₁₆ is equal to what (decimal)?" }, o: [{ vi: "2738", en: "2738" }, { vi: "2580", en: "2580" }, { vi: "2802", en: "2802" }, { vi: "2914", en: "2914" }], a: 0, explanation: { vi: "10*16^2 + 11*16^1 + 2*16^0 = 2560 + 176 + 2 = 2738.", en: "10*16^2 + 11*16^1 + 2*16^0 = 2560 + 176 + 2 = 2738." } },
                    { q: { vi: "(123)₁₆ = ? (thập phân)", en: "(123)₁₆ = ? (decimal)" }, o: [{ vi: "291", en: "291" }, { vi: "274", en: "274" }, { vi: "315", en: "315" }, { vi: "299", en: "299" }], a: 0, explanation: { vi: "1*16^2 + 2*16^1 + 3*16^0 = 256 + 32 + 3 = 291.", en: "1*16^2 + 2*16^1 + 3*16^0 = 256 + 32 + 3 = 291." } },
                    { q: { vi: "(ABB)₁₆ = ? (thập phân)", en: "(ABB)₁₆ = ? (decimal)" }, o: [{ vi: "2747", en: "2747" }, { vi: "2738", en: "2738" }, { vi: "2779", en: "2779" }, { vi: "2811", en: "2811" }], a: 0, explanation: { vi: "10*16^2 + 11*16^1 + 11*16^0 = 2560 + 176 + 11 = 2747.", en: "10*16^2 + 11*16^1 + 11*16^0 = 2560 + 176 + 11 = 2747." } },
                    { q: { vi: "(35E.E1)₁₆ ≈ ? (thập phân, làm tròn thích hợp)", en: "(35E.E1)₁₆ ≈ ? (decimal, with appropriate rounding)" }, o: [{ vi: "862.75", en: "862.75" }, { vi: "862.875", en: "862.875" }, { vi: "862.87890625", en: "862.87890625" }, { vi: "862.9", en: "862.9" }], a: 2, explanation: { vi: "Phần nguyên: 3*256 + 5*16 + 14 = 862. Phần thập phân: 14/16 + 1/256 = 0.875 + 0.00390625 = 0.87890625.", en: "Integer part: 3*256 + 5*16 + 14 = 862. Fractional part: 14/16 + 1/256 = 0.875 + 0.00390625 = 0.87890625." } },
                    { q: { vi: "(237)₈ = ? (thập phân)", en: "(237)₈ = ? (decimal)" }, o: [{ vi: "159", en: "159" }, { vi: "175", en: "175" }, { vi: "191", en: "191" }, { vi: "143", en: "143" }], a: 0, explanation: { vi: "2*8^2 + 3*8^1 + 7*8^0 = 128 + 24 + 7 = 159.", en: "2*8^2 + 3*8^1 + 7*8^0 = 128 + 24 + 7 = 159." } },
                    { q: { vi: "(2731)₈ = ? (thập phân)", en: "(2731)₈ = ? (decimal)" }, o: [{ vi: "1379", en: "1379" }, { vi: "1497", en: "1497" }, { vi: "1501", en: "1501" }, { vi: "1605", en: "1605" }], a: 1, explanation: { vi: "2*8^3 + 7*8^2 + 3*8^1 + 1*8^0 = 1024 + 448 + 24 + 1 = 1497.", en: "2*8^3 + 7*8^2 + 3*8^1 + 1*8^0 = 1024 + 448 + 24 + 1 = 1497." } },
                    { q: { vi: "(617.7)₈ = ? (thập phân)", en: "(617.7)₈ = ? (decimal)" }, o: [{ vi: "399.5", en: "399.5" }, { vi: "399.75", en: "399.75" }, { vi: "399.875", en: "399.875" }, { vi: "400.0", en: "400.0" }], a: 2, explanation: { vi: "Phần nguyên: 6*64 + 1*8 + 7 = 399. Phần thập phân: 7/8 = 0.875. Kết quả: 399.875.", en: "Integer part: 6*64 + 1*8 + 7 = 399. Fractional part: 7/8 = 0.875. Result: 399.875." } },
                    { q: { vi: "(21.11)₈ = ? (thập phân)", en: "(21.11)₈ = ? (decimal)" }, o: [{ vi: "17.140625", en: "17.140625" }, { vi: "17.125", en: "17.125" }, { vi: "17.25", en: "17.25" }, { vi: "17.0625", en: "17.0625" }], a: 0, explanation: { vi: "Phần nguyên: 2*8+1=17. Phần thập phân: 1/8 + 1/64 = 0.125 + 0.015625 = 0.140625.", en: "Integer part: 2*8+1=17. Fractional part: 1/8 + 1/64 = 0.125 + 0.015625 = 0.140625." } },
                    { q: { vi: "1234 (thập phân) sang nhị phân là:", en: "1234 (decimal) to binary is:" }, o: [{ vi: "10011010010", en: "10011010010" }, { vi: "10011000110", en: "10011000110" }, { vi: "10011101010", en: "10011101010" }, { vi: "10011100100", en: "10011100100" }], a: 0, explanation: { vi: "Chuyển đổi bằng cách chia lặp cho 2 và lấy các số dư theo thứ tự ngược lại.", en: "Convert by repeatedly dividing by 2 and taking the remainders in reverse order." } },
                    { q: { vi: "1156 (thập phân) sang bát phân (octal) là:", en: "1156 (decimal) to octal is:" }, o: [{ vi: "2144", en: "2144" }, { vi: "2204", en: "2204" }, { vi: "2244", en: "2244" }, { vi: "2104", en: "2104" }], a: 1, explanation: { vi: "1156/8=144 dư 4, 144/8=18 dư 0, 18/8=2 dư 2, 2/8=0 dư 2. Đọc ngược: 2204.", en: "1156/8=144 R 4, 144/8=18 R 0, 18/8=2 R 2, 2/8=0 R 2. Read backwards: 2204." } },
                    { q: { vi: "567 (thập phân) sang hexa là:", en: "567 (decimal) to hex is:" }, o: [{ vi: "237", en: "237" }, { vi: "245", en: "245" }, { vi: "2A7", en: "2A7" }, { vi: "22F", en: "22F" }], a: 0, explanation: { vi: "567/16=35 dư 7, 35/16=2 dư 3, 2/16=0 dư 2. Đọc ngược: 237.", en: "567/16=35 R 7, 35/16=2 R 3, 2/16=0 R 2. Read backwards: 237." } },
                    { q: { vi: "Chuyển (1011000)₂ sang hex được:", en: "Convert (1011000)₂ to hex:" }, o: [{ vi: "5C", en: "5C" }, { vi: "58", en: "58" }, { vi: "50", en: "50" }, { vi: "1B", en: "1B" }], a: 1, explanation: { vi: "Gom nhóm 4 bit từ phải qua: 0101 1000. 0101 = 5, 1000 = 8. Kết quả: 58.", en: "Group into 4 bits from the right: 0101 1000. 0101 = 5, 1000 = 8. Result: 58." } },
                    { q: { vi: "Chuyển (1011000)₂ sang octal được:", en: "Convert (1011000)₂ to octal:" }, o: [{ vi: "130", en: "130" }, { vi: "128", en: "128" }, { vi: "150", en: "150" }, { vi: "160", en: "160" }], a: 0, explanation: { vi: "Gom nhóm 3 bit từ phải qua: 001 011 000. 001=1, 011=3, 000=0. Kết quả: 130.", en: "Group into 3 bits from the right: 001 011 000. 001=1, 011=3, 000=0. Result: 130." } },
                    { q: { vi: "Trong chuyển đổi nhị phân ↔ octal, một chữ số octal tương ứng với bao nhiêu bit?", en: "In binary ↔ octal conversion, one octal digit corresponds to how many bits?" }, o: [{ vi: "1 bit", en: "1 bit" }, { vi: "2 bit", en: "2 bits" }, { vi: "3 bit", en: "3 bits" }, { vi: "4 bit", en: "4 bits" }], a: 2, explanation: { vi: "Vì 8 = 2^3, mỗi 3 bit nhị phân tương ứng với một chữ số bát phân.", en: "Because 8 = 2^3, each 3 binary bits correspond to one octal digit." } },
                    { q: { vi: "Trong chuyển đổi nhị phân ↔ hex, một chữ số hex tương ứng với bao nhiêu bit?", en: "In binary ↔ hex conversion, one hex digit corresponds to how many bits?" }, o: [{ vi: "2 bit", en: "2 bits" }, { vi: "3 bit", en: "3 bits" }, { vi: "4 bit", en: "4 bits" }, { vi: "8 bit", en: "8 bits" }], a: 2, explanation: { vi: "Vì 16 = 2^4, mỗi 4 bit nhị phân tương ứng với một chữ số thập lục phân.", en: "Because 16 = 2^4, each 4 binary bits correspond to one hexadecimal digit." } },
                    { q: { vi: "Số nguyên lớn nhất có thể biểu diễn với 6 chữ số ở hệ thập phân là:", en: "The largest integer representable with 6 decimal digits is:" }, o: [{ vi: "99999", en: "99999" }, { vi: "999999", en: "999999" }, { vi: "1000000", en: "1000000" }, { vi: "9999", en: "9999" }], a: 1, explanation: { vi: "Số lớn nhất có 6 chữ số là 999,999. Công thức là 10^6 - 1.", en: "The largest 6-digit number is 999,999. The formula is 10^6 - 1." } },
                    { q: { vi: "Số lớn nhất có thể biểu diễn với 5 chữ số ở hệ bát phân (octal) là:", en: "The largest number representable with 5 octal digits is:" }, o: [{ vi: "32766", en: "32766" }, { vi: "32767", en: "32767" }, { vi: "32768", en: "32768" }, { vi: "32769", en: "32769" }], a: 1, explanation: { vi: "Giá trị lớn nhất là 8^5 - 1 = 32768 - 1 = 32767.", en: "The largest value is 8^5 - 1 = 32768 - 1 = 32767." } },
                    { q: { vi: "Số bit tối thiểu cần để lưu mọi số < 1000 là:", en: "The minimum number of bits needed to store any number < 1000 is:" }, o: [{ vi: "9", en: "9" }, { vi: "10", en: "10" }, { vi: "11", en: "11" }, { vi: "12", en: "12" }], a: 1, explanation: { vi: "Cần tìm n sao cho 2^n >= 1000. 2^9=512, 2^10=1024. Vậy cần 10 bit.", en: "We need to find n such that 2^n >= 1000. 2^9=512, 2^10=1024. So 10 bits are needed." } },
                    { q: { vi: "Số bit tối thiểu để lưu mọi số < 100000 là:", en: "The minimum number of bits to store any number < 100000 is:" }, o: [{ vi: "16", en: "16" }, { vi: "17", en: "17" }, { vi: "18", en: "18" }, { vi: "19", en: "19" }], a: 1, explanation: { vi: "2^16 = 65536, 2^17 = 131072. Cần 17 bit.", en: "2^16 = 65536, 2^17 = 131072. 17 bits are needed." } },
                    { q: { vi: "Số bit tối thiểu để lưu mọi số < 64 là:", en: "The minimum number of bits to store any number < 64 is:" }, o: [{ vi: "5", en: "5" }, { vi: "6", en: "6" }, { vi: "7", en: "7" }, { vi: "8", en: "8" }], a: 1, explanation: { vi: "Cần 6 bit để biểu diễn các số từ 0 đến 63 (2^6 = 64 giá trị).", en: "6 bits are needed to represent numbers from 0 to 63 (2^6 = 64 values)." } },
                    { q: { vi: "Số bit tối thiểu để lưu mọi số < 256 là:", en: "The minimum number of bits to store any number < 256 is:" }, o: [{ vi: "7", en: "7" }, { vi: "8", en: "8" }, { vi: "9", en: "9" }, { vi: "10", en: "10" }], a: 1, explanation: { vi: "Cần 8 bit để biểu diễn các số từ 0 đến 255 (2^8 = 256 giá trị).", en: "8 bits are needed to represent numbers from 0 to 255 (2^8 = 256 values)." } },
                    { q: { vi: "Chuyển 0.375 (thập phân) sang nhị phân (phần phân) là:", en: "Convert 0.375 (decimal) to a binary fraction:" }, o: [{ vi: "0.011", en: "0.011" }, { vi: "0.101", en: "0.101" }, { vi: "0.110", en: "0.110" }, { vi: "0.0110", en: "0.0110" }], a: 0, explanation: { vi: "0.375*2=0.75(0), 0.75*2=1.5(1), 0.5*2=1.0(1). Kết quả: 0.011.", en: "0.375*2=0.75(0), 0.75*2=1.5(1), 0.5*2=1.0(1). Result: 0.011." } },
                    { q: { vi: "Số thập phân 7.1875 sang nhị phân là:", en: "The decimal number 7.1875 to binary is:" }, o: [{ vi: "111.0011", en: "111.0011" }, { vi: "111.001", en: "111.001" }, { vi: "111.00101", en: "111.00101" }, { vi: "111.0010", en: "111.0010" }], a: 0, explanation: { vi: "Phần nguyên: 7=111. Phần thập phân: 0.1875*2=0.375(0), 0.375*2=0.75(0), 0.75*2=1.5(1), 0.5*2=1.0(1) -> .0011. Kết quả: 111.0011.", en: "Integer part: 7=111. Fractional part: 0.1875*2=0.375(0), 0.375*2=0.75(0), 0.75*2=1.5(1), 0.5*2=1.0(1) -> .0011. Result: 111.0011." } },
                    { q: { vi: "Theo công thức trong chương, số chữ số K cần trong base b để biểu diễn số N là:", en: "According to the formula in the chapter, the number of digits K needed in base b to represent the number N is:" }, o: [{ vi: "K = ⌊log_b N⌋", en: "K = ⌊log_b N⌋" }, { vi: "K = ⌈log_b N⌉", en: "K = ⌈log_b N⌉" }, { vi: "K = log_b (N)", en: "K = log_b (N)" }, { vi: "K = N * log_b", en: "K = N * log_b" }], a: 1, explanation: { vi: "Công thức sử dụng hàm ceiling (làm tròn lên) của logarit cơ số b của N.", en: "The formula uses the ceiling function of the base-b logarithm of N." } },
                    { q: { vi: "Giá trị chữ số của Roman 'XIX' là:", en: "The value of the Roman numeral 'XIX' is:" }, o: [{ vi: "16", en: "16" }, { vi: "18", en: "18" }, { vi: "19", en: "19" }, { vi: "20", en: "20" }], a: 2, explanation: { vi: "X = 10, IX = 9. 10 + 9 = 19.", en: "X = 10, IX = 9. 10 + 9 = 19." } },
                    { q: { vi: "Roman numeral 'MMVII' tương đương với:", en: "The Roman numeral 'MMVII' is equivalent to:" }, o: [{ vi: "2005", en: "2005" }, { vi: "2006", en: "2006" }, { vi: "2007", en: "2007" }, { vi: "2010", en: "2010" }], a: 2, explanation: { vi: "M=1000, V=5, I=1. 1000+1000+5+1+1 = 2007.", en: "M=1000, V=5, I=1. 1000+1000+5+1+1 = 2007." } },
                    { q: { vi: "Việc thiếu ký số '0' trong một hệ (như một số hệ cổ) gây ra vấn đề gì chủ yếu?", en: "The lack of a '0' digit in a number system (like some ancient ones) primarily causes what issue?" }, o: [{ vi: "Không thể cộng hai số", en: "Cannot add two numbers" }, { vi: "Không thể biểu diễn số âm", en: "Cannot represent negative numbers" }, { vi: "Không phân biệt vị trí (place value) dẫn tới mơ hồ về trị giá các chữ số", en: "Ambiguity in place value, leading to confusion about digit values" }, { vi: "Không thể nhân hai số", en: "Cannot multiply two numbers" }], a: 2, explanation: { vi: "Số 0 đóng vai trò giữ chỗ. Nếu không có nó, rất khó để phân biệt giữa 25, 205, và 250.", en: "The number 0 acts as a placeholder. Without it, it's hard to distinguish between 25, 205, and 250." } },
                    { q: { vi: "Trong số các hệ sau, hệ nào là không vị trí (nonpositional)?", en: "Among the following systems, which one is nonpositional?" }, o: [{ vi: "Decimal", en: "Decimal" }, { vi: "Binary", en: "Binary" }, { vi: "Roman numerals", en: "Roman numerals" }, { vi: "Hexadecimal", en: "Hexadecimal" }], a: 2, explanation: { vi: "Trong hệ La Mã, giá trị của một ký hiệu (X luôn là 10) không phụ thuộc hoàn toàn vào vị trí của nó, mà phụ thuộc vào các quy tắc cộng trừ với các ký hiệu bên cạnh.", en: "In the Roman system, a symbol's value (X is always 10) doesn't strictly depend on its position, but on addition/subtraction rules with adjacent symbols." } }
                ]
            },
            chapter3: {
                theory: {
                    vi: `
                        <h2>Chương 3: Lưu trữ Dữ liệu</h2>
                        <h3>1. Các kiểu dữ liệu cơ bản</h3>
                        <ul>
                            <li>Máy tính xử lý nhiều loại dữ liệu: Số (Numbers), Văn bản (Text), Âm thanh (Audio), Hình ảnh (Images), Video.</li>
                            <li>Tất cả các loại dữ liệu này đều được chuyển đổi thành một dạng duy nhất để lưu trữ: <span class="highlight">chuỗi bit (bit pattern)</span>.</li>
                        </ul>
                        <h3>2. Lưu trữ số nguyên (Storing Integers)</h3>
                        <ul>
                            <li><strong>Số nguyên không dấu (Unsigned Integers):</strong>
                                <ul><li>Chỉ biểu diễn số không âm (0 và các số dương). Một chuỗi n bit có thể biểu diễn các giá trị từ 0 đến 2ⁿ-1.</li></ul>
                            </li>
                            <li><strong>Số nguyên có dấu (Signed Integers):</strong>
                                <ul>
                                    <li><strong>Sign-and-Magnitude:</strong> Bit ngoài cùng bên trái dùng cho dấu (0 là +, 1 là -), các bit còn lại biểu diễn độ lớn. Nhược điểm: có hai giá trị zero (+0 và -0).</li>
                                    <li><span class="highlight">Two's Complement (Bù 2):</span> Phương pháp chuẩn hiện nay.
                                        <ul>
                                            <li>Số dương được biểu diễn như số không dấu (với bit dấu là 0).</li>
                                            <li>Số âm được biểu diễn bằng cách lấy bù 2 của số dương tương ứng. (Cách lấy bù 2: Đảo tất cả các bit rồi cộng 1).</li>
                                            <li>Ưu điểm: Chỉ có một giá trị zero, phép trừ có thể thực hiện bằng phép cộng, giúp đơn giản hóa mạch logic.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                             <li><strong>Tràn số (Overflow):</strong> Xảy ra khi kết quả của một phép toán vượt ra ngoài phạm vi biểu diễn cho phép. Ví dụ: cộng hai số 8-bit dương lớn ra kết quả có bit dấu là 1 (số âm).</li>
                        </ul>
                        <h3>3. Lưu trữ số thực (Storing Reals)</h3>
                        <ul>
                            <li>
                                <strong>Floating-Point (Dấu phẩy động) - Chuẩn IEEE 754:</strong>
                                <ul>
                                    <li>Biểu diễn một số dưới dạng khoa học: (Dấu) × (Định trị) × (Cơ số)<sup>Số mũ</sup>.</li>
                                    <li>Một số thực được lưu trữ thành 3 phần:
                                        <ol>
                                            <li><strong>Sign (S):</strong> 1 bit (0 cho dương, 1 cho âm).</li>
                                            <li><strong>Exponent (E):</strong> Số mũ, được lưu trữ bằng phương pháp <span class="highlight">Excess representation</span> (cộng một số bias để luôn là số dương).</li>
                                            <li><strong>Mantissa (M):</strong> Phần định trị (phần sau dấu chấm của số đã được chuẩn hóa).</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    `,
                    en: `
                        <h2>Chapter 3: Data Storage</h2>
                        <h3>1. Basic Data Types</h3>
                        <ul>
                            <li>Computers process various data types: Numbers, Text, Audio, Images, Video.</li>
                            <li>All these data types are converted into a single uniform representation for storage: the <span class="highlight">bit pattern</span>.</li>
                        </ul>
                        <h3>2. Storing Integers</h3>
                        <ul>
                            <li><strong>Unsigned Integers:</strong>
                                <ul><li>Represent only non-negative numbers (0 and positives). An n-bit pattern can represent values from 0 to 2ⁿ-1.</li></ul>
                            </li>
                            <li><strong>Signed Integers:</strong>
                                <ul>
                                    <li><strong>Sign-and-Magnitude:</strong> The leftmost bit is for the sign (0 for +, 1 for -), the rest represent the magnitude. Drawback: has two representations of zero (+0 and -0).</li>
                                    <li><span class="highlight">Two's Complement:</span> The standard method today.
                                        <ul>
                                            <li>Positive numbers are represented like unsigned integers (with a sign bit of 0).</li>
                                            <li>Negative numbers are represented by taking the two's complement of the corresponding positive number. (How to take two's complement: Invert all bits then add 1).</li>
                                            <li>Advantages: Only one representation of zero, subtraction can be performed by addition, simplifying logic circuits.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Overflow:</strong> Occurs when the result of an operation falls outside the representable range. E.g., adding two large positive 8-bit numbers results in a number with a sign bit of 1 (negative).</li>
                        </ul>
                        <h3>3. Storing Reals</h3>
                        <ul>
                            <li>
                                <strong>Floating-Point - IEEE 754 Standard:</strong>
                                <ul>
                                    <li>Represents a number in scientific notation: (Sign) × (Mantissa) × (Base)<sup>Exponent</sup>.</li>
                                    <li>A real number is stored in 3 parts:
                                        <ol>
                                            <li><strong>Sign (S):</strong> 1 bit (0 for positive, 1 for negative).</li>
                                            <li><strong>Exponent (E):</strong> Stored using <span class="highlight">Excess representation</span> (a bias is added to make it always positive).</li>
                                            <li><strong>Mantissa (M):</strong> The fractional part of the normalized number.</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    `
                },
                questions: [
                    { q: { vi: "Bit là gì trong máy tính?", en: "What is a bit in a computer?" }, o: [{ vi: "Một ký tự chữ cái.", en: "An alphabetic character." }, { vi: "Một đơn vị lưu trữ có giá trị 0 hoặc 1.", en: "A storage unit with a value of 0 or 1." }, { vi: "Một byte chứa 8 ký tự.", en: "A byte containing 8 characters." }, { vi: "Một loại định dạng ảnh.", en: "A type of image format." }], a: 1, explanation: { vi: "Bit (Binary Digit) là đơn vị thông tin cơ bản nhất, chỉ có thể là 0 hoặc 1.", en: "A bit (Binary Digit) is the most basic unit of information, which can only be 0 or 1." } },
                    { q: { vi: "Một byte truyền thống gồm bao nhiêu bit?", en: "How many bits are in a traditional byte?" }, o: [{ vi: "4", en: "4" }, { vi: "6", en: "6" }, { vi: "8", en: "8" }, { vi: "16", en: "16" }], a: 2, explanation: { vi: "Theo quy ước, một byte là một nhóm gồm 8 bit.", en: "By convention, a byte is a group of 8 bits." } },
                    { q: { vi: "Một bit pattern (chuỗi bit) có thể được dùng để biểu diễn:", en: "A bit pattern can be used to represent:" }, o: [{ vi: "Chỉ số nguyên.", en: "Only integers." }, { vi: "Chỉ ký tự văn bản.", en: "Only text characters." }, { vi: "Số, chữ, âm thanh, ảnh — tất cả đều có thể.", en: "Numbers, text, audio, images — all are possible." }, { vi: "Chỉ ảnh.", en: "Only images." }], a: 2, explanation: { vi: "Tất cả các loại dữ liệu trong máy tính đều được mã hóa thành các chuỗi bit để lưu trữ và xử lý.", en: "All types of data in a computer are encoded into bit patterns for storage and processing." } },
                    { q: { vi: "Phạm vi số nguyên unsigned được lưu trong n bits là:", en: "The range of an unsigned integer stored in n bits is:" }, o: [{ vi: "−2^(n−1) đến 2^(n−1) − 1", en: "−2^(n−1) to 2^(n−1) − 1" }, { vi: "0 đến 2ⁿ − 1", en: "0 to 2ⁿ − 1" }, { vi: "−2^(n−1) + 1 đến 2^(n−1) − 1", en: "−2^(n−1) + 1 to 2^(n−1) − 1" }, { vi: "−2ⁿ đến 2ⁿ", en: "−2ⁿ to 2ⁿ" }], a: 1, explanation: { vi: "Với n bit, có 2^n tổ hợp khác nhau, biểu diễn các số từ 0 đến 2^n-1.", en: "With n bits, there are 2^n different combinations, representing numbers from 0 to 2^n-1." } },
                    { q: { vi: "Trong sign-and-magnitude (dấu và độ lớn) dùng n bits, bit trái nhất dùng để:", en: "In sign-and-magnitude using n bits, the leftmost bit is used for:" }, o: [{ vi: "Biểu diễn bit chẵn lẻ.", en: "Representing the parity bit." }, { vi: "Biểu diễn dấu (0:+, 1:-).", en: "Representing the sign (0:+, 1:-)." }, { vi: "Biểu diễn phần mũ của số thực.", en: "Representing the exponent of a real number." }, { vi: "Không dùng.", en: "Not used." }], a: 1, explanation: { vi: "Trong phương pháp này, bit ngoài cùng bên trái được dành riêng để chỉ ra dấu của số.", en: "In this method, the leftmost bit is explicitly reserved to indicate the number's sign." } },
                    { q: { vi: "Điều nào sau đây KHÔNG đúng về sign-and-magnitude?", en: "Which of the following is NOT true about sign-and-magnitude?" }, o: [{ vi: "Có thể có hai biểu diễn cho số 0 (+0 và -0).", en: "It can have two representations for zero (+0 and -0)." }, { vi: "Bit trái nhất là dấu.", en: "The leftmost bit is the sign." }, { vi: "Dùng 1 bit để lưu dấu, phần còn lại lưu giá trị tuyệt đối.", en: "It uses 1 bit for the sign, the rest for the absolute value." }, { vi: "Phổ biến trong các CPU hiện đại để lưu số nguyên.", en: "It is common in modern CPUs for storing integers." }], a: 3, explanation: { vi: "Sign-and-magnitude không phổ biến cho số nguyên vì vấn đề hai số 0 và sự phức tạp trong mạch số học. Bù hai là tiêu chuẩn.", en: "Sign-and-magnitude is not common for integers due to the two-zeros problem and arithmetic complexity. Two's complement is the standard." } },
                    { q: { vi: "Hầu hết máy tính hiện đại lưu số nguyên có dấu theo dạng nào?", en: "How do most modern computers store signed integers?" }, o: [{ vi: "Sign-and-magnitude", en: "Sign-and-magnitude" }, { vi: "One’s complement", en: "One's complement" }, { vi: "Two’s complement", en: "Two's complement" }, { vi: "Excess-127", en: "Excess-127" }], a: 2, explanation: { vi: "Bù hai (Two's complement) là phương pháp thống trị vì nó có một biểu diễn duy nhất cho số 0 và đơn giản hóa các phép toán số học.", en: "Two's complement is the dominant method because it has a single representation for zero and simplifies arithmetic operations." } },
                    { q: { vi: "Cách lấy two’s complement của một số nhị phân (cách ngắn gọn) là:", en: "The way to take the two's complement of a binary number (the short way) is:" }, o: [{ vi: "Đảo tất cả bit (one’s complement) rồi cộng 1.", en: "Invert all bits (one's complement) then add 1." }, { vi: "Cộng 1 rồi đảo tất cả bit.", en: "Add 1 then invert all bits." }, { vi: "Chỉ đảo các bit 0→1.", en: "Only invert the 0→1 bits." }, { vi: "Không liên quan tới đảo bit.", en: "It's unrelated to inverting bits." }], a: 0, explanation: { vi: "Đây là thuật toán hai bước tiêu chuẩn: đầu tiên tìm bù một bằng cách đảo tất cả các bit, sau đó cộng 1 vào kết quả.", en: "This is the standard two-step algorithm: first find the one's complement by inverting all bits, then add 1 to the result." } },
                    { q: { vi: "Biểu diễn two’s-complement 8-bit của +28 là:", en: "The 8-bit two's complement representation of +28 is:" }, o: [{ vi: "11100100", en: "11100100" }, { vi: "00011100", en: "00011100" }, { vi: "10011100", en: "10011100" }, { vi: "01110000", en: "01110000" }], a: 1, explanation: { vi: "Số dương trong bù hai được biểu diễn giống như số không dấu. 28 = 16 + 8 + 4, là 00011100.", en: "Positive numbers in two's complement are represented like unsigned numbers. 28 = 16 + 8 + 4, which is 00011100." } },
                    { q: { vi: "Biểu diễn two’s-complement 8-bit của −28 là:", en: "The 8-bit two's complement representation of -28 is:" }, o: [{ vi: "11100100", en: "11100100" }, { vi: "00011100", en: "00011100" }, { vi: "10011100", en: "10011100" }, { vi: "01110000", en: "01110000" }], a: 0, explanation: { vi: "+28 là 00011100. Đảo bit: 11100011. Cộng 1: 11100100.", en: "+28 is 00011100. Invert bits: 11100011. Add 1: 11100100." } },
                    { q: { vi: "Khi đọc giá trị lưu ở two’s complement 8-bit là 11100110, giá trị thập phân là:", en: "When reading the 8-bit two's complement value 11100110, the decimal value is:" }, o: [{ vi: "+230", en: "+230" }, { vi: "−26", en: "-26" }, { vi: "+110", en: "+110" }, { vi: "−100", en: "-100" }], a: 1, explanation: { vi: "Bit đầu là 1 nên là số âm. Đảo bit: 00011001. Cộng 1: 00011010 = 26. Vậy giá trị là -26.", en: "The first bit is 1, so it's a negative number. Invert bits: 00011001. Add 1: 00011010 = 26. So the value is -26." } },
                    { q: { vi: "Phạm vi giá trị của two’s-complement trong n bit là:", en: "The value range of an n-bit two's complement is:" }, o: [{ vi: "0 đến 2ⁿ − 1", en: "0 to 2ⁿ − 1" }, { vi: "−(2ⁿ⁻¹) đến 2ⁿ⁻¹ − 1", en: "−(2ⁿ⁻¹) to 2ⁿ⁻¹ − 1" }, { vi: "−(2ⁿ⁻¹ − 1) đến 2ⁿ⁻¹ − 1", en: "−(2ⁿ⁻¹ − 1) to 2ⁿ⁻¹ − 1" }, { vi: "−2ⁿ đến 2ⁿ", en: "−2ⁿ to 2ⁿ" }], a: 1, explanation: { vi: "Đây là công thức chuẩn cho phạm vi của số bù hai, nó có thể biểu diễn thêm một số âm so với số dương.", en: "This is the standard formula for the range of two's complement numbers, which can represent one more negative number than positive." } },
                    { q: { vi: "Trong sign-and-magnitude với 8 bits, giá trị tối đa dương có thể lưu là:", en: "In sign-and-magnitude with 8 bits, the maximum positive value that can be stored is:" }, o: [{ vi: "127", en: "127" }, { vi: "128", en: "128" }, { vi: "255", en: "255" }, { vi: "63", en: "63" }], a: 0, explanation: { vi: "1 bit cho dấu, 7 bit còn lại cho độ lớn. Giá trị lớn nhất của 7 bit là 2⁷-1 = 127.", en: "1 bit is for the sign, the remaining 7 bits are for the magnitude. The maximum value of 7 bits is 2⁷-1 = 127." } },
                    { q: { vi: "Điều nào mô tả overflow khi cộng số trong bộ nhớ cố định n-bit?", en: "Which describes overflow when adding numbers in a fixed n-bit memory?" }, o: [{ vi: "Khi kết quả vừa khớp n-bit.", en: "When the result fits exactly in n-bits." }, { vi: "Khi kết quả vượt quá phạm vi có thể biểu diễn trong n-bit.", en: "When the result exceeds the range representable in n-bits." }, { vi: "Khi có bit trái nhất bằng 1.", en: "When the leftmost bit is 1." }, { vi: "Khi số âm đổi thành 0.", en: "When a negative number becomes 0." }], a: 1, explanation: { vi: "Overflow là một lỗi xảy ra khi một phép toán số học tạo ra một giá trị nằm ngoài phạm vi có thể được lưu trữ.", en: "Overflow is an error that occurs when an arithmetic operation produces a value that is outside the representable range." } },
                    { q: { vi: "Floating-point (số chấm động) trong máy tính lưu trữ các phần:", en: "Floating-point numbers in a computer store which parts:" }, o: [{ vi: "Dấu (S), mũ (E), mantissa (M)", en: "Sign (S), exponent (E), mantissa (M)" }, { vi: "Chỉ dấu và phần nguyên.", en: "Only sign and integer part." }, { vi: "Chỉ mũ và phần nguyên.", en: "Only exponent and integer part." }, { vi: "Dấu, thập phân, và kiểm tra chẵn lẻ.", en: "Sign, decimal, and parity check." }], a: 0, explanation: { vi: "Biểu diễn này tương tự như ký hiệu khoa học, bao gồm dấu, phần định trị (mantissa) và số mũ (exponent).", en: "This representation is analogous to scientific notation, consisting of a sign, a significand (mantissa), and an exponent." } },
                    { q: { vi: "Normalization trong floating-point là:", en: "Normalization in floating-point is:" }, o: [{ vi: "Giữ nhiều số 0 bên trái dấu thập phân.", en: "Keeping many zeros to the left of the decimal point." }, { vi: "Đảm bảo chỉ có một chữ số không-zero bên trái dấu thập phân (binary: 1.x).", en: "Ensuring there is only one non-zero digit to the left of the decimal point (binary: 1.x)." }, { vi: "Chuyển sang hệ thập phân.", en: "Converting to the decimal system." }, { vi: "Lưu exponent dưới dạng hai-bù.", en: "Storing the exponent in two's complement." }], a: 1, explanation: { vi: "Chuẩn hóa đảm bảo rằng mỗi số có một biểu diễn duy nhất, giúp cho việc so sánh và tính toán trở nên nhất quán.", en: "Normalization ensures that each number has a unique representation, which makes comparison and calculations consistent." } },
                    { q: { vi: "Trong IEEE-754 single precision (32 bit): số bit cho exponent và mantissa lần lượt là:", en: "In IEEE-754 single precision (32 bits): the number of bits for the exponent and mantissa are, respectively:" }, o: [{ vi: "8 và 23", en: "8 and 23" }, { vi: "11 và 52", en: "11 and 52" }, { vi: "1 và 31", en: "1 and 31" }, { vi: "10 và 21", en: "10 and 21" }], a: 0, explanation: { vi: "Định dạng 32-bit được chia thành 1 bit dấu, 8 bit số mũ, và 23 bit phần định trị.", en: "The 32-bit format is divided into 1 sign bit, 8 exponent bits, and 23 mantissa bits." } },
                    { q: { vi: "Bias (giá trị bù) cho exponent trong single precision (m = 8) bằng:", en: "The bias for the exponent in single precision (m = 8) is:" }, o: [{ vi: "2^8 − 1", en: "2^8 − 1" }, { vi: "2⁷ − 1 = 127", en: "2⁷ − 1 = 127" }, { vi: "1273", en: "1273" }, { vi: "2⁸", en: "2⁸" }], a: 1, explanation: { vi: "Bias được tính bằng 2^(m-1) - 1, với m là số bit của exponent. Với m=8, bias là 127.", en: "The bias is calculated as 2^(m-1) - 1, where m is the number of exponent bits. For m=8, the bias is 127." } },
                    { q: { vi: "Giá trị biểu diễn của bit pattern single-precision 01000000101110000000000000000000 là (theo ví dụ sách):", en: "The value represented by the single-precision bit pattern 01000000101110000000000000000000 is (per the book's example):" }, o: [{ vi: "5.75", en: "5.75" }, { vi: "−5.75", en: "-5.75" }, { vi: "448", en: "448" }, { vi: "−448", en: "-448" }], a: 0, explanation: { vi: "S=0 (dương). E=129 -> e=2. M=0.0111. Số là +1.0111 * 2^2 = +101.11 = 5.75.", en: "S=0 (positive). E=129 -> e=2. M=0.0111. The number is +1.0111 * 2^2 = +101.11 = 5.75." } },
                    { q: { vi: "Trong IEEE single-precision, biểu diễn zero (0.0) được lưu thế nào?", en: "In IEEE single-precision, how is zero (0.0) represented?" }, o: [{ vi: "S = 0, E = 0, M = 0", en: "S = 0, E = 0, M = 0" }, { vi: "S = 1, E = 0, M = 0", en: "S = 1, E = 0, M = 0" }, { vi: "S = 0, E = 255, M = 0", en: "S = 0, E = 255, M = 0" }, { vi: "S = 0, E = 127, M = 0", en: "S = 0, E = 127, M = 0" }], a: 0, explanation: { vi: "Số không được biểu diễn bằng một trường số mũ và phần định trị đều bằng không. Bit dấu có thể là 0 hoặc 1 (+0 và -0).", en: "Zero is represented by an exponent field and a mantissa field of all zeros. The sign bit can be 0 or 1 (+0 and -0)." } },
                    { q: { vi: "Phát biểu đúng về truncation error trong floating-point là:", en: "The correct statement about truncation error in floating-point is:" }, o: [{ vi: "Là lỗi do ghi nhãn bit.", en: "It is an error from bit labeling." }, { vi: "Là sai số sinh ra khi mantissa bị cắt/truncate vì độ dài cố định.", en: "It is the error generated when the mantissa is cut/truncated due to fixed length." }, { vi: "Là lỗi chỉ có trong integer.", en: "It is an error that only exists in integers." }, { vi: "Là lỗi do thiếu memoria.", en: "It is an error due to lack of memory." }], a: 1, explanation: { vi: "Khi một số có nhiều chữ số ở phần định trị hơn số bit cho phép, các bit cuối cùng sẽ bị loại bỏ, gây ra một sai số nhỏ.", en: "When a number has more digits in its mantissa than the available bits allow, the final bits are discarded, causing a small error." } },
                    { q: { vi: "ASCII truyền thống dùng bao nhiêu bit cho một ký tự?", en: "How many bits does traditional ASCII use for one character?" }, o: [{ vi: "7 bit", en: "7 bits" }, { vi: "8 bit", en: "8 bits" }, { vi: "16 bit", en: "16 bits" }, { vi: "32 bit", en: "32 bits" }], a: 0, explanation: { vi: "ASCII gốc sử dụng 7 bit, cho phép 128 ký tự khác nhau.", en: "The original ASCII uses 7 bits, allowing for 128 different characters." } },
                    { q: { vi: "Unicode (theo chương này) dùng tối đa bao nhiêu bit cho mỗi mã?", en: "Unicode (according to this chapter) uses a maximum of how many bits per code point?" }, o: [{ vi: "7", en: "7" }, { vi: "8", en: "8" }, { vi: "16", en: "16" }, { vi: "32", en: "32" }], a: 3, explanation: { vi: "Unicode được thiết kế để bao quát tất cả các ngôn ngữ, và các lược đồ mã hóa của nó có thể sử dụng tới 32 bit để biểu diễn một ký tự.", en: "Unicode is designed to encompass all languages, and its encoding schemes can use up to 32 bits to represent a character." } },
                    { q: { vi: "Khi lưu âm thanh analog vào máy tính, sampling là gì?", en: "When storing analog audio on a computer, what is sampling?" }, o: [{ vi: "Lấy mẫu giá trị tín hiệu tại các thời điểm rời rạc.", en: "Taking samples of the signal's value at discrete time intervals." }, { vi: "Là lưu toàn bộ tín hiệu liên tục.", en: "Storing the entire continuous signal." }, { vi: "Là thuật toán nén âm thanh.", en: "It is an audio compression algorithm." }, { vi: "Là chỉnh âm lượng.", en: "It is adjusting the volume." }], a: 0, explanation: { vi: "Lấy mẫu là quá trình chuyển đổi một tín hiệu thời gian liên tục thành một tín hiệu thời gian rời rạc bằng cách đo biên độ của nó tại các khoảng thời gian đều đặn.", en: "Sampling is the process of converting a continuous-time signal into a discrete-time signal by measuring its amplitude at regular intervals." } },
                    { q: { vi: "Quantization trong lưu âm thanh là gì?", en: "What is quantization in audio storage?" }, o: [{ vi: "Lấy mẫu theo thời gian.", en: "Sampling over time." }, { vi: "Là làm tròn giá trị mẫu liên tục sang giá trị rời rạc (số nguyên).", en: "Rounding a continuous sample value to a discrete (integer) value." }, { vi: "Là nén dữ liệu.", en: "It is data compression." }, { vi: "Là thay đổi tần số.", en: "It is changing the frequency." }], a: 1, explanation: { vi: "Sau khi lấy mẫu, mỗi giá trị đo được được ánh xạ tới một giá trị trong một tập hợp hữu hạn các mức. Quá trình này được gọi là lượng tử hóa.", en: "After sampling, each measured value is mapped to a value from a finite set of levels. This process is called quantization." } },
                    { q: { vi: "Công thức tính bit rate (R) cho âm thanh thô (trước nén) là:", en: "The formula for the bit rate (R) of raw (uncompressed) audio is:" }, o: [{ vi: "R = S + B", en: "R = S + B" }, { vi: "R = S × B (S = số mẫu/s, B = bit trên mẫu)", en: "R = S × B (S = samples/sec, B = bits per sample)" }, { vi: "R = B / S", en: "R = B / S" }, { vi: "R = S^B", en: "R = S^B" }], a: 1, explanation: { vi: "Tốc độ bit là tổng số bit cần thiết mỗi giây, bằng tần số lấy mẫu nhân với số bit cho mỗi mẫu.", en: "The bit rate is the total number of bits needed per second, which is the sampling rate multiplied by the number of bits per sample." } },
                    { q: { vi: "Nếu dùng 40.000 samples/s và 16 bits/sample thì bit rate là:", en: "If using 40,000 samples/s and 16 bits/sample, the bit rate is:" }, o: [{ vi: "640,000 bits/s", en: "640,000 bits/s" }, { vi: "705,600 bits/s", en: "705,600 bits/s" }, { vi: "44,100 bits/s", en: "44,100 bits/s" }, { vi: "1,280,000 bits/s", en: "1,280,000 bits/s" }], a: 0, explanation: { vi: "Tốc độ bit = 40,000 mẫu/giây * 16 bit/mẫu = 640,000 bit/giây.", en: "Bit rate = 40,000 samples/sec * 16 bits/sample = 640,000 bits/sec." } },
                    { q: { vi: "True-Color dùng bao nhiêu bit cho mỗi pixel (thông thường)?", en: "How many bits does True-Color typically use per pixel?" }, o: [{ vi: "8 bit", en: "8 bits" }, { vi: "16 bit", en: "16 bits" }, { vi: "24 bit (8 bit cho R,G,B)", en: "24 bits (8 bits for R,G,B)" }, { vi: "32 bit", en: "32 bits" }], a: 2, explanation: { vi: "True-Color sử dụng 8 bit cho mỗi kênh trong ba kênh màu (Đỏ, Xanh lá, Xanh dương), tổng cộng 24 bit, cho phép hơn 16 triệu màu.", en: "True-Color uses 8 bits for each of the three color channels (Red, Green, Blue), for a total of 24 bits, allowing for over 16 million colors." } },
                    { q: { vi: "Raster graphics (bitmap) khác vector ở điểm nào?", en: "How do raster graphics (bitmap) differ from vector graphics?" }, o: [{ vi: "Raster lưu công thức toán học; vector lưu từng pixel.", en: "Raster stores mathematical formulas; vector stores individual pixels." }, { vi: "Raster lưu từng pixel; vector lưu bằng các hình hình học/định nghĩa toán học.", en: "Raster stores individual pixels; vector stores by geometric shapes/mathematical definitions." }, { vi: "Cả hai giống nhau.", en: "They are the same." }, { vi: "Raster không thể hiển thị ảnh.", en: "Raster cannot display images." }], a: 1, explanation: { vi: "Đồ họa raster là một lưới các pixel, trong khi đồ họa vector là một tập hợp các chỉ thị toán học để vẽ hình dạng.", en: "Raster graphics are a grid of pixels, while vector graphics are a set of mathematical instructions for drawing shapes." } },
                    { q: { vi: "Rescaling (phóng to) ảnh vector so với raster:", en: "Rescaling a vector image versus a raster image:" }, o: [{ vi: "Vector giữ chất lượng khi phóng lớn; raster có thể bị răng cưa.", en: "Vector maintains quality when enlarged; raster can become pixelated." }, { vi: "Ngược lại.", en: "The opposite is true." }, { vi: "Cả hai đều xấu hơn khi phóng to.", en: "Both look worse when enlarged." }, { vi: "Liên quan tới âm thanh.", en: "This is related to audio." }], a: 0, explanation: { vi: "Vì vector được định nghĩa bằng toán học, chúng có thể được thu phóng đến bất kỳ kích thước nào mà không làm mất chất lượng. Raster, là một lưới pixel cố định, sẽ bị vỡ hạt.", en: "Because vectors are mathematically defined, they can be scaled to any size without quality loss. Raster, being a fixed grid of pixels, will become pixelated." } },
                    { q: { vi: "Bit depth (độ sâu bit) cho ảnh, ảnh hưởng đến:", en: "The bit depth for an image affects:" }, o: [{ vi: "Kích thước ảnh duy nhất.", en: "Only the image dimensions." }, { vi: "Số mức màu mỗi pixel có thể biểu diễn.", en: "The number of color levels each pixel can represent." }, { vi: "Tốc độ khung hình.", en: "The frame rate." }, { vi: "Kích thước màn hình.", en: "The screen size." }], a: 1, explanation: { vi: "Độ sâu bit cao hơn có nghĩa là nhiều bit hơn cho mỗi pixel, cho phép một dải màu rộng hơn và hình ảnh chân thực hơn.", en: "A higher bit depth means more bits per pixel, allowing for a wider range of colors and a more realistic image." } },
                    { q: { vi: "Một pixel True-Color có thể lưu màu (R,G,B) = (255,0,0) là màu gì?", en: "A True-Color pixel storing the color (R,G,B) = (255,0,0) is what color?" }, o: [{ vi: "Xanh lá", en: "Green" }, { vi: "Đỏ tươi", en: "Bright Red" }, { vi: "Đen", en: "Black" }, { vi: "Trắng", en: "White" }], a: 1, explanation: { vi: "Trong mô hình màu RGB, giá trị đầu tiên đại diện cho Đỏ, thứ hai cho Xanh lá, và thứ ba cho Xanh dương. (255, 0, 0) là màu đỏ tối đa.", en: "In the RGB color model, the first value represents Red, the second Green, and the third Blue. (255, 0, 0) is maximum red." } },
                    { q: { vi: "Video lưu như thế nào trong máy tính (theo chương)?", en: "How is video stored in a computer (according to the chapter)?" }, o: [{ vi: "Là dạng ảnh tĩnh.", en: "As a static image." }, { vi: "Là chuỗi frames (ảnh) theo thời gian.", en: "As a sequence of frames (images) over time." }, { vi: "Là dạng audio thuần túy.", en: "As pure audio." }, { vi: "Là dạng vector luôn.", en: "Always as a vector format." }], a: 1, explanation: { vi: "Video tạo ra ảo giác chuyển động bằng cách hiển thị một loạt các hình ảnh tĩnh (khung hình) một cách nhanh chóng.", en: "Video creates the illusion of motion by displaying a rapid series of still images (frames)." } },
                    { q: { vi: "Trong biểu diễn floating-point, mantissa là:", en: "In floating-point representation, the mantissa is:" }, o: [{ vi: "Phần mũ.", en: "The exponent part." }, { vi: "Phần xác định độ chính xác (phần sau dấu trong 1.x), định dạng cố định.", en: "The part that determines precision (the part after the point in 1.x), in a fixed format." }, { vi: "Dấu (+/-).", en: "The sign (+/-)." }, { vi: "Giải mã ASCII.", en: "The ASCII decoding." }], a: 1, explanation: { vi: "Mantissa (hay significand) chứa các chữ số có nghĩa của số, xác định độ chính xác của nó.", en: "The mantissa (or significand) contains the significant digits of the number, determining its precision." } },
                    { q: { vi: "Giá trị bias cho double precision (exponent 11 bit) là:", en: "The bias value for double precision (11-bit exponent) is:" }, o: [{ vi: "127", en: "127" }, { vi: "1023", en: "1023" }, { vi: "2047", en: "2047" }, { vi: "512", en: "512" }], a: 1, explanation: { vi: "Sử dụng công thức 2^(m-1) - 1, với m=11, bias là 2^10 - 1 = 1024 - 1 = 1023.", en: "Using the formula 2^(m-1) - 1, with m=11, the bias is 2^10 - 1 = 1024 - 1 = 1023." } },
                    { q: { vi: "One’s complement có một đặc điểm khác two’s complement là:", en: "One's complement has a characteristic different from two's complement, which is:" }, o: [{ vi: "One’s complement có hai biểu diễn cho zero (+0 và −0).", en: "One's complement has two representations for zero (+0 and −0)." }, { vi: "One’s complement chỉ có +0.", en: "One's complement only has +0." }, { vi: "Two’s complement có hai zero.", en: "Two's complement has two zeros." }, { vi: "Cả hai giống nhau.", en: "They are the same." }], a: 0, explanation: { vi: "Trong bù một, 000...0 là +0 và 111...1 là -0. Bù hai giải quyết vấn đề này.", en: "In one's complement, 000...0 is +0 and 111...1 is -0. Two's complement solves this issue." } },
                    { q: { vi: "Khi so sánh biểu diễn của cùng một chuỗi bit 00001101 nếu ta đọc như unsigned thì là 13; nếu đọc như two’s complement (8-bit) thì vẫn là:", en: "Comparing the representation of the same bit string 00001101, if read as unsigned it is 13; if read as two's complement (8-bit) it is still:" }, o: [{ vi: "−13", en: "-13" }, { vi: "+13", en: "+13" }, { vi: "−243", en: "-243" }, { vi: "Không xác định", en: "Undefined" }], a: 1, explanation: { vi: "Đối với các số có bit dấu (bit ngoài cùng bên trái) là 0, giá trị của chúng là như nhau trong cả biểu diễn không dấu và bù hai.", en: "For numbers with a sign bit (leftmost bit) of 0, their value is the same in both unsigned and two's complement representation." } },
                    { q: { vi: "Nếu một ảnh có kích thước 800×600 pixel và dùng True-Color (24 bit/pixel), kích thước thô (không nén) tính theo bytes là:", en: "If an image is 800×600 pixels and uses True-Color (24 bits/pixel), its raw (uncompressed) size in bytes is:" }, o: [{ vi: "1,440,000 bytes", en: "1,440,000 bytes" }, { vi: "1,440 bytes", en: "1,440 bytes" }, { vi: "19,200 bytes", en: "19,200 bytes" }, { vi: "Không xác định", en: "Undefined" }], a: 0, explanation: { vi: "Tổng số bit = 800 * 600 * 24 = 11,520,000 bit. Tổng số byte = 11,520,000 / 8 = 1,440,000 byte.", en: "Total bits = 800 * 600 * 24 = 11,520,000 bits. Total bytes = 11,520,000 / 8 = 1,440,000 bytes." } },
                    { q: { vi: "Trong floating-point: “underflow” xảy ra khi:", en: "In floating-point: 'underflow' occurs when:" }, o: [{ vi: "Cố gắng lưu số nhỏ hơn giá trị +smallest có thể biểu diễn.", en: "Trying to store a number smaller than the smallest positive representable value." }, { vi: "Cố gắng lưu số lớn hơn +largest.", en: "Trying to store a number larger than the largest positive value." }, { vi: "Khi mantissa dài hơn exponent.", en: "When the mantissa is longer than the exponent." }, { vi: "Khi bit S = 1.", en: "When the S bit = 1." }], a: 0, explanation: { vi: "Underflow xảy ra khi kết quả của một phép toán quá gần số 0 để có thể được biểu diễn chính xác trong định dạng dấu phẩy động.", en: "Underflow occurs when the result of an operation is too close to zero to be accurately represented in the floating-point format." } },
                    { q: { vi: "MP3 thuộc loại nén nào?", en: "What type of compression does MP3 belong to?" }, o: [{ vi: "Lossless (Bảo toàn dữ liệu)", en: "Lossless" }, { vi: "Lossy (Mất dữ liệu)", en: "Lossy" }, { vi: "Không nén", en: "No compression" }, { vi: "Uncompressed PCM", en: "Uncompressed PCM" }], a: 1, explanation: { vi: "Nén mất mát (lossy) loại bỏ một số dữ liệu (thường là những âm thanh mà tai người khó nhận biết) để giảm đáng kể kích thước tệp.", en: "Lossy compression removes some data (often sounds that are hard for the human ear to perceive) to significantly reduce file size." } },
                    { q: { vi: "Một hệ 4-bit unsigned có thể biểu diễn bao nhiêu giá trị khác nhau?", en: "How many different values can a 4-bit unsigned system represent?" }, o: [{ vi: "8", en: "8" }, { vi: "16", en: "16" }, { vi: "4", en: "4" }, { vi: "32", en: "32" }], a: 1, explanation: { vi: "Với n bit, có thể biểu diễn 2^n giá trị. Với 4 bit, có 2^4 = 16 giá trị (từ 0 đến 15).", en: "With n bits, 2^n values can be represented. With 4 bits, there are 2^4 = 16 values (from 0 to 15)." } },
                    { q: { vi: "Trong biểu diễn Excess-7 (4-bit bias =7), giá trị 0 được biểu diễn bằng:", en: "In Excess-7 representation (4-bit, bias=7), the value 0 is represented by:" }, o: [{ vi: "0000", en: "0000" }, { vi: "0111", en: "0111" }, { vi: "1110", en: "1110" }, { vi: "1000", en: "1000" }], a: 1, explanation: { vi: "Giá trị lưu trữ = giá trị thực + bias. Do đó, 0 + 7 = 7. Số 7 trong hệ nhị phân 4-bit là 0111.", en: "Stored value = actual value + bias. Therefore, 0 + 7 = 7. The number 7 in 4-bit binary is 0111." } },
                    { q: { vi: "Số bit cần để biểu diễn N ký tự khác nhau là log2(N) làm tròn lên. Vậy để biểu diễn 256 ký tự cần ít nhất bao nhiêu bit?", en: "The number of bits needed to represent N different characters is ceil(log2(N)). So, to represent 256 characters, how many bits are needed at least?" }, o: [{ vi: "7", en: "7" }, { vi: "8", en: "8" }, { vi: "9", en: "9" }, { vi: "16", en: "16" }], a: 1, explanation: { vi: "Chúng ta cần tìm n sao cho 2^n >= 256. 2^8 = 256, vì vậy cần 8 bit.", en: "We need to find n such that 2^n >= 256. 2^8 = 256, so 8 bits are needed." } },
                    { q: { vi: "Lý do phải normalize khi lưu floating-point là gì?", en: "What is the reason for normalizing when storing a floating-point number?" }, o: [{ vi: "Để tiết kiệm bit cho sign.", en: "To save a bit for the sign." }, { vi: "Để có biểu diễn chuẩn, giúp so sánh và thao tác chính xác hơn (1.x form).", en: "To have a standard representation, which helps in more accurate comparison and manipulation (1.x form)." }, { vi: "Để lưu exponent bằng dạng ASCII.", en: "To store the exponent in ASCII format." }, { vi: "Để nén dữ liệu.", en: "To compress the data." }], a: 1, explanation: { vi: "Chuẩn hóa đảm bảo rằng mỗi số có một biểu diễn duy nhất, loại bỏ sự mơ hồ và làm cho các hoạt động như so sánh trở nên đơn giản.", en: "Normalization ensures that every number has a unique representation, which removes ambiguity and makes operations like comparison straightforward." } }
                ]
            },
            chapter4: {
                 theory: {
                    vi: `
                        <h2>Chương 4: Các Phép toán trên Dữ liệu</h2>
                        <h3>1. Phép toán Logic (Logic Operations)</h3>
                        <ul>
                            <li>Thực hiện trên từng bit của một hoặc hai chuỗi bit. Các toán tử chính:
                                <ul>
                                    <li><strong>NOT:</strong> Đảo bit (0 thành 1, 1 thành 0).</li>
                                    <li><strong>AND:</strong> Kết quả là 1 chỉ khi cả hai bit đầu vào đều là 1.</li>
                                    <li><strong>OR:</strong> Kết quả là 1 nếu ít nhất một trong hai bit đầu vào là 1.</li>
                                    <li><strong>XOR (Exclusive OR):</strong> Kết quả là 1 chỉ khi hai bit đầu vào khác nhau.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Ứng dụng: Dùng mặt nạ (Masking)</strong>
                                <ul>
                                    <li><span class="highlight">Unsetting (Xóa bit về 0):</span> Dùng phép <strong>AND</strong> với mặt nạ có bit 0 tại vị trí cần xóa.</li>
                                    <li><span class="highlight">Setting (Bật bit lên 1):</span> Dùng phép <strong>OR</strong> với mặt nạ có bit 1 tại vị trí cần bật.</li>
                                    <li><span class="highlight">Flipping (Lật bit):</span> Dùng phép <strong>XOR</strong> với mặt nạ có bit 1 tại vị trí cần lật.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Ví dụ về Masking</h3>
                        <pre><strong>Ví dụ: Xóa (unset) 5 bit ngoài cùng bên trái của 10100110</strong>
  1010 0110   (Dữ liệu gốc)
& 0000 0111   (Mặt nạ AND - 0 ở vị trí cần xóa)
-----------
  0000 0110   (Kết quả)

<strong>Ví dụ: Lật (flip) 5 bit ngoài cùng bên trái của 10100110</strong>
  1010 0110   (Dữ liệu gốc)
^ 1111 1000   (Mặt nạ XOR - 1 ở vị trí cần lật)
-----------
  0101 1110   (Kết quả)</pre>
                        <h3>3. Phép toán Dịch chuyển (Shift Operations)</h3>
                        <ul>
                             <li><strong>Dịch logic (Logical Shift):</strong> Dịch chuyển các bit, chèn số 0 vào chỗ trống. Dùng cho số không dấu.</li>
                             <li><strong>Dịch số học (Arithmetic Shift):</strong> Dùng cho số bù 2. Khi dịch phải, bit dấu được giữ nguyên để bảo toàn giá trị âm/dương. Dịch trái tương đương nhân 2, dịch phải tương đương chia 2.</li>
                        </ul>
                        <h3>4. Phép toán Số học (Arithmetic Operations)</h3>
                        <ul>
                            <li>Phép cộng số Bù 2 được thực hiện như cộng nhị phân thông thường, bit nhớ cuối cùng (nếu có) sẽ bị bỏ đi.</li>
                            <li><span class="highlight">Phép trừ A - B được thực hiện bằng phép cộng: A + (Bù 2 của B)</span>.</li>
                        </ul>
                         <pre><strong>Ví dụ: (+24) + (-17) dùng số bù 2 8-bit</strong>
+24       = 0001 1000
-17       = 1110 1111  (Bù 2 của 17)
-------------------
Kết quả: (1)0000 0111  (Bỏ bit nhớ cuối)
          = 7₁₀ (Đúng)</pre>
                    `,
                    en: `
                        <h2>Chapter 4: Operations on Data</h2>
                        <h3>1. Logic Operations</h3>
                        <ul>
                            <li>Performed on individual bits of one or two bit patterns. Main operators:
                                <ul>
                                    <li><strong>NOT:</strong> Inverts the bit (0 becomes 1, 1 becomes 0).</li>
                                    <li><strong>AND:</strong> The result is 1 only if both input bits are 1.</li>
                                    <li><strong>OR:</strong> The result is 1 if at least one of the input bits is 1.</li>
                                    <li><strong>XOR (Exclusive OR):</strong> The result is 1 only if the input bits are different.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Application: Masking</strong>
                                <ul>
                                    <li><span class="highlight">Unsetting a bit (to 0):</span> Use <strong>AND</strong> with a mask that has a 0 at the desired position.</li>
                                    <li><span class="highlight">Setting a bit (to 1):</span> Use <strong>OR</strong> with a mask that has a 1 at the desired position.</li>
                                    <li><span class="highlight">Flipping a bit:</span> Use <strong>XOR</strong> with a mask that has a 1 at the desired position.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Masking Examples</h3>
                        <pre><strong>Example: Unset the five leftmost bits of 10100110</strong>
  1010 0110   (Original Data)
& 0000 0111   (AND Mask - 0s where you want to clear)
-----------
  0000 0110   (Result)

<strong>Example: Flip the five leftmost bits of 10100110</strong>
  1010 0110   (Original Data)
^ 1111 1000   (XOR Mask - 1s where you want to flip)
-----------
  0101 1110   (Result)</pre>
                        <h3>3. Shift Operations</h3>
                        <ul>
                             <li><strong>Logical Shift:</strong> Shifts bits and inserts a 0 into the empty spot. Used for unsigned numbers.</li>
                             <li><strong>Arithmetic Shift:</strong> Used for two's complement numbers. A right shift preserves the sign bit. Left shift is equivalent to multiplying by 2, right shift is equivalent to dividing by 2.</li>
                        </ul>
                        <h3>4. Arithmetic Operations</h3>
                        <ul>
                            <li>Two's Complement addition is performed like normal binary addition, and the final carry bit (if any) is discarded.</li>
                            <li><span class="highlight">Subtraction A - B is performed as an addition: A + (Two's complement of B)</span>.</li>
                        </ul>
                         <pre><strong>Example: (+24) + (-17) using 8-bit two's complement</strong>
+24       = 0001 1000
-17       = 1110 1111  (Two's complement of 17)
-------------------
Result: (1)0000 0111  (Discard final carry)
          = 7₁₀ (Correct)</pre>
                    `
                },
                questions: [
                    { q: { vi: "Kết quả của phép NOT trên 8-bit 10011000 là:", en: "The result of a NOT operation on the 8-bit pattern 10011000 is:" }, o: [{ vi: "01100111", en: "01100111" }, { vi: "10011000", en: "10011000" }, { vi: "01111000", en: "01111000" }, { vi: "00100111", en: "00100111" }], a: 0, explanation: { vi: "Vì NOT đổi 0↔1: 10011000 → 01100111.", en: "Because NOT inverts 0↔1: 10011000 → 01100111." } },
                    { q: { vi: "10011000 AND 00101010 bằng:", en: "10011000 AND 00101010 equals:" }, o: [{ vi: "00001000", en: "00001000" }, { vi: "10011010", en: "10011010" }, { vi: "00101000", en: "00101000" }, { vi: "00000000", en: "00000000" }], a: 0, explanation: { vi: "AND giữ 1 chỉ khi cả hai là 1; kết quả 00001000.", en: "AND results in 1 only when both bits are 1; the result is 00001000." } },
                    { q: { vi: "10011001 OR 00101110 bằng:", en: "10011001 OR 00101110 equals:" }, o: [{ vi: "10011111", en: "10011111" }, { vi: "10111111", en: "10111111" }, { vi: "00101111", en: "00101111" }, { vi: "10001010", en: "10001010" }], a: 1, explanation: { vi: "Bitwise OR operation results in 10111111.", en: "Bitwise OR operation results in 10111111." } },
                    { q: { vi: "10011001 XOR 00101110 bằng:", en: "10011001 XOR 00101110 equals:" }, o: [{ vi: "10110111", en: "10110111" }, { vi: "10111111", en: "10111111" }, { vi: "10011001", en: "10011001" }, { vi: "00101110", en: "00101110" }], a: 0, explanation: { vi: "XOR = 1 khi các bit khác nhau → 10110111.", en: "XOR = 1 when bits are different → 10110111." } },
                    { q: { vi: "Ta muốn unset (clear) 5 bit trái nhất của 10100110. Mask phù hợp và kết quả là:", en: "We want to unset (clear) the 5 leftmost bits of 10100110. The appropriate mask and result are:" }, o: [{ vi: "Mask 00000111, kết quả 00000110", en: "Mask 00000111, result 00000110" }, { vi: "Mask 11111000, kết quả 11111110", en: "Mask 11111000, result 11111110" }, { vi: "Mask 00011111, kết quả 00000110", en: "Mask 00011111, result 00000110" }, { vi: "Mask 00000111, kết quả 10100110", en: "Mask 00000111, result 10100110" }], a: 0, explanation: { vi: "Để unset 5 bit trái, mask cần có 0 ở 5 vị trí đó và 1 ở các vị trí còn lại: 00000111. 10100110 AND 00000111 = 00000110.", en: "To unset the 5 leftmost bits, the mask needs 0s in those positions and 1s elsewhere: 00000111. 10100110 AND 00000111 = 00000110." } },
                    { q: { vi: "Ta muốn set (force =1) 5 bit trái nhất của 10100110. Mask và kết quả là:", en: "We want to set (force to 1) the 5 leftmost bits of 10100110. The mask and result are:" }, o: [{ vi: "Mask 11111000, kết quả 11111110", en: "Mask 11111000, result 11111110" }, { vi: "Mask 00000111, kết quả 10100111", en: "Mask 00000111, result 10100111" }, { vi: "Mask 11111000, kết quả 10111110", en: "Mask 11111000, result 10111110" }, { vi: "Mask 11111111, kết quả 11111110", en: "Mask 11111111, result 11111110" }], a: 0, explanation: { vi: "Để set bit, dùng OR với mask có 1 ở vị trí cần set. OR với 11111000 → 11111110.", en: "To set bits, use OR with a mask having 1s at the desired positions. OR with 11111000 → 11111110." } },
                    { q: { vi: "Dùng mask 11111000 để flip (XOR) 5 bit trái nhất trên 10100110. Kết quả là:", en: "Using mask 11111000 to flip (XOR) the 5 leftmost bits of 10100110. The result is:" }, o: [{ vi: "01011110", en: "01011110" }, { vi: "11111110", en: "11111110" }, { vi: "00000110", en: "00000110" }, { vi: "10100110", en: "10100110" }], a: 0, explanation: { vi: "10100110 XOR 11111000 = 01011110.", en: "10100110 XOR 11111000 = 01011110." } },
                    { q: { vi: "Simple left shift 1 vị trí của 10011000 (8-bit logical shift) cho kết quả:", en: "A simple left shift by 1 position of 10011000 (8-bit logical shift) results in:" }, o: [{ vi: "00110000", en: "00110000" }, { vi: "00011000", en: "00011000" }, { vi: "00110001", en: "00110001" }, { vi: "10011000", en: "10011000" }], a: 0, explanation: { vi: "Dịch trái làm mất bit trái nhất và chèn 0 vào bên phải → 00110000.", en: "A left shift discards the leftmost bit and inserts a 0 on the right → 00110000." } },
                    { q: { vi: "Circular (rotate) left 1 vị trí của 10011000 cho:", en: "A circular (rotate) left by 1 position of 10011000 gives:" }, o: [{ vi: "00110000", en: "00110000" }, { vi: "00110001", en: "00110001" }, { vi: "11001100", en: "11001100" }, { vi: "00011001", en: "00011001" }], a: 1, explanation: { vi: "Dịch vòng trái: 10011000 → 00110001 (bit trái nhất '1' được đưa về bên phải).", en: "Left rotate: 10011000 → 00110001 (the leftmost bit '1' is moved to the rightmost position)." } },
                    { q: { vi: "Cho mẫu 10110110. Bit thứ 3 từ bên phải (third bit from right) có giá trị:", en: "Given the pattern 10110110. The third bit from the right has a value of:" }, o: [{ vi: "0", en: "0" }, { vi: "1", en: "1" }, { vi: "Không xác định", en: "Undefined" }, { vi: "Phải tính kiểu dấu", en: "Depends on sign type" }], a: 1, explanation: { vi: "Đếm từ phải sang (bắt đầu từ 1): bit thứ nhất là 0, thứ hai là 1, thứ ba là 1.", en: "Counting from the right (starting at 1): the first bit is 0, the second is 1, the third is 1." } },
                    { q: { vi: "Arithmetic left shift 1 vị trí trên số 8-bit two’s complement 11011001 cho kết quả nhị phân và thập phân tương ứng?", en: "An arithmetic left shift by 1 on the 8-bit two's complement number 11011001 gives what binary and decimal result?" }, o: [{ vi: "10110010 (−78)", en: "10110010 (−78)" }, { vi: "01101100 (+108)", en: "01101100 (+108)" }, { vi: "10110010 (+178)", en: "10110010 (+178)" }, { vi: "01011001 (89)", en: "01011001 (89)" }], a: 0, explanation: { vi: "Số ban đầu là -39. Dịch trái số học 1 vị trí tương đương nhân 2. -39 * 2 = -78, là 10110010 trong bù hai.", en: "The original number is -39. An arithmetic left shift by 1 is equivalent to multiplying by 2. -39 * 2 = -78, which is 10110010 in two's complement." } },
                    { q: { vi: "Arithmetic left shift của 01111111 (8-bit) một vị trí tạo ra:", en: "An arithmetic left shift of 01111111 (8-bit) by one position creates:" }, o: [{ vi: "11111110 và xảy ra overflow", en: "11111110 and an overflow occurs" }, { vi: "11111110 và không overflow", en: "11111110 and no overflow" }, { vi: "00111111 và không overflow", en: "00111111 and no overflow" }, { vi: "01111110 và không overflow", en: "01111110 and no overflow" }], a: 0, explanation: { vi: "01111111 (+127) dịch trái 1 bit thành 11111110 (-2). Vì dấu đã thay đổi từ dương sang âm, đã xảy ra tràn số.", en: "01111111 (+127) shifted left by 1 bit becomes 11111110 (-2). Since the sign changed from positive to negative, an overflow occurred." } },
                    { q: { vi: "Để chia một số nguyên (unsigned) cho 4 ta dùng thao tác dịch bit nào?", en: "To divide an unsigned integer by 4, which bit operation is used?" }, o: [{ vi: "Right shift by 2 (logical right shift)", en: "Right shift by 2 (logical right shift)" }, { vi: "Left shift by 2", en: "Left shift by 2" }, { vi: "Circular shift right by 2", en: "Circular shift right by 2" }, { vi: "XOR với 0x03", en: "XOR with 0x03" }], a: 0, explanation: { vi: "Dịch phải 2 vị trí tương đương chia cho 2², tức là chia cho 4 (đối với số không dấu).", en: "A right shift by 2 positions is equivalent to dividing by 2², which is dividing by 4 (for unsigned numbers)." } },
                    { q: { vi: "Để nhân một số nguyên (unsigned) với 8 ta làm:", en: "To multiply an unsigned integer by 8, we do:" }, o: [{ vi: "Left shift by 3", en: "Left shift by 3" }, { vi: "Right shift by 3", en: "Right shift by 3" }, { vi: "Left shift by 2 rồi + chính nó", en: "Left shift by 2 then + itself" }, { vi: "XOR với 0x08", en: "XOR with 0x08" }], a: 0, explanation: { vi: "Dịch trái 3 vị trí tương đương nhân với 2³, tức là nhân với 8.", en: "A left shift by 3 positions is equivalent to multiplying by 2³, which is multiplying by 8." } },
                    { q: { vi: "Với 8-bit two’s complement, 19 + 23 = ? (dạng nhị phân 8-bit)", en: "With 8-bit two's complement, 19 + 23 = ? (in 8-bit binary)" }, o: [{ vi: "00101010", en: "00101010" }, { vi: "11010110", en: "11010110" }, { vi: "11110110", en: "11110110" }, { vi: "00010101", en: "00010101" }], a: 0, explanation: { vi: "19 + 23 = 42. Trong hệ nhị phân 8-bit, 42 được viết là 00101010. Không có tràn số.", en: "19 + 23 = 42. In 8-bit binary, 42 is written as 00101010. There is no overflow." } },
                    { q: { vi: "Với 8-bit two’s complement, 19 − 23 = ? (kết quả dạng nhị phân)", en: "With 8-bit two's complement, 19 - 23 = ? (result in binary)" }, o: [{ vi: "11111100", en: "11111100" }, { vi: "00000100", en: "00000100" }, { vi: "11111011", en: "11111011" }, { vi: "00001100", en: "00001100" }], a: 0, explanation: { vi: "19 - 23 = -4. Biểu diễn bù hai 8-bit của -4 là 11111100.", en: "19 - 23 = -4. The 8-bit two's complement representation of -4 is 11111100." } },
                    { q: { vi: "Với 8-bit two’s complement, −19 + 23 = ?", en: "With 8-bit two's complement, -19 + 23 = ?" }, o: [{ vi: "00000100 (4)", en: "00000100 (4)" }, { vi: "11111100 (−4)", en: "11111100 (−4)" }, { vi: "11101101 (−19)", en: "11101101 (−19)" }, { vi: "00010110 (22)", en: "00010110 (22)" }], a: 0, explanation: { vi: "-19 + 23 = 4. Trong hệ nhị phân 8-bit, 4 được viết là 00000100.", en: "-19 + 23 = 4. In 8-bit binary, 4 is written as 00000100." } },
                    { q: { vi: "Tính (012A)₁₆ + (0E27)₁₆ trong 16-bit (hex):", en: "Calculate (012A)₁₆ + (0E27)₁₆ in 16-bit (hex):" }, o: [{ vi: "0F51", en: "0F51" }, { vi: "100F", en: "100F" }, { vi: "0D51", en: "0D51" }, { vi: "0E51", en: "0E51" }], a: 0, explanation: { vi: "Cộng theo từng cột từ phải sang: A+7=17=11₁₆ (viết 1 nhớ 1), 1+2+2=5, 1+E(14)=15=F, 0+0=0. Kết quả: 0F51.", en: "Adding column by column from the right: A+7=17=11₁₆ (write 1, carry 1), 1+2+2=5, 1+E(14)=15=F, 0+0=0. Result: 0F51." } },
                    { q: { vi: "Trong các phép sau (8-bit two’s complement), phép nào gây overflow?", en: "Among the following operations (8-bit two's complement), which one causes an overflow?" }, o: [{ vi: "01111111 + 00000011", en: "01111111 + 00000011" }, { vi: "11000010 + 00111111", en: "11000010 + 00111111" }, { vi: "00000010 + 00111111", en: "00000010 + 00111111" }, { vi: "00001111 + 00010000", en: "00001111 + 00010000" }], a: 0, explanation: { vi: "01111111 (+127) + 00000011 (+3) = +130. Giá trị này nằm ngoài phạm vi [-128, +127] của số bù hai 8-bit, do đó gây ra tràn số.", en: "01111111 (+127) + 00000011 (+3) = +130. This value is outside the [-128, +127] range of an 8-bit two's complement number, thus causing an overflow." } },
                    { q: { vi: "Kết quả cộng một số với two’s complement của chính nó (A + (A)₂c):", en: "The result of adding a number with its own two's complement (A + (A)₂c) is:" }, o: [{ vi: "0 (và có thể có carry)", en: "0 (and possibly a carry)" }, { vi: "All 1s (−1)", en: "All 1s (−1)" }, { vi: "A (giữ nguyên)", en: "A (unchanged)" }, { vi: "Undefined", en: "Undefined" }], a: 0, explanation: { vi: "Phép toán này tương đương với A + (-A), kết quả luôn là 0. Bit nhớ (carry) cuối cùng sẽ bị loại bỏ.", en: "This operation is equivalent to A + (-A), which always results in 0. The final carry bit is discarded." } },
                    { q: { vi: "Thao tác nào là unary (một toán hạng) trong chương này?", en: "Which operation is unary (one operand) in this chapter?" }, o: [{ vi: "AND", en: "AND" }, { vi: "OR", en: "OR" }, { vi: "XOR", en: "XOR" }, { vi: "NOT", en: "NOT" }], a: 3, explanation: { vi: "NOT là toán tử đơn (unary) vì nó chỉ hoạt động trên một đầu vào.", en: "NOT is a unary operator because it only works on one input." } },
                    { q: { vi: "AND, OR, XOR thuộc loại nào?", en: "What category do AND, OR, and XOR belong to?" }, o: [{ vi: "Unary", en: "Unary" }, { vi: "Binary", en: "Binary" }, { vi: "Ternary", en: "Ternary" }, { vi: "N/A", en: "N/A" }], a: 1, explanation: { vi: "Tất cả chúng đều là toán tử hai ngôi (binary), nghĩa là chúng hoạt động trên hai toán hạng đầu vào.", en: "They are all binary operators, meaning they operate on two input operands." } },
                    { q: { vi: "Trong truth table, AND trả về 1 khi:", en: "In a truth table, AND returns 1 when:" }, o: [{ vi: "ít nhất một input =1", en: "at least one input is 1" }, { vi: "cả hai input =1", en: "both inputs are 1" }, { vi: "chỉ một input =1", en: "only one input is 1" }, { vi: "cả hai input =0", en: "both inputs are 0" }], a: 1, explanation: { vi: "Phép AND chỉ đúng (1) khi tất cả các đầu vào của nó đều đúng (1).", en: "The AND operation is true (1) only when all of its inputs are true (1)." } },
                    { q: { vi: "OR (inclusive-or) trả về 0 khi:", en: "OR (inclusive-or) returns 0 when:" }, o: [{ vi: "cả hai input =0", en: "both inputs are 0" }, { vi: "ít nhất một input =1", en: "at least one input is 1" }, { vi: "cả hai input =1", en: "both inputs are 1" }, { vi: "không bao giờ 0", en: "never 0" }], a: 0, explanation: { vi: "Phép OR chỉ sai (0) khi tất cả các đầu vào của nó đều sai (0).", en: "The OR operation is false (0) only when all of its inputs are false (0)." } },
                    { q: { vi: "XOR trả về 1 khi:", en: "XOR returns 1 when:" }, o: [{ vi: "cả hai input giống nhau", en: "both inputs are the same" }, { vi: "hai input khác nhau", en: "the two inputs are different" }, { vi: "cả hai đều 1", en: "both are 1" }, { vi: "cả hai đều 0", en: "both are 0" }], a: 1, explanation: { vi: "XOR (Exclusive OR) trả về 1 chỉ khi các đầu vào của nó khác nhau (một là 1, một là 0).", en: "XOR (Exclusive OR) returns 1 only when its inputs are different (one is 1, the other is 0)." } },
                    { q: { vi: "Một ứng dụng của AND ở mức pattern là:", en: "An application of AND at the pattern level is:" }, o: [{ vi: "complement toàn bộ pattern", en: "complementing the entire pattern" }, { vi: "set (force to 1) bit cụ thể", en: "setting (force to 1) a specific bit" }, { vi: "unset (force to 0) bit cụ thể bằng mask", en: "unsetting (force to 0) a specific bit using a mask" }, { vi: "flip bit cụ thể", en: "flipping a specific bit" }], a: 2, explanation: { vi: "Phép AND với một mask có bit 0 tại một vị trí sẽ buộc bit tương ứng trong kết quả về 0, hay còn gọi là 'unset' hoặc 'clear'.", en: "The AND operation with a mask that has a 0 at a certain position will force the corresponding bit in the result to be 0, which is called 'unsetting' or 'clearing'." } },
                    { q: { vi: "Một ứng dụng của OR ở mức pattern là:", en: "An application of OR at the pattern level is:" }, o: [{ vi: "unset bit", en: "unsetting a bit" }, { vi: "set bit bằng mask có 1 ở vị trí cần set", en: "setting a bit using a mask with a 1 at the desired position" }, { vi: "lấy complement toàn bộ", en: "complementing the whole pattern" }, { vi: "xoay (rotate) bit", en: "rotating bits" }], a: 1, explanation: { vi: "Phép OR với một mask có bit 1 tại một vị trí sẽ buộc bit tương ứng trong kết quả về 1, hay còn gọi là 'set'.", en: "The OR operation with a mask that has a 1 at a certain position will force the corresponding bit in the result to be 1, which is called 'setting'." } },
                    { q: { vi: "Một ứng dụng của XOR ở mức pattern là:", en: "An application of XOR at the pattern level is:" }, o: [{ vi: "set bit", en: "setting a bit" }, { vi: "unset bit", en: "unsetting a bit" }, { vi: "flip (complement) bit được chọn", en: "flipping (complementing) selected bits" }, { vi: "trả về số bit 1", en: "returning the number of 1s" }], a: 2, explanation: { vi: "Phép XOR với một mask có bit 1 tại một vị trí sẽ đảo (flip) bit tương ứng trong pattern (0 thành 1, 1 thành 0).", en: "The XOR operation with a mask that has a 1 at a certain position will invert (flip) the corresponding bit in the pattern (0 becomes 1, 1 becomes 0)." } },
                    { q: { vi: "NOT trên một pattern tương đương với:", en: "A NOT on a pattern is equivalent to:" }, o: [{ vi: "one's complement", en: "one's complement" }, { vi: "two’s complement", en: "two’s complement" }, { vi: "mask OR", en: "mask OR" }, { vi: "mask AND", en: "mask AND" }], a: 0, explanation: { vi: "Phép NOT đảo tất cả các bit của một pattern, đây chính là định nghĩa của phép bù 1 (one's complement).", en: "The NOT operation inverts all bits of a pattern, which is the definition of the one's complement." } },
                    { q: { vi: "Logical shift được áp dụng cho:", en: "Logical shift is applied to:" }, o: [{ vi: "mẫu không đại diện số dấu", en: "patterns not representing signed numbers" }, { vi: "số dấu (signed) bắt buộc", en: "signed numbers exclusively" }, { vi: "floating point only", en: "floating point only" }, { vi: "tất cả trên", en: "all of the above" }], a: 0, explanation: { vi: "Phép dịch logic xử lý chuỗi bit như một tập hợp các bit đơn thuần, không quan tâm đến bit dấu. Nó phù hợp cho số không dấu.", en: "Logical shift treats the bit string as a simple collection of bits, without regard for a sign bit. It is suitable for unsigned numbers." } },
                    { q: { vi: "Arithmetic shift giả định:", en: "Arithmetic shift assumes:" }, o: [{ vi: "pattern là unsigned integer", en: "the pattern is an unsigned integer" }, { vi: "pattern là signed integer (two’s complement)", en: "the pattern is a signed integer (two's complement)" }, { vi: "pattern là string", en: "the pattern is a string" }, { vi: "pattern là floating point", en: "the pattern is a floating point" }], a: 1, explanation: { vi: "Phép dịch số học được thiết kế đặc biệt để bảo toàn dấu của số bù hai khi thực hiện dịch phải.", en: "Arithmetic shift is specifically designed to preserve the sign of a two's complement number during a right shift." } },
                    { q: { vi: "Simple right shift (logical right) chèn bit gì vào bên trái?", en: "A simple right shift (logical right) inserts what bit on the left?" }, o: [{ vi: "1", en: "1" }, { vi: "0", en: "0" }, { vi: "phụ thuộc sign", en: "depends on the sign" }, { vi: "giữ bit cũ", en: "keeps the old bit" }], a: 1, explanation: { vi: "Trong phép dịch logic, bit 0 luôn được chèn vào vị trí trống.", en: "In a logical shift, a 0 is always inserted into the vacant position." } },
                    { q: { vi: "Circular shift (rotate) khác simple shift ở điểm:", en: "A circular shift (rotate) differs from a simple shift in that:" }, o: [{ vi: "mất bit trái nhất", en: "it loses the leftmost bit" }, { vi: "không mất/không thêm bit — bit bị dịch được quay vòng", en: "it neither loses nor adds bits — the shifted bit is rotated" }, { vi: "luôn chèn 0", en: "it always inserts a 0" }, { vi: "chỉ áp dụng cho signed numbers", en: "it only applies to signed numbers" }], a: 1, explanation: { vi: "Phép dịch vòng (rotate) bảo toàn tất cả các bit bằng cách di chuyển bit bị đẩy ra từ một đầu sang đầu kia.", en: "A rotate operation preserves all bits by moving the bit that falls off one end to the other end." } },
                    { q: { vi: "Trong arithmetic right shift (two’s complement), khi shift phải, bit mới chèn vào trái là:", en: "In an arithmetic right shift (two's complement), when shifting right, the new bit inserted on the left is:" }, o: [{ vi: "0 luôn", en: "always 0" }, { vi: "bit dấu cũ (sign bit) — giữ dấu", en: "the old sign bit — preserving the sign" }, { vi: "bit ngẫu nhiên", en: "a random bit" }, { vi: "1 luôn", en: "always 1" }], a: 1, explanation: { vi: "Để giữ đúng giá trị của số âm (ví dụ, chia một số âm cho 2), bit dấu phải được sao chép vào vị trí trống bên trái.", en: "To maintain the correct value of a negative number (e.g., dividing a negative number by 2), the sign bit must be copied into the vacant leftmost position." } },
                    { q: { vi: "Overflow khi cộng hai số two's complement xảy ra khi:", en: "Overflow when adding two two's complement numbers occurs when:" }, o: [{ vi: "hai số cùng dấu và kết quả khác dấu", en: "two numbers of the same sign result in a different sign" }, { vi: "hai số khác dấu", en: "the two numbers have different signs" }, { vi: "luôn khi có carry out từ MSB", en: "always when there is a carry out from the MSB" }, { vi: "chỉ khi cả hai âm", en: "only when both are negative" }], a: 0, explanation: { vi: "Đây là quy tắc phát hiện tràn số: cộng hai số dương ra kết quả âm, hoặc cộng hai số âm ra kết quả dương.", en: "This is the rule for overflow detection: adding two positive numbers yields a negative result, or adding two negative numbers yields a positive result." } },
                    { q: { vi: "Khi cộng hai two's complement 8-bit, carry ra khỏi cột trái cùng (MSB carry) được:", en: "When adding two 8-bit two's complement numbers, the carry out of the leftmost column (MSB carry) is:" }, o: [{ vi: "giữ làm một bit của kết quả 9-bit", en: "kept as a bit of a 9-bit result" }, { vi: "bỏ (discard)", en: "discarded" }, { vi: "nhân với 2", en: "multiplied by 2" }, { vi: "chuyển sang LSB", en: "moved to the LSB" }], a: 1, explanation: { vi: "Trong phép toán số học với kích thước cố định, bit nhớ cuối cùng không phải là một phần của kết quả và bị loại bỏ.", en: "In fixed-size arithmetic, the final carry bit is not part of the result and is discarded." } },
                    { q: { vi: "Lợi thế chính của two’s complement là:", en: "The main advantage of two's complement is:" }, o: [{ vi: "cần 2 biểu diễn cho 0", en: "it needs 2 representations for 0" }, { vi: "có phép cộng và phép trừ khác nhau phức tạp", en: "it has complex and different addition and subtraction operations" }, { vi: "phép cộng và trừ xử lý giống nhau (dễ hiện thực)", en: "addition and subtraction are handled the same way (easy to implement)" }, { vi: "không thể biểu diễn số âm", en: "it cannot represent negative numbers" }], a: 2, explanation: { vi: "Việc có thể thực hiện phép trừ A-B bằng cách tính A + (bù hai của B) cho phép sử dụng cùng một mạch cộng cho cả hai phép toán, đơn giản hóa thiết kế CPU.", en: "Being able to perform subtraction A-B by calculating A + (two's complement of B) allows the same adder circuit to be used for both operations, simplifying CPU design." } },
                    { q: { vi: "Giá trị biểu diễn lớn nhất của 8-bit two’s complement là:", en: "The largest representable value of an 8-bit two's complement is:" }, o: [{ vi: "255", en: "255" }, { vi: "127", en: "127" }, { vi: "−1", en: "-1" }, { vi: "128", en: "128" }], a: 1, explanation: { vi: "Phạm vi của số bù hai n-bit là từ -2ⁿ⁻¹ đến +2ⁿ⁻¹-1. Với n=8, giá trị lớn nhất là +2⁷-1 = 127.", en: "The range of an n-bit two's complement number is from -2ⁿ⁻¹ to +2ⁿ⁻¹-1. For n=8, the maximum value is +2⁷-1 = 127." } },
                    { q: { vi: "Giá trị nhỏ nhất (most negative) của 8-bit two’s complement là:", en: "The smallest (most negative) value of an 8-bit two's complement is:" }, o: [{ vi: "−128", en: "-128" }, { vi: "−127", en: "-127" }, { vi: "0", en: "0" }, { vi: "−256", en: "-256" }], a: 0, explanation: { vi: "Phạm vi của số bù hai n-bit là từ -2ⁿ⁻¹ đến +2ⁿ⁻¹-1. Với n=8, giá trị nhỏ nhất là -2⁷ = -128.", en: "The range of an n-bit two's complement number is from -2ⁿ⁻¹ to +2ⁿ⁻¹-1. For n=8, the minimum value is -2⁷ = -128." } },
                    { q: { vi: "Một truth table mô tả:", en: "A truth table describes:" }, o: [{ vi: "cách biểu diễn số thập phân", en: "how to represent decimal numbers" }, { vi: "cách xác định output cho mọi tổ hợp input", en: "how to determine the output for all input combinations" }, { vi: "bảng mã hóa ký tự", en: "a character encoding table" }, { vi: "đồ thị liên kết", en: "a linkage graph" }], a: 1, explanation: { vi: "Một bảng chân lý (truth table) liệt kê một cách có hệ thống tất cả các kết quả đầu ra có thể có của một hàm logic cho mọi kết hợp đầu vào có thể có.", en: "A truth table systematically lists all possible outputs of a logical function for every possible combination of inputs." } },
                    { q: { vi: "Biểu thức x XOR 1 cho kết quả:", en: "The expression x XOR 1 results in:" }, o: [{ vi: "x (không đổi)", en: "x (unchanged)" }, { vi: "NOT x (lật bit)", en: "NOT x (flipped bit)" }, { vi: "1", en: "1" }, { vi: "0", en: "0" }], a: 1, explanation: { vi: "0 XOR 1 = 1 (NOT 0). 1 XOR 1 = 0 (NOT 1). Do đó, XOR với 1 luôn đảo ngược giá trị của x.", en: "0 XOR 1 = 1 (NOT 0). 1 XOR 1 = 0 (NOT 1). Therefore, XORing with 1 always inverts the value of x." } },
                    { q: { vi: "Biểu thức x OR 1 cho kết quả:", en: "The expression x OR 1 results in:" }, o: [{ vi: "1", en: "1" }, { vi: "x", en: "x" }, { vi: "NOT x", en: "NOT x" }, { vi: "0", en: "0" }], a: 0, explanation: { vi: "Bất kỳ giá trị nào OR với 1 cũng sẽ cho kết quả là 1. Đây là thuộc tính 'annihilator' của OR.", en: "Any value ORed with 1 will result in 1. This is the 'annihilator' property of OR." } },
                    { q: { vi: "Mask dùng để unset (clear) bit i (0-index LSB) phải có:", en: "A mask used to unset (clear) bit i (0-indexed from LSB) must have:" }, o: [{ vi: "1 ở bit i", en: "a 1 at bit i" }, { vi: "0 ở bit i và 1 ở các bit khác", en: "a 0 at bit i and 1s at other bits" }, { vi: "0 ở tất cả bit", en: "0s at all bits" }, { vi: "1 ở tất cả bit", en: "1s at all bits" }], a: 1, explanation: { vi: "Để unset một bit, ta dùng phép AND. AND với 0 sẽ cho kết quả là 0, trong khi AND với 1 sẽ giữ nguyên bit ban đầu.", en: "To unset a bit, we use the AND operation. ANDing with 0 results in 0, while ANDing with 1 preserves the original bit." } },
                    { q: { vi: "Mask để flip (complement) một số bit là dùng phép:", en: "A mask to flip (complement) some bits uses which operation?" }, o: [{ vi: "AND", en: "AND" }, { vi: "OR", en: "OR" }, { vi: "XOR", en: "XOR" }, { vi: "NOT", en: "NOT" }], a: 2, explanation: { vi: "Phép XOR với 1 sẽ đảo bit, trong khi XOR với 0 sẽ giữ nguyên bit. Điều này cho phép lật bit một cách có chọn lọc.", en: "XORing with 1 flips a bit, while XORing with 0 preserves it. This allows for selective bit flipping." } },
                    { q: { vi: "Dịch trái logic một pattern thường tương đương với phép toán số nguyên:", en: "A logical left shift on a pattern is often equivalent to which integer operation?" }, o: [{ vi: "chia cho 2", en: "division by 2" }, { vi: "nhân ×2 (nếu không overflow)", en: "multiplication by 2 (if no overflow)" }, { vi: "XOR với 2", en: "XOR with 2" }, { vi: "cộng 1", en: "adding 1" }], a: 1, explanation: { vi: "Mỗi lần dịch trái một vị trí sẽ nhân giá trị của số (không dấu) lên 2, miễn là bit quan trọng nhất không bị mất.", en: "Each left shift by one position multiplies the value of the (unsigned) number by 2, as long as the most significant bit is not lost." } },
                    { q: { vi: "Dịch phải logic một pattern unsigned tương đương với:", en: "A logical right shift on an unsigned pattern is equivalent to:" }, o: [{ vi: "nhân ×2", en: "multiplication by 2" }, { vi: "chia cho 2 (floor)", en: "division by 2 (floor)" }, { vi: "invert bits", en: "inverting bits" }, { vi: "rotate right", en: "rotating right" }], a: 1, explanation: { vi: "Mỗi lần dịch phải một vị trí sẽ chia giá trị của số không dấu cho 2, làm tròn xuống (floor division).", en: "Each right shift by one position divides the value of the unsigned number by 2, performing a floor division." } },
                    { q: { vi: "Trong floating-point addition, bước quan trọng để thực hiện phép cộng là:", en: "In floating-point addition, what is the crucial step to perform the addition?" }, o: [{ vi: "đổi sang two’s complement trước", en: "converting to two's complement first" }, { vi: "align (căn) các exponent trước khi cộng mantissa", en: "aligning the exponents before adding the mantissas" }, { vi: "dùng XOR để cộng mantissa", en: "using XOR to add the mantissas" }, { vi: "swap bits", en: "swapping bits" }], a: 1, explanation: { vi: "Không thể cộng trực tiếp các phần định trị (mantissa) trừ khi các số mũ (exponent) của chúng bằng nhau. Do đó, cần phải dịch chuyển một trong các mantissa để làm cho các số mũ khớp nhau.", en: "The mantissas cannot be added directly unless their exponents are equal. Therefore, one of the mantissas must be shifted to make the exponents match." } },
                    { q: { vi: "Phép toán để kiểm tra “bit i có 1 hay không” thường là:", en: "The operation to check 'if bit i is 1' is usually:" }, o: [{ vi: "shift phải i lần rồi AND với 1", en: "shift right i times then AND with 1" }, { vi: "shift trái i lần rồi AND với 1", en: "shift left i times then AND with 1" }, { vi: "OR với 1 rồi so sánh", en: "OR with 1 and then compare" }, { vi: "XOR với 1 rồi so sánh", en: "XOR with 1 and then compare" }], a: 0, explanation: { vi: "Đây là một kỹ thuật phổ biến: dịch chuyển bit cần kiểm tra đến vị trí cuối cùng (LSB), sau đó dùng mask '1' để cô lập nó. Nếu kết quả khác không, bit đó là 1.", en: "This is a common technique: shift the bit to be tested to the last position (LSB), then use a mask of '1' to isolate it. If the result is non-zero, the bit was 1." } },
                    { q: { vi: "“Arithmetic shift” và “logical shift” khác nhau chủ yếu ở việc:", en: "'Arithmetic shift' and 'logical shift' differ mainly in that:" }, o: [{ vi: "arithmetic chèn sign bit khi shift phải", en: "arithmetic inserts the sign bit when shifting right" }, { vi: "logical chèn sign bit khi shift phải", en: "logical inserts the sign bit when shifting right" }, { vi: "arithmetic chỉ dùng cho rotate", en: "arithmetic is only for rotation" }, { vi: "không khác nhau", en: "there is no difference" }], a: 0, explanation: { vi: "Sự khác biệt cốt lõi là cách xử lý bit được chèn vào khi dịch phải. Dịch số học (arithmetic) bảo toàn bit dấu, trong khi dịch logic luôn chèn 0.", en: "The core difference is how the inserted bit is handled on a right shift. Arithmetic shift preserves the sign bit, while logical shift always inserts a 0." } },
                    { q: { vi: "Nếu x OR (NOT x) cho kết quả:", en: "If x OR (NOT x), the result is:" }, o: [{ vi: "0", en: "0" }, { vi: "1 (all 1s tại mọi bit)", en: "1 (all 1s at every bit)" }, { vi: "x", en: "x" }, { vi: "NOT x", en: "NOT x" }], a: 1, explanation: { vi: "Tại mỗi vị trí bit, một trong hai toán hạng (x hoặc NOT x) phải là 1. Do đó, kết quả của phép OR sẽ luôn là 1 ở mọi vị trí.", en: "At every bit position, one of the two operands (x or NOT x) must be 1. Therefore, the result of the OR operation will always be 1 at every position." } },
                    { q: { vi: "Nếu x AND (NOT x) luôn cho:", en: "If x AND (NOT x), the result is always:" }, o: [{ vi: "all 1s", en: "all 1s" }, { vi: "all 0s", en: "all 0s" }, { vi: "x", en: "x" }, { vi: "NOT x", en: "NOT x" }], a: 1, explanation: { vi: "Tại mỗi vị trí bit, nếu bit của x là 1, bit của NOT x là 0, và ngược lại. Do đó, không có vị trí nào cả hai bit đều là 1, nên kết quả là 0 ở mọi vị trí.", en: "At every bit position, if the bit of x is 1, the bit of NOT x is 0, and vice-versa. Therefore, at no position are both bits 1, so the result is 0 at every position." } }
                ]
            },
            chapter5: {
                 theory: {
                    vi: `
                        <h2>Chương 5: Tổ chức Máy tính</h2>
                        <h3>1. Các thành phần chính</h3>
                        <ul>
                            <li><strong>CPU (Central Processing Unit):</strong> "Bộ não" của máy tính. Gồm 3 phần: ALU (tính toán), Control Unit (điều khiển), và Registers (thanh ghi).</li>
                            <li><strong>Bộ nhớ chính (Main Memory):</strong> Thường là RAM, lưu trữ chương trình và dữ liệu đang chạy.</li>
                            <li><strong>Hệ thống Vào/Ra (I/O Subsystem):</strong> Gồm các thiết bị ngoại vi (bàn phím, màn hình, ổ cứng) và các bộ điều khiển (controllers) để giao tiếp với chúng.</li>
                        </ul>
                        <h3>2. Kết nối các thành phần</h3>
                        <ul>
                            <li><strong>Bus hệ thống (System Bus):</strong> Là một tập hợp các đường dây điện tử kết nối CPU, bộ nhớ và hệ thống I/O, cho phép chúng trao đổi thông tin. Gồm 3 loại bus con:
                                <ol>
                                    <li><strong>Address Bus:</strong> Mang địa chỉ của ô nhớ hoặc thiết bị I/O mà CPU muốn truy cập.</li>
                                    <li><strong>Data Bus:</strong> Mang dữ liệu thực tế được truyền qua lại.</li>
                                    <li><strong>Control Bus:</strong> Mang các tín hiệu điều khiển (ví dụ: đọc hay ghi) để điều phối hoạt động.</li>
                                </ol>
                            </li>
                        </ul>
                        <h3>3. Phân cấp bộ nhớ (Memory Hierarchy)</h3>
                        <p>Một hệ thống gồm nhiều loại bộ nhớ khác nhau, được sắp xếp theo tốc độ và giá thành. Tốc độ và giá/bit giảm dần, trong khi dung lượng tăng dần:</p>
                        <p><span class="highlight">Registers → Cache → Main Memory (RAM) → Magnetic Disk (Ổ cứng) → Magnetic Tape</span></p>
                        <h3>4. Chu kỳ máy (Machine Cycle)</h3>
                        <ul>
                             <li>Là quá trình lặp đi lặp lại mà CPU dùng để thực thi một lệnh. Gồm 3 bước cơ bản:
                                <ol>
                                    <li><span class="highlight">Fetch (Nạp lệnh):</span> Đơn vị điều khiển lấy lệnh từ bộ nhớ (tại địa chỉ do Program Counter chỉ định).</li>
                                    <li><span class="highlight">Decode (Giải mã):</span> Lệnh được giải mã để xác định thao tác cần thực hiện.</li>
                                    <li><span class="highlight">Execute (Thực thi):</span> ALU hoặc các thành phần khác thực hiện lệnh đã giải mã.</li>
                                </ol>
                            </li>
                        </ul>
                        <h3>5. Các kiến trúc CPU</h3>
                        <ul>
                            <li><strong>CISC (Complex Instruction Set Computer):</strong> Có một tập lệnh lớn và phức tạp. Một lệnh có thể thực hiện nhiều thao tác cấp thấp.</li>
                            <li><strong>RISC (Reduced Instruction Set Computer):</strong> Có một tập lệnh nhỏ, được tối ưu hóa. Mỗi lệnh thực hiện một thao tác đơn giản và rất nhanh.</li>
                            <li><strong>Pipelining:</strong> Kỹ thuật cho phép CPU xử lý gối đầu các giai đoạn của nhiều lệnh cùng lúc (giống dây chuyền lắp ráp), làm tăng thông lượng (throughput).</li>
                        </ul>
                    `,
                    en: `
                        <h2>Chapter 5: Computer Organization</h2>
                        <h3>1. Main Components</h3>
                        <ul>
                           <li><strong>CPU (Central Processing Unit):</strong> The "brain" of the computer. Contains 3 parts: ALU (calculation), Control Unit (control), and Registers.</li>
                            <li><strong>Main Memory:</strong> Usually RAM, stores currently running programs and data.</li>
                            <li><strong>I/O Subsystem:</strong> Consists of peripheral devices (keyboard, monitor, hard drive) and their controllers for communication.</li>
                        </ul>
                        <h3>2. Connecting Components</h3>
                        <ul>
                            <li><strong>System Bus:</strong> A set of electronic pathways connecting the CPU, memory, and I/O subsystem, allowing them to exchange information. It comprises 3 sub-buses:
                                <ol>
                                    <li><strong>Address Bus:</strong> Carries the address of the memory location or I/O device the CPU wants to access.</li>
                                    <li><strong>Data Bus:</strong> Carries the actual data being transferred.</li>
                                    <li><strong>Control Bus:</strong> Carries control signals (e.g., read or write) to coordinate activities.</li>
                                </ol>
                            </li>
                        </ul>
                        <h3>3. Memory Hierarchy</h3>
                        <p>A system of different types of memory, organized by speed and cost. Speed and cost/bit decrease, while capacity increases:</p>
                        <p><span class="highlight">Registers → Cache → Main Memory (RAM) → Magnetic Disk → Magnetic Tape</span></p>
                        <h3>4. Machine Cycle</h3>
                        <ul>
                             <li>The repetitive process by which the CPU executes one instruction. Consists of 3 basic steps:
                                <ol>
                                    <li><span class="highlight">Fetch:</span> The control unit retrieves an instruction from memory (at the address pointed to by the Program Counter).</li>
                                    <li><span class="highlight">Decode:</span> The instruction is decoded to determine the required operation.</li>
                                    <li><span class="highlight">Execute:</span> The ALU or other components perform the decoded instruction.</li>
                                </ol>
                            </li>
                        </ul>
                        <h3>5. CPU Architectures</h3>
                        <ul>
                            <li><strong>CISC (Complex Instruction Set Computer):</strong> Has a large and complex instruction set. One instruction can perform multiple low-level operations.</li>
                            <li><strong>RISC (Reduced Instruction Set Computer):</strong> Has a small, optimized instruction set. Each instruction performs a simple and very fast operation.</li>
                            <li><strong>Pipelining:</strong> A technique that allows the CPU to overlap the stages of multiple instructions simultaneously (like an assembly line), increasing throughput.</li>
                        </ul>
                    `
                },
                questions: [
                    { q: { vi: "Máy tính gồm mấy hệ thống con chính?", en: "How many main subsystems does a computer consist of?" }, o: [{ vi: "2 — CPU và Memory", en: "2 — CPU and Memory" }, { vi: "3 — CPU, Main memory, I/O subsystem", en: "3 — CPU, Main memory, I/O subsystem" }, { vi: "4 — CPU, Memory, I/O, GPU", en: "4 — CPU, Memory, I/O, GPU" }, { vi: "5 — CPU, Memory, I/O, Cache, Bus", en: "5 — CPU, Memory, I/O, Cache, Bus" }], a: 1, explanation: { vi: "Theo mô hình đơn giản hóa, máy tính có 3 thành phần chính: CPU để xử lý, Main Memory để lưu trữ tạm thời, và I/O Subsystem để giao tiếp.", en: "According to the simplified model, a computer has 3 main components: the CPU for processing, Main Memory for temporary storage, and the I/O Subsystem for communication." } },
                    { q: { vi: "CPU thường gồm những thành phần nào?", en: "What components does a CPU typically consist of?" }, o: [{ vi: "ALU, Control unit, Registers", en: "ALU, Control unit, Registers" }, { vi: "ALU, Hard drive, Network card", en: "ALU, Hard drive, Network card" }, { vi: "Cache, Disk controller, Monitor", en: "Cache, Disk controller, Monitor" }, { vi: "Keyboard, Mouse, Printer", en: "Keyboard, Mouse, Printer" }], a: 0, explanation: { vi: "CPU có ba khối chức năng cốt lõi: ALU (tính toán), Control Unit (điều khiển), và Registers (lưu trữ siêu nhanh).", en: "The CPU has three core functional blocks: the ALU (arithmetic/logic), the Control Unit (coordination), and Registers (super-fast storage)." } },
                    { q: { vi: "Chức năng chính của Program Counter (PC) là gì?", en: "What is the main function of the Program Counter (PC)?" }, o: [{ vi: "Lưu dữ liệu tạm thời", en: "To store temporary data" }, { vi: "Giữ địa chỉ lệnh tiếp theo cần thực thi", en: "To hold the address of the next instruction to be executed" }, { vi: "Thực hiện phép toán số học", en: "To perform arithmetic operations" }, { vi: "Điều khiển tốc độ bus", en: "To control the bus speed" }], a: 1, explanation: { vi: "PC luôn trỏ đến lệnh tiếp theo trong bộ nhớ, cho phép CPU thực thi chương trình một cách tuần tự.", en: "The PC always points to the next instruction in memory, allowing the CPU to execute a program sequentially." } },
                    { q: { vi: "Instruction Register (IR) dùng để làm gì?", en: "What is the Instruction Register (IR) used for?" }, o: [{ vi: "Lưu toàn bộ chương trình", en: "To store the entire program" }, { vi: "Lưu lệnh hiện đang được thực thi (mã lệnh)", en: "To store the instruction currently being executed (opcode)" }, { vi: "Tăng/giảm giá trị của thanh ghi", en: "To increment/decrement the value of a register" }, { vi: "Kết nối I/O với bộ nhớ", en: "To connect I/O with memory" }], a: 1, explanation: { vi: "Sau khi lệnh được nạp (fetch) từ bộ nhớ, nó được đặt vào IR để Control Unit có thể giải mã và thực thi.", en: "After an instruction is fetched from memory, it is placed in the IR so the Control Unit can decode and execute it." } },
                    { q: { vi: "ALU không thực hiện tác vụ nào dưới đây?", en: "Which of the following tasks is NOT performed by the ALU?" }, o: [{ vi: "Toán học (cộng, trừ)", en: "Arithmetic (add, subtract)" }, { vi: "Phép logic (AND, OR, NOT)", en: "Logic operations (AND, OR, NOT)" }, { vi: "Ghi/đọc đĩa cứng (disk I/O)", en: "Reading/writing to the hard disk (disk I/O)" }, { vi: "Dịch bit (shift, rotate)", en: "Bit shifting (shift, rotate)" }], a: 2, explanation: { vi: "ALU là đơn vị tính toán và logic. Việc giao tiếp với thiết bị lưu trữ như đĩa cứng là nhiệm vụ của I/O subsystem và controllers.", en: "The ALU is the arithmetic and logic unit. Communicating with storage devices like hard disks is the job of the I/O subsystem and controllers." } },
                    { q: { vi: "Data bus có nhiệm vụ gì chính?", en: "What is the main task of the data bus?" }, o: [{ vi: "Mang địa chỉ bộ nhớ", en: "To carry memory addresses" }, { vi: "Mang dữ liệu giữa CPU và bộ nhớ", en: "To carry data between the CPU and memory" }, { vi: "Mang tín hiệu điều khiển (read/write)", en: "To carry control signals (read/write)" }, { vi: "Mang tín hiệu đồng hồ (clock)", en: "To carry clock signals" }], a: 1, explanation: { vi: "Đúng như tên gọi, data bus là con đường để di chuyển dữ liệu thực tế (các bit của chương trình hoặc dữ liệu) qua lại.", en: "As its name implies, the data bus is the pathway for moving the actual data (the bits of a program or data) back and forth." } },
                    { q: { vi: "Nếu bộ nhớ có 2^n words thì address bus cần bao nhiêu dây?", en: "If a memory has 2^n words, how many wires does the address bus need?" }, o: [{ vi: "n/2 dây", en: "n/2 wires" }, { vi: "2^n dây", en: "2^n wires" }, { vi: "n dây", en: "n wires" }, { vi: "1 dây", en: "1 wire" }], a: 2, explanation: { vi: "Để có thể định danh duy nhất 2^n vị trí khác nhau, bạn cần n bit địa chỉ. Mỗi bit cần một dây dẫn.", en: "To uniquely identify 2^n different locations, you need n bits of address. Each bit requires one wire." } },
                    { q: { vi: "Control bus dùng để:", en: "The control bus is used to:" }, o: [{ vi: "Truyền dữ liệu 8 bit mỗi lần", en: "Transmit 8 bits of data at a time" }, { vi: "Gửi các tín hiệu điều khiển như read/write, interrupts", en: "Send control signals like read/write, interrupts" }, { vi: "Chứa địa chỉ của thiết bị I/O", en: "Contain the address of an I/O device" }, { vi: "Lưu chương trình tạm thời", en: "Store a program temporarily" }], a: 1, explanation: { vi: "Control bus điều phối hoạt động của hệ thống, mang các tín hiệu như 'bộ nhớ đọc', 'bộ nhớ ghi', 'thiết bị I/O đã sẵn sàng', v.v.", en: "The control bus coordinates the system's activities, carrying signals like 'memory read', 'memory write', 'I/O device is ready', etc." } },
                    { q: { vi: "Trong hệ thống phân cấp bộ nhớ, thành phần nào nhanh nhất nhưng đắt nhất?", en: "In the memory hierarchy, which component is the fastest but also the most expensive?" }, o: [{ vi: "Main memory", en: "Main memory" }, { vi: "Cache", en: "Cache" }, { vi: "Registers (thanh ghi)", en: "Registers" }, { vi: "Disk", en: "Disk" }], a: 2, explanation: { vi: "Thanh ghi (registers) nằm ngay bên trong lõi CPU, được làm từ công nghệ nhanh nhất (và đắt nhất), do đó có tốc độ truy cập gần như tức thời.", en: "Registers are located right inside the CPU core, made from the fastest (and most expensive) technology, giving them near-instant access speeds." } },
                    { q: { vi: "Đâu là nhiệm vụ chính của address bus?", en: "What is the main task of the address bus?" }, o: [{ vi: "Chỉ ra địa chỉ ô nhớ cần truy xuất", en: "To specify the address of the memory location to be accessed" }, { vi: "Truyền dữ liệu giữa CPU và I/O", en: "To transfer data between the CPU and I/O" }, { vi: "Thực hiện phép cộng nhị phân", en: "To perform binary addition" }, { vi: "Điều khiển tốc độ quạt CPU", en: "To control the CPU fan speed" }], a: 0, explanation: { vi: "Address bus chỉ có một chiều (từ CPU ra ngoài) và mang địa chỉ của ô nhớ hoặc cổng I/O mà CPU muốn tương tác.", en: "The address bus is unidirectional (from the CPU outwards) and carries the address of the memory location or I/O port that the CPU wants to interact with." } },
                    { q: { vi: "Điểm khác nhau cơ bản giữa RAM và ROM là gì?", en: "What is the fundamental difference between RAM and ROM?" }, o: [{ vi: "RAM chỉ đọc, ROM đọc/ghi", en: "RAM is read-only, ROM is read/write" }, { vi: "RAM volatile (mất khi tắt), ROM non-volatile", en: "RAM is volatile (lost on power-off), ROM is non-volatile" }, { vi: "RAM là thiết bị lưu trữ lâu dài, ROM là bộ nhớ tạm thời", en: "RAM is long-term storage, ROM is temporary memory" }, { vi: "RAM chỉ dùng cho I/O, ROM chỉ dùng cho CPU", en: "RAM is only for I/O, ROM is only for the CPU" }], a: 1, explanation: { vi: "Volatile (khả biến) là đặc tính quan trọng nhất. Dữ liệu trong RAM biến mất khi mất điện, trong khi dữ liệu trong ROM (như firmware BIOS) vẫn còn.", en: "Volatility is the most important characteristic. Data in RAM vanishes when power is lost, while data in ROM (like BIOS firmware) persists." } },
                    { q: { vi: "SRAM khác DRAM ở chỗ nào?", en: "How does SRAM differ from DRAM?" }, o: [{ vi: "SRAM dùng tụ điện, DRAM dùng flip-flop", en: "SRAM uses capacitors, DRAM uses flip-flops" }, { vi: "SRAM cần refresh định kỳ, DRAM không cần", en: "SRAM needs periodic refreshing, DRAM does not" }, { vi: "SRAM dùng flip-flop (không cần refresh) và nhanh hơn; DRAM dùng capacitor (cần refresh) và rẻ hơn", en: "SRAM uses flip-flops (no refresh needed) and is faster; DRAM uses capacitors (needs refresh) and is cheaper" }, { vi: "SRAM là lưu trữ ngoài, DRAM là trong CPU", en: "SRAM is external storage, DRAM is in the CPU" }], a: 2, explanation: { vi: "SRAM (Static RAM) dùng mạch flip-flop để giữ bit, nhanh nhưng tốn diện tích và đắt. DRAM (Dynamic RAM) dùng tụ điện, cần được làm tươi (refresh) liên tục, chậm hơn nhưng rẻ và có mật độ cao hơn.", en: "SRAM (Static RAM) uses flip-flop circuits to hold a bit, which is fast but bulky and expensive. DRAM (Dynamic RAM) uses a capacitor, needs constant refreshing, is slower, but is cheaper and denser." } },
                    { q: { vi: "EEPROM khác EPROM ở điểm nào?", en: "How does EEPROM differ from EPROM?" }, o: [{ vi: "EEPROM không thể xóa, EPROM có thể xóa điện tử", en: "EEPROM cannot be erased, EPROM can be erased electronically" }, { vi: "EPROM xóa bằng ánh sáng UV; EEPROM có thể xóa bằng xung điện mà không tháo IC ra", en: "EPROM is erased by UV light; EEPROM can be erased by an electrical pulse without removing the IC" }, { vi: "EEPROM chỉ đọc, EPROM đọc/ghi", en: "EEPROM is read-only, EPROM is read/write" }, { vi: "Không khác nhau", en: "There is no difference" }], a: 1, explanation: { vi: "EPROM (Erasable PROM) cần tháo ra và chiếu tia cực tím để xóa. EEPROM (Electrically Erasable PROM) tiện lợi hơn nhiều vì nó có thể được xóa và lập trình lại bằng điện ngay trên bo mạch.", en: "EPROM (Erasable PROM) needs to be removed and exposed to UV light for erasure. EEPROM (Electrically Erasable PROM) is much more convenient as it can be erased and reprogrammed electrically while still on the circuit board." } },
                    { q: { vi: "Một máy có bộ nhớ 32 MB (byte-addressable). Cần bao nhiêu bit để địa chỉ từng byte?", en: "A machine has 32 MB of byte-addressable memory. How many bits are needed to address each byte?" }, o: [{ vi: "20 bit", en: "20 bits" }, { vi: "24 bit", en: "24 bits" }, { vi: "25 bit", en: "25 bits" }, { vi: "32 bit", en: "32 bits" }], a: 2, explanation: { vi: "32 MB = 32 * 2^20 bytes = 2^5 * 2^20 bytes = 2^25 bytes. Do đó, cần 25 bit để địa chỉ 2^25 byte khác nhau.", en: "32 MB = 32 * 2^20 bytes = 2^5 * 2^20 bytes = 2^25 bytes. Therefore, 25 bits are needed to address 2^25 different bytes." } },
                    { q: { vi: "Máy có 128 MB bộ nhớ, mỗi từ (word) dài 8 bytes. Cần bao nhiêu bit để địa chỉ mỗi word?", en: "A machine has 128 MB of memory, and each word is 8 bytes. How many bits are needed to address each word?" }, o: [{ vi: "21 bit", en: "21 bits" }, { vi: "24 bit", en: "24 bits" }, { vi: "27 bit", en: "27 bits" }, { vi: "30 bit", en: "30 bits" }], a: 1, explanation: { vi: "Tổng số byte = 128 MB = 2^7 * 2^20 = 2^27 bytes. Số lượng từ = (Tổng số byte) / (Số byte mỗi từ) = 2^27 / 8 = 2^27 / 2^3 = 2^24 từ. Cần 24 bit để địa chỉ 2^24 từ.", en: "Total bytes = 128 MB = 2^7 * 2^20 = 2^27 bytes. Number of words = (Total bytes) / (Bytes per word) = 2^27 / 8 = 2^27 / 2^3 = 2^24 words. 24 bits are needed to address 2^24 words." } },
                    { q: { vi: "Cache thường đặt ở đâu trong hệ thống bộ nhớ?", en: "Where is the cache typically placed in the memory system?" }, o: [{ vi: "Sau ổ cứng", en: "After the hard disk" }, { vi: "Giữa CPU và main memory", en: "Between the CPU and main memory" }, { vi: "Trước keyboard", en: "Before the keyboard" }, { vi: "Bên ngoài hệ thống I/O", en: "Outside the I/O system" }], a: 1, explanation: { vi: "Cache đóng vai trò là bộ đệm tốc độ cao giữa CPU cực nhanh và main memory (RAM) chậm hơn đáng kể.", en: "The cache acts as a high-speed buffer between the extremely fast CPU and the significantly slower main memory (RAM)." } },
                    { q: { vi: "Khi CPU cần truy xuất một từ ở main memory, trình tự đúng là:", en: "When the CPU needs to access a word in main memory, the correct sequence is:" }, o: [{ vi: "Truy cập main memory trực tiếp", en: "Access main memory directly" }, { vi: "Kiểm tra cache; nếu có thì lấy, nếu không thì đọc block từ main memory vào cache rồi lấy", en: "Check the cache; if present (hit), get it. If not (miss), read a block from main memory into the cache, then get it." }, { vi: "Gửi lệnh cho I/O controller", en: "Send a command to the I/O controller" }, { vi: "Dừng CPU và chờ interrupt", en: "Halt the CPU and wait for an interrupt" }], a: 1, explanation: { vi: "Đây là nguyên tắc hoạt động cơ bản của cache. Luôn kiểm tra cache trước. Nếu 'cache miss', mới phải truy cập main memory chậm hơn.", en: "This is the fundamental principle of cache operation. Always check the cache first. A 'cache miss' necessitates an access to the slower main memory." } },
                    { q: { vi: "“80–20 rule” trong ngữ cảnh cache ám chỉ gì?", en: "What does the '80-20 rule' imply in the context of a cache?" }, o: [{ vi: "80% dữ liệu lưu trữ ở 20% địa chỉ của disk", en: "80% of data is stored in 20% of the disk's addresses" }, { vi: "80% thời gian CPU truy cập 20% dữ liệu — cache giữ vùng 20% đó để tăng tốc ~80% thời gian", en: "80% of the time, the CPU accesses 20% of the data — the cache holds that 20% region to speed up ~80% of accesses" }, { vi: "Cache chiếm 80% bộ nhớ chính", en: "The cache takes up 80% of the main memory" }, { vi: "20% bộ nhớ là non-volatile", en: "20% of the memory is non-volatile" }], a: 1, explanation: { vi: "Quy tắc này là một cách diễn đạt của nguyên lý cục bộ (locality principle). Hầu hết các chương trình dành phần lớn thời gian hoạt động trên một phần nhỏ mã và dữ liệu. Cache tận dụng điều này bằng cách lưu trữ phần nhỏ đó.", en: "This rule is an expression of the locality principle. Most programs spend most of their time in a small fraction of their code and data. The cache exploits this by storing that small fraction." } },
                    { q: { vi: "So sánh tốc độ: registers, cache, main memory, disk — thứ tự nào đúng từ nhanh nhất đến chậm nhất?", en: "Compare the speeds: registers, cache, main memory, disk — which order is correct from fastest to slowest?" }, o: [{ vi: "Disk → Main memory → Cache → Registers", en: "Disk → Main memory → Cache → Registers" }, { vi: "Registers → Cache → Main memory → Disk", en: "Registers → Cache → Main memory → Disk" }, { vi: "Cache → Registers → Disk → Main memory", en: "Cache → Registers → Disk → Main memory" }, { vi: "Main memory → Cache → Registers → Disk", en: "Main memory → Cache → Registers → Disk" }], a: 1, explanation: { vi: "Đây là hệ thống phân cấp bộ nhớ. Tốc độ giảm dần và dung lượng tăng dần khi di chuyển ra xa CPU: Registers (trong CPU) > Cache (gần CPU) > Main Memory (RAM) > Disk (lưu trữ).", en: "This is the memory hierarchy. Speed decreases and capacity increases as you move away from the CPU: Registers (in CPU) > Cache (near CPU) > Main Memory (RAM) > Disk (storage)." } },
                    { q: { vi: "Tại sao cache thường tải cả một block chứ không chỉ một từ?", en: "Why does a cache typically load an entire block, not just one word?" }, o: [{ vi: "Vì công nghệ không thể truyền single byte", en: "Because the technology cannot transfer a single byte" }, { vi: "Do tính cục bộ không gian/thời gian (locality): có khả năng truy cập tiếp những từ gần đó → tiết kiệm truy xuất main memory", en: "Due to spatial/temporal locality: it's likely that nearby words will be accessed soon → saves main memory accesses" }, { vi: "Để tăng kích thước cache vật lý", en: "To increase the physical cache size" }, { vi: "Để giảm số thanh ghi CPU", en: "To reduce the number of CPU registers" }], a: 1, explanation: { vi: "Nguyên lý cục bộ không gian (spatial locality) cho rằng nếu bạn truy cập một địa chỉ, rất có thể bạn sẽ sớm truy cập các địa chỉ lân cận. Tải cả một khối (block) sẽ nạp sẵn các dữ liệu này vào cache.", en: "The principle of spatial locality suggests that if you access one address, you are very likely to access nearby addresses soon. Loading an entire block pre-fetches this data into the cache." } },
                    { q: { vi: "Thiết bị nào sau đây là non-storage I/O device?", en: "Which of the following is a non-storage I/O device?" }, o: [{ vi: "Hard disk", en: "Hard disk" }, { vi: "CD-ROM", en: "CD-ROM" }, { vi: "Keyboard", en: "Keyboard" }, { vi: "Magnetic tape", en: "Magnetic tape" }], a: 2, explanation: { vi: "Thiết bị lưu trữ (storage) có thể giữ lại dữ liệu. Bàn phím (keyboard) chỉ truyền dữ liệu vào tại một thời điểm, nó không lưu trữ dữ liệu.", en: "A storage device can retain data. A keyboard only transmits data at a moment in time; it does not store it." } },
                    { q: { vi: "Storage devices được phân thành mấy loại chính trong chương này?", en: "Storage devices are divided into how many main categories in this chapter?" }, o: [{ vi: "1 — chỉ magnetic", en: "1 — only magnetic" }, { vi: "2 — magnetic và optical", en: "2 — magnetic and optical" }, { vi: "3 — magnetic, optical, và flash (không nhắc đến)", en: "3 — magnetic, optical, and flash (not mentioned)" }, { vi: "4 — magnetic, optical, tape, và RAM", en: "4 — magnetic, optical, tape, and RAM" }], a: 1, explanation: { vi: "Chương này tập trung vào hai công nghệ lưu trữ truyền thống: từ tính (magnetic) như đĩa cứng và băng từ, và quang học (optical) như CD/DVD.", en: "This chapter focuses on two traditional storage technologies: magnetic (like hard disks and tapes) and optical (like CDs/DVDs)." } },
                    { q: { vi: "Thiết bị lưu trữ dạng đĩa từ (magnetic disk): điểm nào đúng?", en: "Regarding magnetic disk storage devices: which point is correct?" }, o: [{ vi: "Là thiết bị truy cập tuần tự như tape", en: "It is a sequential access device like tape" }, { vi: "Mỗi mặt đĩa chia thành track và sector; truy cập là ngẫu nhiên (random) theo sector", en: "Each platter is divided into tracks and sectors; access is random by sector" }, { vi: "Không cần head để đọc/ghi", en: "It does not need a head to read/write" }, { vi: "Là bộ nhớ volatile", en: "It is volatile memory" }], a: 1, explanation: { vi: "Đĩa từ cho phép đầu đọc/ghi di chuyển trực tiếp đến bất kỳ track và sector nào, cho phép truy cập ngẫu nhiên, nhanh hơn nhiều so với truy cập tuần tự của băng từ.", en: "A magnetic disk allows the read/write head to move directly to any track and sector, enabling random access, which is much faster than the sequential access of a tape." } },
                    { q: { vi: "Magnetic tape có kiểu truy cập nào?", en: "What type of access does a magnetic tape have?" }, o: [{ vi: "Random access", en: "Random access" }, { vi: "Memory-mapped access", en: "Memory-mapped access" }, { vi: "Sequential access", en: "Sequential access" }, { vi: "Parallel access", en: "Parallel access" }], a: 2, explanation: { vi: "Giống như băng cassette, để đọc dữ liệu ở giữa, bạn phải tua qua tất cả dữ liệu ở phía trước. Đây là truy cập tuần tự (sequential).", en: "Like a cassette tape, to read data in the middle, you must wind through all the data before it. This is sequential access." } },
                    { q: { vi: "CD-ROM ghi dữ liệu bằng cách tạo:", en: "A CD-ROM stores data by creating:" }, o: [{ vi: "Tụ điện trên bề mặt", en: "Capacitors on the surface" }, { vi: "Pit (hố) và land (bề mặt) tạo độ phản xạ khác nhau đọc bằng laser", en: "Pits and lands that create different reflections read by a laser" }, { vi: "Từ hóa bề mặt bằng nam châm", en: "Magnetized areas on the surface" }, { vi: "Ghi điện áp trên đĩa kim loại", en: "Voltage levels on a metal disk" }], a: 1, explanation: { vi: "Dữ liệu trên CD được biểu diễn bằng các hố (pits) nhỏ được ép lên bề mặt. Một tia laser đọc sự khác biệt về độ phản xạ giữa các hố và bề mặt phẳng (lands) để diễn giải thành 0 và 1.", en: "Data on a CD is represented by tiny pits pressed into the surface. A laser reads the difference in reflectivity between the pits and the flat surface (lands) to interpret them as 0s and 1s." } },
                    { q: { vi: "SCSI là loại giao diện nào và yêu cầu gì đặc biệt?", en: "What type of interface is SCSI and what special requirement does it have?" }, o: [{ vi: "Serial, không cần terminator", en: "Serial, no terminator needed" }, { vi: "Parallel, daisy-chain, cả hai đầu chuỗi phải có terminator", en: "Parallel, daisy-chain, both ends of the chain must have a terminator" }, { vi: "USB, tree topology", en: "USB, tree topology" }, { vi: "FireWire, hỗ trợ hot-plug", en: "FireWire, supports hot-plugging" }], a: 1, explanation: { vi: "SCSI song song sử dụng kết nối chuỗi (daisy-chain). Để ngăn tín hiệu bị dội lại, đầu cuối của chuỗi bus phải được kết thúc bằng một điện trở gọi là terminator.", en: "Parallel SCSI uses a daisy-chain connection. To prevent signal reflections, the physical end of the bus chain must be capped with a resistor called a terminator." } },
                    { q: { vi: "FireWire (IEEE 1394) có thể kết nối tối đa bao nhiêu thiết bị theo tài liệu?", en: "According to the documentation, FireWire (IEEE 1394) can connect a maximum of how many devices?" }, o: [{ vi: "16", en: "16" }, { vi: "32", en: "32" }, { vi: "63", en: "63" }, { vi: "127", en: "127" }], a: 2, explanation: { vi: "FireWire cho phép kết nối chuỗi (daisy-chaining) lên đến 63 thiết bị.", en: "FireWire allows for the daisy-chaining of up to 63 devices." } },
                    { q: { vi: "USB-2 cho phép tối đa bao nhiêu thiết bị trên một controller (root hub)?", en: "How many devices does USB-2 allow on a single controller (root hub)?" }, o: [{ vi: "63", en: "63" }, { vi: "127", en: "127" }, { vi: "256", en: "256" }, { vi: "512", en: "512" }], a: 1, explanation: { vi: "Kiến trúc USB hỗ trợ lên đến 127 thiết bị (bao gồm cả các hub) được kết nối với một bộ điều khiển duy nhất.", en: "The USB architecture supports up to 127 devices (including hubs) connected to a single host controller." } },
                    { q: { vi: "HDMI được mô tả là:", en: "HDMI is described as:" }, o: [{ vi: "Giao diện analog cho tín hiệu âm thanh", en: "An analog interface for audio signals" }, { vi: "Giao diện digital thay thế cho các chuẩn video analog, truyền audio & video số", en: "A digital interface replacing analog video standards, transmitting digital audio & video" }, { vi: "Giao diện cho ổ cứng", en: "An interface for hard drives" }, { vi: "Giao diện cho bàn phím cơ", en: "An interface for mechanical keyboards" }], a: 1, explanation: { vi: "HDMI (High-Definition Multimedia Interface) là tiêu chuẩn hiện đại để truyền cả video và âm thanh kỹ thuật số không nén qua một cáp duy nhất.", en: "HDMI (High-Definition Multimedia Interface) is the modern standard for transmitting uncompressed digital video and audio over a single cable." } },
                    { q: { vi: "Trong số: SCSI, USB, FireWire — cái nào là giao diện song song (parallel) theo tài liệu?", en: "Among SCSI, USB, and FireWire — which is a parallel interface according to the text?" }, o: [{ vi: "USB", en: "USB" }, { vi: "FireWire", en: "FireWire" }, { vi: "SCSI", en: "SCSI" }, { vi: "HDMI", en: "HDMI" }], a: 2, explanation: { vi: "SCSI (Small Computer System Interface) truyền thống là một giao diện song song, truyền nhiều bit cùng một lúc. USB và FireWire là giao diện nối tiếp (serial).", en: "Traditional SCSI (Small Computer System Interface) is a parallel interface, transferring multiple bits at once. USB and FireWire are serial interfaces." } },
                    { q: { vi: "Phương pháp isolated I/O có đặc điểm gì?", en: "What is a characteristic of the isolated I/O method?" }, o: [{ vi: "I/O dùng cùng lệnh với truy xuất memory", en: "I/O uses the same instructions as memory access" }, { vi: "Có tập lệnh riêng cho I/O (input/output) tách biệt với lệnh memory", en: "It has a separate set of I/O instructions (input/output) distinct from memory instructions" }, { vi: "I/O không có địa chỉ", en: "I/O has no address" }, { vi: "Là cách mà ROM được truy xuất", en: "It is the way ROM is accessed" }], a: 1, explanation: { vi: "Trong isolated I/O, CPU có các lệnh đặc biệt (như IN, OUT) chỉ dành cho việc giao tiếp với các thiết bị I/O, tách biệt hoàn toàn với các lệnh đọc/ghi bộ nhớ.", en: "In isolated I/O, the CPU has special instructions (like IN, OUT) used only for communicating with I/O devices, completely separate from memory read/write instructions." } },
                    { q: { vi: "Phương pháp memory-mapped I/O là gì?", en: "What is the memory-mapped I/O method?" }, o: [{ vi: "Mỗi thanh ghi của controller được ánh xạ như một ô nhớ → dùng cùng lệnh đọc/ghi như memory", en: "Each controller register is mapped as a memory location → uses the same read/write instructions as memory" }, { vi: "I/O không bao giờ dùng bus hệ thống", en: "I/O never uses the system bus" }, { vi: "I/O luôn dùng interrupt-driven I/O", en: "I/O always uses interrupt-driven I/O" }, { vi: "Là một loại disk format", en: "It is a type of disk format" }], a: 0, explanation: { vi: "Với memory-mapped I/O, CPU không phân biệt giữa một ô nhớ và một thanh ghi của thiết bị. Nó dùng cùng các lệnh (ví dụ: LOAD, STORE) cho cả hai.", en: "With memory-mapped I/O, the CPU does not distinguish between a memory cell and a device's register. It uses the same instructions (e.g., LOAD, STORE) for both." } },
                    { q: { vi: "Một nhược điểm của memory-mapped I/O?", en: "What is a disadvantage of memory-mapped I/O?" }, o: [{ vi: "Không thể dùng DMA", en: "Cannot use DMA" }, { vi: "Cần nhiều lệnh hơn so với isolated I/O", en: "Needs more instructions than isolated I/O" }, { vi: "Chiếm 1 phần không gian địa chỉ memory cho registers → giảm dung lượng memory dùng cho dữ liệu/chương trình", en: "It occupies part of the memory address space for registers → reduces memory available for data/programs" }, { vi: "Không thể hot-plug thiết bị", en: "Cannot hot-plug devices" }], a: 2, explanation: { vi: "Vì các thanh ghi của thiết bị I/O chiếm các địa chỉ trong không gian bộ nhớ, nên các địa chỉ đó không thể được sử dụng cho RAM thực tế.", en: "Because the I/O device registers occupy addresses in the memory space, those addresses cannot be used for actual RAM." } },
                    { q: { vi: "Ví dụ minh họa isolated I/O: để đọc từ thiết bị có địa chỉ 101, lệnh nào hợp lý?", en: "Illustrating isolated I/O: to read from a device with address 101, which instruction is appropriate?" }, o: [{ vi: "READ 101 (chỉ dành cho memory)", en: "READ 101 (only for memory)" }, { vi: "INPUT 101 (lệnh I/O riêng)", en: "INPUT 101 (a separate I/O instruction)" }, { vi: "STORE 101", en: "STORE 101" }, { vi: "JUMP 101", en: "JUMP 101" }], a: 1, explanation: { vi: "Lệnh INPUT là một ví dụ về một lệnh dành riêng cho I/O, tách biệt với các lệnh truy cập bộ nhớ như READ hoặc LOAD.", en: "The INPUT instruction is an example of a dedicated I/O command, separate from memory access instructions like READ or LOAD." } },
                    { q: { vi: "Ưu điểm của memory-mapped I/O là:", en: "An advantage of memory-mapped I/O is:" }, o: [{ vi: "Số lượng instructions giảm do có thể dùng chung lệnh memory cho I/O", en: "The number of instructions is reduced as memory instructions can be used for I/O" }, { vi: "Không cần controller cho I/O", en: "No controller is needed for I/O" }, { vi: "Không cần bus dữ liệu", en: "No data bus is needed" }, { vi: "Tốc độ luôn nhanh hơn isolated I/O", en: "It is always faster than isolated I/O" }], a: 0, explanation: { vi: "Bằng cách cho phép tất cả các lệnh thao tác bộ nhớ cũng hoạt động trên các thiết bị I/O, nó làm cho tập lệnh của CPU đơn giản hơn và lập trình linh hoạt hơn.", en: "By allowing all memory-manipulation instructions to also work on I/O devices, it makes the CPU's instruction set simpler and programming more flexible." } },
                    { q: { vi: "Máy thực hiện một chu kỳ (machine cycle) gồm những pha cơ bản nào?", en: "A machine performs a cycle (machine cycle) consisting of which basic phases?" }, o: [{ vi: "Read → Write → Store", en: "Read → Write → Store" }, { vi: "Fetch → Decode → Execute", en: "Fetch → Decode → Execute" }, { vi: "Input → Output → Transfer", en: "Input → Output → Transfer" }, { vi: "Start → Stop → Reset", en: "Start → Stop → Reset" }], a: 1, explanation: { vi: "Đây là 3 bước lặp đi lặp lại cốt lõi của CPU: Lấy lệnh từ bộ nhớ (Fetch), hiểu lệnh đó là gì (Decode), và thực hiện hành động được yêu cầu (Execute).", en: "These are the 3 core repetitive steps of the CPU: Get an instruction from memory (Fetch), understand what it is (Decode), and perform the requested action (Execute)." } },
                    { q: { vi: "Trong programmed I/O, CPU làm gì khi gặp lệnh I/O?", en: "In programmed I/O, what does the CPU do when it encounters an I/O instruction?" }, o: [{ vi: "Gửi interrupt và làm việc khác", en: "Sends an interrupt and does other work" }, { vi: "Đợi/poll liên tục trạng thái thiết bị → CPU bị chặn (busy-wait)", en: "Waits/polls the device status continuously → the CPU is blocked (busy-wait)" }, { vi: "Dùng DMA ngay lập tức", en: "Uses DMA immediately" }, { vi: "Tự động bỏ qua lệnh I/O", en: "Automatically skips the I/O instruction" }], a: 1, explanation: { vi: "Programmed I/O là phương pháp đơn giản nhất nhưng kém hiệu quả nhất. CPU bị kẹt trong một vòng lặp, liên tục hỏi 'Xong chưa?', không thể làm việc khác.", en: "Programmed I/O is the simplest but least efficient method. The CPU gets stuck in a loop, constantly asking 'Are you done yet?', unable to do other work." } },
                    { q: { vi: "Trong interrupt-driven I/O, điều gì xảy ra?", en: "In interrupt-driven I/O, what happens?" }, o: [{ vi: "Thiết bị gửi interrupt khi sẵn sàng, CPU có thể làm việc khác trong lúc chờ", en: "The device sends an interrupt when ready, the CPU can do other work while waiting" }, { vi: "CPU phải poll thường xuyên thiết bị", en: "The CPU must poll the device frequently" }, { vi: "Không có giao tiếp DMA", en: "There is no DMA communication" }, { vi: "CPU dừng hoàn toàn cho đến khi xong I/O", en: "The CPU halts completely until I/O is finished" }], a: 0, explanation: { vi: "Đây là một cải tiến lớn. CPU ra lệnh cho thiết bị và đi làm việc khác. Khi thiết bị hoàn thành, nó sẽ 'ngắt' (interrupt) CPU để báo hiệu.", en: "This is a major improvement. The CPU commands the device and goes off to do other work. When the device is finished, it 'interrupts' the CPU to signal completion." } },
                    { q: { vi: "Direct Memory Access (DMA) có tác dụng gì?", en: "What is the purpose of Direct Memory Access (DMA)?" }, o: [{ vi: "Chuyển khối dữ liệu lớn trực tiếp giữa I/O và memory mà không qua CPU (hoặc chỉ qua mức tối thiểu)", en: "To transfer large blocks of data directly between I/O and memory without CPU intervention (or with minimal intervention)" }, { vi: "Thay thế cache hoàn toàn", en: "To completely replace the cache" }, { vi: "Là một loại controller cho keyboard", en: "It is a type of controller for the keyboard" }, { vi: "Chỉ dùng cho CD-ROM", en: "It is only used for CD-ROMs" }], a: 0, explanation: { vi: "DMA giải phóng CPU khỏi công việc truyền dữ liệu tẻ nhạt. CPU chỉ cần khởi tạo việc truyền, và bộ điều khiển DMA sẽ tự xử lý, cho phép CPU làm những việc hữu ích hơn.", en: "DMA frees the CPU from the tedious job of data transfer. The CPU only needs to initiate the transfer, and the DMA controller handles it, allowing the CPU to do more useful work." } },
                    { q: { vi: "Khi DMA thực hiện truyền khối dữ liệu, CPU:", en: "When DMA performs a block data transfer, the CPU:" }, o: [{ vi: "Bận hoàn toàn và không làm gì khác", en: "Is completely busy and does nothing else" }, { vi: "Luôn phải chờ cho đến khi DMA xong mới tiếp tục", en: "Must always wait until DMA is finished to continue" }, { vi: "Thường chỉ nhường bus trong thời gian ngắn (CPU tạm dừng dùng bus), còn có thể làm các công việc khác không cần bus", en: "Usually only yields the bus for short periods (cycle stealing), and can do other work that doesn't require the bus" }, { vi: "Phải xử lý từng byte một bằng polling", en: "Must process each byte via polling" }], a: 2, explanation: { vi: "DMA và CPU chia sẻ bus. DMA 'đánh cắp' các chu kỳ bus từ CPU để truyền dữ liệu. Trong thời gian đó, CPU vẫn có thể thực hiện các lệnh không cần truy cập bộ nhớ (ví dụ: các phép toán trên thanh ghi).", en: "DMA and the CPU share the bus. DMA 'steals' bus cycles from the CPU to transfer data. During that time, the CPU can still execute instructions that don't require memory access (e.g., operations on registers)." } },
                    { q: { vi: "Đặc trưng chính của CISC là gì?", en: "What is the main characteristic of CISC?" }, o: [{ vi: "Tập lệnh nhỏ, đơn giản, thực thi nhanh từng lệnh", en: "A small, simple instruction set, with fast execution for each instruction" }, { vi: "Tập lệnh phức tạp, nhiều chức năng — dùng microprogramming để phân giải thành micro-operations", en: "A complex instruction set with many functions — using microprogramming to resolve into micro-operations" }, { vi: "Không có ALU", en: "No ALU" }, { vi: "Chỉ dùng cho supercomputers", en: "Only used for supercomputers" }], a: 1, explanation: { vi: "CISC (Complex Instruction Set Computer) có các lệnh mạnh mẽ, có thể thực hiện các tác vụ phức tạp trong một lệnh duy nhất. Bên trong, các lệnh này được chia thành các bước nhỏ hơn gọi là micro-operations.", en: "CISC (Complex Instruction Set Computer) has powerful instructions that can perform complex tasks in a single command. Internally, these are broken down into smaller steps called micro-operations." } },
                    { q: { vi: "RISC tập trung vào:", en: "RISC focuses on:" }, o: [{ vi: "Tập lệnh lớn phức tạp", en: "A large, complex instruction set" }, { vi: "Tập lệnh giảm thiểu, mỗi lệnh đơn giản và nhanh", en: "A reduced instruction set, where each instruction is simple and fast" }, { vi: "Loại bỏ cache", en: "Eliminating the cache" }, { vi: "Dùng micromemory cho mỗi lệnh", en: "Using micromemory for each instruction" }], a: 1, explanation: { vi: "RISC (Reduced Instruction Set Computer) có triết lý ngược lại với CISC. Nó sử dụng một tập lệnh nhỏ gồm các lệnh rất đơn giản, mỗi lệnh có thể được thực thi rất nhanh (thường trong một chu kỳ xung nhịp).", en: "RISC (Reduced Instruction Set Computer) has the opposite philosophy of CISC. It uses a small set of very simple instructions, each of which can be executed very quickly (often in a single clock cycle)." } },
                    { q: { vi: "Mục đích của pipelining là:", en: "The purpose of pipelining is:" }, o: [{ vi: "Giảm kích thước RAM", en: "To reduce RAM size" }, { vi: "Tăng throughput bằng cách chồng lấp các pha fetch/decode/execute của nhiều lệnh khác nhau", en: "To increase throughput by overlapping the fetch/decode/execute phases of different instructions" }, { vi: "Thay thế ALU bằng nhiều ALU nhỏ", en: "To replace the ALU with many smaller ALUs" }, { vi: "Làm cho CPU chạy chậm hơn để tiết kiệm điện", en: "To make the CPU run slower to save power" }], a: 1, explanation: { vi: "Pipelining giống như một dây chuyền lắp ráp. Trong khi một lệnh đang được thực thi, lệnh tiếp theo đang được giải mã, và lệnh sau đó nữa đang được nạp. Điều này làm tăng đáng kể số lượng lệnh được hoàn thành trong một đơn vị thời gian (throughput).", en: "Pipelining is like an assembly line. While one instruction is being executed, the next one is being decoded, and the one after that is being fetched. This greatly increases the number of instructions completed per unit of time (throughput)." } },
                    { q: { vi: "Theo Flynn, dạng nào là Single Instruction-stream, Multiple Data-stream?", en: "According to Flynn, which category is Single Instruction-stream, Multiple Data-stream?" }, o: [{ vi: "SISD", en: "SISD" }, { vi: "SIMD", en: "SIMD" }, { vi: "MISD", en: "MISD" }, { vi: "MIMD", en: "MIMD" }], a: 1, explanation: { vi: "SIMD (Single Instruction, Multiple Data) thực hiện cùng một lệnh trên nhiều phần dữ liệu khác nhau cùng một lúc. Điều này rất phổ biến trong xử lý đồ họa và khoa học.", en: "SIMD (Single Instruction, Multiple Data) performs the same instruction on multiple different pieces of data simultaneously. This is very common in graphics and scientific processing." } },
                    { q: { vi: "MISD (Multiple Instruction-stream, Single Data-stream) là:", en: "MISD (Multiple Instruction-stream, Single Data-stream) is:" }, o: [{ vi: "Rất phổ biến trong hệ thống desktop", en: "Very common in desktop systems" }, { vi: "Thường ít hoặc chưa được thực thi thực tế (hiếm gặp)", en: "Rarely or not practically implemented" }, { vi: "Là kiến trúc USB", en: "The architecture of USB" }, { vi: "Tương đương với SIMD", en: "Equivalent to SIMD" }], a: 1, explanation: { vi: "Kiến trúc MISD, trong đó nhiều lệnh hoạt động trên cùng một luồng dữ liệu, có rất ít ứng dụng trong thực tế và chủ yếu mang tính lý thuyết.", en: "The MISD architecture, where multiple instructions operate on the same stream of data, has very few practical applications and is mostly theoretical." } },
                    { q: { vi: "Định dạng lệnh của máy đơn giản trong chương có độ dài bao nhiêu bit?", en: "What is the instruction format length of the simple computer in the chapter?" }, o: [{ vi: "8 bit", en: "8 bits" }, { vi: "12 bit", en: "12 bits" }, { vi: "16 bit (chia làm 4 trường, mỗi trường 4 bit)", en: "16 bits (divided into 4 fields, each 4 bits)" }, { vi: "32 bit", en: "32 bits" }], a: 2, explanation: { vi: "Máy tính giả định trong sách sử dụng các lệnh 16-bit, được chia thành một opcode 4-bit và ba toán hạng 4-bit.", en: "The hypothetical computer in the book uses 16-bit instructions, divided into a 4-bit opcode and three 4-bit operands." } },
                    { q: { vi: "Trong bảng mã lệnh mẫu, opcode của LOAD là số nào?", en: "In the sample instruction table, what is the opcode for LOAD?" }, o: [{ vi: "0", en: "0" }, { vi: "1", en: "1" }, { vi: "2", en: "2" }, { vi: "3", en: "3" }], a: 1, explanation: { vi: "Theo bảng mã lệnh được cung cấp trong chương, lệnh LOAD được gán mã opcode là 1.", en: "According to the instruction set table provided in the chapter, the LOAD instruction is assigned opcode 1." } },
                    { q: { vi: "Opcode của HALT trong máy đơn giản là gì?", en: "What is the opcode for HALT in the simple computer?" }, o: [{ vi: "0", en: "0" }, { vi: "1", en: "1" }, { vi: "F", en: "F" }, { vi: "8", en: "8" }], a: 0, explanation: { vi: "Lệnh HALT (dừng máy) được gán mã opcode là 0.", en: "The HALT instruction (stop the machine) is assigned opcode 0." } },
                    { q: { vi: "Ở máy đơn giản, địa chỉ memory-mapped của keyboard và monitor lần lượt là?", en: "In the simple computer, what are the memory-mapped addresses of the keyboard and monitor, respectively?" }, o: [{ vi: "00 và 01", en: "00 and 01" }, { vi: "FE và FF", en: "FE and FF" }, { vi: "7F và 80", en: "7F and 80" }, { vi: "A0 và A1", en: "A0 and A1" }], a: 1, explanation: { vi: "Sách quy ước hai địa chỉ cuối cùng của không gian 256-byte (FE và FF) được dành riêng cho việc giao tiếp với bàn phím và màn hình.", en: "The book specifies that the last two addresses of the 256-byte space (FE and FF) are reserved for communicating with the keyboard and monitor." } },
                    { q: { vi: "Trong máy đơn giản này, kích thước (size) của Program Counter (PC) là bao nhiêu bit?", en: "In this simple computer, what is the size of the Program Counter (PC)?" }, o: [{ vi: "4 bit", en: "4 bits" }, { vi: "8 bit", en: "8 bits" }, { vi: "16 bit", en: "16 bits" }, { vi: "32 bit", en: "32 bits" }], a: 1, explanation: { vi: "Vì máy có 256 byte bộ nhớ (2^8), Program Counter cần 8 bit để có thể trỏ đến bất kỳ địa chỉ nào trong số đó.", en: "Since the machine has 256 bytes of memory (2^8), the Program Counter needs 8 bits to be able to point to any of those addresses." } }
                ]
            }
        };
        // --- END: NGÂN HÀNG CÂU HỎI VÀ LÝ THUYẾT ---

        // --- START: JAVASCRIPT LOGIC (HOÀN CHỈNH) ---
        let currentLang = 'vi';
        let currentChapter = 'chapter1';
        let quizState = {};

        document.addEventListener('DOMContentLoaded', () => {
            renderAllContent();
        });

        function renderAllContent() {
            const tabContent = document.querySelector('.tab-content');
            tabContent.innerHTML = '';
            let isFirstChapter = true;
            for (const chapterId in contentData) {
                const chapterDiv = document.createElement('div');
                chapterDiv.id = chapterId;
                chapterDiv.className = isFirstChapter ? 'tab-pane active' : 'tab-pane';
                isFirstChapter = false;

                chapterDiv.innerHTML = `
                    <div class="theory-view">
                        <div class="theory-content"></div>
                        <div class="button-group">
                            <button class="primary-button" onclick="showQuizSetup('${chapterId}')" data-lang-key="startQuiz"></button>
                            <button class="info-button" onclick="askAI()" data-lang-key="askAI"></button>
                        </div>
                    </div>
                    <div class="quiz-view">
                        <div class="quiz-setup">
                            <h3 data-lang-key="quizSetupTitle"></h3>
                            <div>
                                <label data-lang-key="numQuestions"></label>
                                <input type="number" id="num-questions-${chapterId}" value="10" min="1" max="${contentData[chapterId].questions.length}">
                            </div>
                            <div>
                                <button class="primary-button" onclick="startQuiz('${chapterId}')" data-lang-key="start"></button>
                                <button class="secondary-button" onclick="showTheory('${chapterId}')" data-lang-key="backToTheory"></button>
                            </div>
                        </div>
                        <div class="quiz-container" style="display:none;">
                            <div id="question-text-${chapterId}" class="quiz-question"></div>
                            <div id="quiz-options-${chapterId}" class="quiz-options"></div>
                            <div id="explanation-${chapterId}"></div>
                            <div class="button-group">
                                <button onclick="nextQuestion('${chapterId}')" id="next-btn-${chapterId}" class="primary-button" data-lang-key="nextQuestion" style="display:none;"></button>
                            </div>
                        </div>
                        <div class="quiz-results" style="display:none;">
                            <h3 data-lang-key="resultsTitle"></h3>
                            <p id="score-${chapterId}"></p>
                            <button class="secondary-button" onclick="showTheory('${chapterId}')" data-lang-key="backToTheory"></button>
                            <button class="primary-button" onclick="showQuizSetup('${chapterId}')" data-lang-key="retakeQuiz"></button>
                        </div>
                    </div>
                `;
                tabContent.appendChild(chapterDiv);
            }
            updateAllVisibleText();
        }

        function switchTab(chapterId) {
            currentChapter = chapterId;
            document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
            document.getElementById(chapterId).classList.add('active');
            
            document.querySelectorAll('.tab-link').forEach(l => l.classList.remove('active'));
            document.querySelector(`.tab-link[onclick="switchTab('${chapterId}')"]`).classList.add('active');
        }

        function switchLanguage(lang) {
            if (currentLang === lang) return;
            currentLang = lang;
            document.querySelectorAll('.lang-switcher button').forEach(b => b.classList.remove('active'));
            document.querySelector(`.lang-switcher button[onclick="switchLanguage('${lang}')"]`).classList.add('active');
            updateAllVisibleText();
        }
        
        const translations = {
            vi: {
                title: "CSI FPTU - Công cụ Ôn tập Nâng cao",
                subtitle: "Chọn chương để học lý thuyết hoặc làm bài tập trắc nghiệm.",
                vietnamese: "Tiếng Việt", english: "English",
                ch1: "Chương 1", ch2: "Chương 2", ch3: "Chương 3", ch4: "Chương 4", ch5: "Chương 5",
                startQuiz: "Làm bài tập", quizSetupTitle: "Thiết lập bài trắc nghiệm",
                numQuestions: "Số lượng câu hỏi:", start: "Bắt đầu",
                backToTheory: "Quay lại Lý thuyết", nextQuestion: "Câu tiếp theo",
                resultsTitle: "Kết quả", scoreText: "Bạn đã trả lời đúng",
                retakeQuiz: "Làm lại bài", askAI: "Hỏi AI"
            },
            en: {
                title: "CSI FPTU - Advanced Study Tool",
                subtitle: "Select a chapter to study theory or take a multiple-choice quiz.",
                vietnamese: "Vietnamese", english: "English",
                ch1: "Chapter 1", ch2: "Chapter 2", ch3: "Chapter 3", ch4: "Chapter 4", ch5: "Chapter 5",
                startQuiz: "Start Quiz", quizSetupTitle: "Quiz Setup",
                numQuestions: "Number of questions:", start: "Start",
                backToTheory: "Back to Theory", nextQuestion: "Next Question",
                resultsTitle: "Results", scoreText: "You answered correctly",
                retakeQuiz: "Retake Quiz", askAI: "Ask AI"
            }
        };
        function askAI() {
            const activeChapter = document.querySelector('.tab-pane.active');
            const titleElement = activeChapter.querySelector('.theory-content h2');
            if (titleElement) {
                let topic = titleElement.textContent.trim();
                topic = topic.replace(/Chapter \d+:|Chương \d+:/i, '').trim();

                const promptText = currentLang === 'vi' 
                    ? `Hãy giải thích chi tiết về chủ đề sau trong môn Khoa học máy tính: "${topic}". Vui lòng giải thích các khái niệm cốt lõi, cho ví dụ minh họa và nêu bật những điểm quan trọng nhất mà sinh viên cần nắm vững.`
                    : `Please provide a detailed explanation of the following topic in Computer Science: "${topic}". Explain the core concepts, provide illustrative examples, and highlight the most important points a student needs to master.`;

                const encodedPrompt = encodeURIComponent(promptText);
                const url = `https://gemini.google.com/app?prompt=${encodedPrompt}`;
                
                window.open(url, '_blank');
            }
        }
    </script>
</body>
</html>
