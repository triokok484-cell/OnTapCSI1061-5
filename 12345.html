<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSI FPTU - Công cụ Ôn tập Nâng cao</title>
    <style>
        :root {
            --fpt-blue: #0055a5;
            --fpt-orange: #f26f21;
            --info-blue: #007bff;
            --text-color: #333;
            --bg-color: #f8f9fa;
            --container-bg: #ffffff;
            --highlight-bg: #fff3cd;
            --highlight-text: #856404;
            --correct-bg: #d4edda;
            --correct-border: #c3e6cb;
            --incorrect-bg: #f8d7da;
            --incorrect-border: #f5c6cb;
            --explanation-bg: #e2e3e5;
        }
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            line-height: 1.7;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        .container {
            max-width: 960px;
            margin: auto;
            background: var(--container-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        header {
            text-align: center;
            border-bottom: 3px solid var(--fpt-blue);
            padding-bottom: 15px;
            margin-bottom: 25px;
        }
        header h1 {
            color: var(--fpt-blue);
            margin: 0 0 5px 0;
        }
        .lang-switcher {
            margin-top: 15px;
        }
        .lang-switcher button {
            padding: 6px 12px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            cursor: pointer;
            margin: 0 5px;
            border-radius: 5px;
            font-size: 14px;
        }
        .lang-switcher button.active {
            background-color: var(--fpt-blue);
            color: white;
            border-color: var(--fpt-blue);
        }
        .tab-nav {
            display: flex;
            margin-bottom: 25px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .tab-link {
            flex: 1;
            padding: 15px;
            cursor: pointer;
            border: none;
            background-color: #e9ecef;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.3s, color 0.3s;
            text-align: center;
        }
        .tab-link.active {
            background-color: var(--fpt-orange);
            color: white;
        }
        .tab-link:hover:not(.active) {
            background-color: #dee2e6;
        }
        .tab-pane { display: none; }
        .tab-pane.active { display: block; }
        
        .theory-content h2 { color: var(--fpt-blue); border-bottom: 2px solid var(--fpt-orange); padding-bottom: 5px; }
        .theory-content h3 { color: #333; margin-top: 25px; }
        .theory-content h4 { color: #555; margin-top: 20px; }
        .theory-content ul { list-style-type: none; padding-left: 0; }
        .theory-content li { background: #f8f9fa; margin-bottom: 10px; padding: 15px; border-left: 4px solid var(--fpt-blue); border-radius: 5px; }
        .theory-content ul ul { margin-top: 10px; }
        .theory-content li li { background: #e9ecef; border-left-color: var(--fpt-orange); }
        .theory-content code, .theory-content pre {
            font-family: Consolas, 'Courier New', monospace;
            background-color: #e9ecef;
            padding: 2px 5px;
            border-radius: 4px;
        }
        .theory-content pre {
            padding: 15px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            border-left: 4px solid #ccc;
        }

        .highlight {
            background-color: var(--highlight-bg);
            padding: 3px 6px;
            border-radius: 4px;
            font-weight: bold;
            color: var(--highlight-text);
        }
        .quiz-view, .quiz-setup, .quiz-results { display: none; }
        .quiz-container, .quiz-setup, .quiz-results {
            border: 1px solid #dee2e6;
            padding: 25px;
            margin-top: 25px;
            border-radius: 8px;
            background-color: #fafafa;
        }
        .quiz-question {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .quiz-options button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 14px;
            margin: 8px 0;
            border: 1px solid #ccc;
            background-color: var(--container-bg);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            font-size: 16px;
        }
        .quiz-options button:hover:not([disabled]) {
            background-color: #e9e9e9;
            border-color: #aaa;
        }
        .quiz-options button.correct {
            background-color: var(--correct-bg);
            border-color: var(--correct-border);
            font-weight: bold;
        }
        .quiz-options button.incorrect {
            background-color: var(--incorrect-bg);
            border-color: var(--incorrect-border);
        }
        .explanation-box {
            margin-top: 15px;
            padding: 15px;
            background-color: var(--explanation-bg);
            border-radius: 6px;
            border: 1px solid #ced4da;
        }
        .button-group button, .quiz-setup button, .quiz-results button, .quiz-setup input {
            padding: 12px 22px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 6px;
            margin: 10px 5px 10px 0;
            border: none;
            font-weight: 500;
        }
        .quiz-setup input {
            width: 80px;
            border: 1px solid #ccc;
            border-radius: 6px;
            text-align: center;
        }
        .primary-button { background-color: var(--fpt-blue); color: white; }
        .secondary-button { background-color: #6c757d; color: white; }
        .info-button { background-color: var(--info-blue); color: white; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 data-lang-key="title">CSI FPTU - Công cụ Ôn tập Nâng cao</h1>
            <p data-lang-key="subtitle">Chọn chương để học lý thuyết hoặc làm bài tập trắc nghiệm.</p>
            <div class="lang-switcher">
                <button onclick="switchLanguage('vi')" class="active" data-lang-key="vietnamese">Tiếng Việt</button>
                <button onclick="switchLanguage('en')" data-lang-key="english">English</button>
            </div>
        </header>

        <div class="tab-nav">
            <button class="tab-link active" onclick="switchTab('chapter1')" data-lang-key="ch1">Chương 1</button>
            <button class="tab-link" onclick="switchTab('chapter2')" data-lang-key="ch2">Chương 2</button>
            <button class="tab-link" onclick="switchTab('chapter3')" data-lang-key="ch3">Chương 3</button>
            <button class="tab-link" onclick="switchTab('chapter4')" data-lang-key="ch4">Chương 4</button>
            <button class="tab-link" onclick="switchTab('chapter5')" data-lang-key="ch5">Chương 5</button>
        </div>

        <div class="tab-content">
            <!-- Content will be generated by JavaScript -->
        </div>
    </div>

    <script>
        // --- START: NGÂN HÀNG CÂU HỎI VÀ LÝ THUYẾT ---
        const contentData = {
            chapter1: {
                theory: {
                    vi: `
                        <h2>Chương 1: Giới thiệu Tổng quan</h2>
                        <h3>1. Các mô hình máy tính cơ bản</h3>
                        <ul>
                            <li>
                                <strong>Mô hình Turing (Turing Model):</strong>
                                <ul>
                                    <li>Định nghĩa máy tính như một <span class="highlight">bộ xử lý dữ liệu có thể lập trình được (programmable data processor)</span>.</li>
                                    <li>Đây là một mô hình lý thuyết, toán học, không phải kiến trúc vật lý.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Mô hình von Neumann (von Neumann Model):</strong>
                                <ul>
                                    <li>Mô hình kiến trúc cho hầu hết các máy tính hiện đại.</li>
                                    <li><span class="highlight">Khái niệm đột phá: Chương trình được lưu trong bộ nhớ (Stored Program Concept)</span>.</li>
                                    <li>Kiến trúc bao gồm 4 hệ thống con (subsystems):
                                        <ol>
                                            <li><strong>Bộ nhớ (Memory)</strong></li>
                                            <li><strong>Đơn vị Số học & Logic (ALU)</strong></li>
                                            <li><strong>Đơn vị Điều khiển (Control Unit)</strong></li>
                                            <li><strong>Hệ thống Vào/Ra (Input/Output Subsystem)</strong></li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    `,
                    en: `
                        <h2>Chapter 1: Introduction</h2>
                        <h3>1. Basic Computer Models</h3>
                        <ul>
                            <li>
                                <strong>Turing Model:</strong>
                                <ul>
                                    <li>Defines a computer as a <span class="highlight">programmable data processor</span>.</li>
                                    <li>This is a theoretical, mathematical model, not a physical architecture.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>von Neumann Model:</strong>
                                <ul>
                                    <li>The architectural model for most modern computers.</li>
                                    <li><span class="highlight">Breakthrough concept: The Stored Program Concept</span>.</li>
                                    <li>The architecture consists of four subsystems:
                                        <ol>
                                            <li><strong>Memory</strong></li>
                                            <li><strong>Arithmetic Logic Unit (ALU)</strong></li>
                                            <li><strong>Control Unit</strong></li>
                                            <li><strong>Input/Output (I/O) Subsystem</strong></li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    `
                },
                questions: [
                    { q: { vi: "Mô hình nào định nghĩa khái niệm 'Stored Program Concept' (Chương trình được lưu trong bộ nhớ)?", en: "Which model defines the 'Stored Program Concept'?" }, o: [{ vi: "Mô hình Turing", en: "Turing Model" }, { vi: "Mô hình von Neumann", en: "von Neumann Model" }, { vi: "Mô hình Pascal", en: "Pascal Model" }, { vi: "Mô hình Babbage", en: "Babbage Model" }], a: 1, explanation: { vi: "Ghi nhớ: Von Neumann = Chương trình trong Bộ nhớ. Đây là kiến trúc máy tính hiện đại.", en: "Remember: Von Neumann = Program in Memory. This is the modern computer architecture." } },
                    { q: { vi: "Theo mô hình Turing, đầu ra phụ thuộc vào yếu tố nào?", en: "According to the Turing model, what does the output depend on?" }, o: [{ vi: "Chỉ dữ liệu đầu vào", en: "Only the input data" }, { vi: "Chỉ chương trình", en: "Only the program" }, { vi: "Sự kết hợp của dữ liệu đầu vào và chương trình", en: "The combination of input data and the program" }, { vi: "Tốc độ của máy tính", en: "The speed of the computer" }], a: 2, explanation: { vi: "Máy Turing là một 'bộ xử lý dữ liệu LẬP TRÌNH ĐƯỢC'. 'Lập trình được' có nghĩa là chương trình quyết định cách xử lý dữ liệu.", en: "A Turing machine is a 'PROGRAMMABLE data processor'. 'Programmable' means the program dictates how the data is handled." } },
                    { q: { vi: "Bốn thành phần của máy tính theo kiến trúc von Neumann là gì?", en: "What are the four components of a computer according to the von Neumann architecture?"}, o: [ {vi: "CPU, RAM, Bàn phím, Màn hình", en: "CPU, RAM, Keyboard, Monitor"}, {vi: "Bộ nhớ, ALU, Đơn vị điều khiển, Thiết bị Vào/Ra", en: "Memory, ALU, Control Unit, Input/Output Subsystem"}, {vi: "Phần cứng, Phần mềm, Dữ liệu, Mạng", en: "Hardware, Software, Data, Network"}, {vi: "Hệ điều hành, Ứng dụng, Driver, Firmware", en: "Operating System, Application, Driver, Firmware"}], a: 1, explanation: {vi: "Kiến trúc von Neumann định nghĩa 4 khối chức năng chính: Memory (bộ nhớ), ALU (đơn vị số học logic), Control Unit (đơn vị điều khiển), và I/O (vào/ra).", en: "The von Neumann architecture defines 4 main functional blocks: Memory, ALU (Arithmetic Logic Unit), Control Unit, and I/O (Input/Output)."}},
                    { q: { vi: "Thành phần nào của CPU chịu trách nhiệm thực hiện các phép toán số học và logic?", en: "Which component of the CPU is responsible for performing arithmetic and logic operations?"}, o: [ {vi: "Control Unit", en: "Control Unit"}, {vi: "Registers", en: "Registers"}, {vi: "ALU (Arithmetic Logic Unit)", en: "ALU (Arithmetic Logic Unit)"}, {vi: "Main Memory", en: "Main Memory"}], a: 2, explanation: {vi: "ALU là viết tắt của Arithmetic Logic Unit, chuyên thực hiện các phép tính toán (+, -, *, /) và các phép so sánh logic (AND, OR, NOT).", en: "ALU stands for Arithmetic Logic Unit, which specializes in performing calculations (+, -, *, /) and logical operations (AND, OR, NOT)."}},
                    { q: { vi: "Sự khác biệt chính giữa máy tính đa năng (general-purpose) và máy tính chuyên dụng (specific-purpose) là gì?", en: "What is the main difference between a general-purpose and a specific-purpose computer?"}, o: [ {vi: "Kích thước vật lý", en: "Physical size"}, {vi: "Khả năng chạy các chương trình khác nhau", en: "The ability to run different programs"}, {vi: "Giá thành", en: "Cost"}, {vi: "Tốc độ xử lý", en: "Processing speed"}], a: 1, explanation: {vi: "Máy tính đa năng (như PC) có thể thực hiện nhiều tác vụ bằng cách chạy các chương trình khác nhau. Máy tính chuyên dụng (như máy tính trong lò vi sóng) chỉ được thiết kế cho một nhiệm vụ duy nhất.", en: "A general-purpose computer (like a PC) can perform many tasks by running different programs. A specific-purpose computer (like one in a microwave) is designed for only one task."}}
                ]
            },
            chapter2: {
                 theory: {
                     vi: `
                        <h2>Chương 2: Hệ thống Số</h2>
                        <h3>1. Các hệ đếm cơ bản (Positional Number Systems)</h3>
                        <ul>
                            <li><strong>Khái niệm:</strong> Giá trị của một chữ số phụ thuộc vào <span class="highlight">vị trí (position)</span> của nó trong chuỗi số.</li>
                            <li><strong>Các hệ đếm chính:</strong>
                                <ul>
                                    <li><strong>Thập phân (Decimal - Base 10)</strong></li>
                                    <li><strong>Nhị phân (Binary - Base 2)</strong>: Ngôn ngữ của máy tính.</li>
                                    <li><strong>Bát phân (Octal - Base 8)</strong></li>
                                    <li><strong>Thập lục phân (Hexadecimal - Base 16)</strong></li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Chuyển đổi</h3>
                        <p>Quy tắc quan trọng: Chuyển từ thập phân sang hệ khác dùng phép <span class="highlight">chia liên tiếp</span>. Chuyển từ hệ khác về thập phân dùng <span class="highlight">phép nhân với lũy thừa của cơ số</span>.</p>
                    `,
                    en: `
                        <h2>Chapter 2: Number Systems</h2>
                        <h3>1. Positional Number Systems</h3>
                        <ul>
                            <li><strong>Concept:</strong> The value of a digit depends on its <span class="highlight">position</span> within the number string.</li>
                            <li><strong>Main Systems:</strong>
                                <ul>
                                    <li><strong>Decimal (Base 10)</strong></li>
                                    <li><strong>Binary (Base 2)</strong>: The language of computers.</li>
                                    <li><strong>Octal (Base 8)</strong></li>
                                    <li><strong>Hexadecimal (Base 16)</strong></li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Conversions</h3>
                        <p>Key rule: To convert from decimal to another base, use <span class="highlight">repeated division</span>. To convert from another base to decimal, use <span class="highlight">multiplication with powers of the base</span>.</p>
                    `
                },
                questions: [
                     { q: { vi: "Trong một hệ số vị (positional number system), radix (base) là gì?", en: "In a positional number system, what is the radix (base)?"}, o: [ {vi: "Giá trị lớn nhất có thể biểu diễn bằng một chữ số.", en: "The maximum value representable by a single digit."}, {vi: "Số chữ số tối đa cho biểu diễn số nguyên.", en: "The maximum number of digits for an integer representation."}, {vi: "Số kí hiệu (symbols) trong hệ (số lượng chữ số khác nhau).", en: "The number of symbols in the system (the count of different digits)."}, {vi: "Tổng các giá trị chữ số trong một số.", en: "The sum of the digit values in a number."}], a: 2, explanation: {vi: "Radix (base) định nghĩa số lượng ký hiệu duy nhất được sử dụng trong hệ đếm đó. Ví dụ, hệ thập phân có base 10 vì nó dùng 10 ký hiệu (0-9).", en: "The radix (base) defines the number of unique symbols used in that number system. For example, the decimal system has a base of 10 because it uses 10 symbols (0-9)."}},
                    { q: { vi: "Hệ thập phân (decimal) có base bằng bao nhiêu?", en: "What is the base of the decimal system?"}, o: [ {vi: "2", en: "2"}, {vi: "8", en: "8"}, {vi: "10", en: "10"}, {vi: "16", en: "16"}], a: 2, explanation: {vi: "Hệ thập phân (decimal) quen thuộc với chúng ta sử dụng 10 chữ số từ 0 đến 9, do đó cơ số (base) của nó là 10.", en: "The familiar decimal system uses 10 digits from 0 to 9, so its base is 10."}},
                    { q: { vi: "Trong hệ nhị phân (binary), mỗi chữ số gọi là gì?", en: "In the binary system, what is each digit called?"}, o: [ {vi: "nibble", en: "nibble"}, {vi: "digit", en: "digit"}, {vi: "byte", en: "byte"}, {vi: "bit", en: "bit"}], a: 3, explanation: {vi: "Một chữ số trong hệ nhị phân được gọi là 'bit', viết tắt của 'binary digit'.", en: "A digit in the binary system is called a 'bit', which is short for 'binary digit'."}},
                    { q: { vi: "Giá trị thập phân của (11001)₂ là:", en: "The decimal value of (11001)₂ is:"}, o: [ {vi: "25", en: "25"}, {vi: "27", en: "27"}, {vi: "29", en: "29"}, {vi: "31", en: "31"}], a: 0, explanation: {vi: "Tính toán: (1 × 2⁴) + (1 × 2³) + (0 × 2²) + (0 × 2¹) + (1 × 2⁰) = 16 + 8 + 0 + 0 + 1 = 25.", en: "Calculation: (1 × 2⁴) + (1 × 2³) + (0 × 2²) + (0 × 2¹) + (1 × 2⁰) = 16 + 8 + 0 + 0 + 1 = 25."}}
                ]
            },
            chapter3: {
                theory: {
                    vi: `
                        <h2>Chương 3: Lưu trữ Dữ liệu</h2>
                        <h3>1. Các kiểu dữ liệu</h3>
                        <ul>
                            <li>Tất cả dữ liệu (số, văn bản, hình ảnh, âm thanh, video) đều được lưu trữ dưới dạng <span class="highlight">chuỗi bit (bit pattern)</span>.</li>
                        </ul>
                        <h3>2. Lưu trữ số nguyên</h3>
                        <ul>
                            <li><strong>Số nguyên không dấu (Unsigned):</strong> 0 đến 2ⁿ-1.</li>
                            <li><strong>Số nguyên có dấu (Signed):</strong> Phương pháp chuẩn là <span class="highlight">Bù 2 (Two's Complement)</span>.
                                <ul>
                                    <li>Ưu điểm: Chỉ có một số 0, phép trừ thực hiện bằng phép cộng.</li>
                                    <li>Cách tìm bù 2 của số âm: Lấy số dương, đảo tất cả các bit (bù 1), rồi cộng 1.</li>
                                </ul>
                            </li>
                        </ul>
                         <h3>3. Lưu trữ số thực</h3>
                        <ul>
                            <li>Sử dụng biểu diễn <span class="highlight">Dấu phẩy động (Floating-Point)</span> theo chuẩn IEEE.</li>
                             <li>Gồm 3 phần: <strong>Dấu (Sign)</strong>, <strong>Số mũ (Exponent)</strong>, và <strong>Phần định trị (Mantissa)</strong>.</li>
                        </ul>
                    `,
                    en: `
                        <h2>Chapter 3: Data Storage</h2>
                        <h3>1. Data Types</h3>
                        <ul>
                            <li>All data (numbers, text, images, audio, video) is stored as a <span class="highlight">bit pattern</span>.</li>
                        </ul>
                        <h3>2. Storing Integers</h3>
                        <ul>
                            <li><strong>Unsigned Integers:</strong> 0 to 2ⁿ-1.</li>
                            <li><strong>Signed Integers:</strong> The standard method is <span class="highlight">Two's Complement</span>.
                                <ul>
                                    <li>Advantages: Only one zero, subtraction is performed via addition.</li>
                                    <li>To find a negative number's two's complement: Take the positive value, invert all bits (one's complement), then add 1.</li>
                                </ul>
                            </li>
                        </ul>
                         <h3>3. Storing Reals</h3>
                        <ul>
                            <li>Uses <span class="highlight">Floating-Point</span> representation (IEEE standard).</li>
                             <li>Consists of 3 parts: <strong>Sign</strong>, <strong>Exponent</strong>, and <strong>Mantissa</strong>.</li>
                        </ul>
                    `
                },
                questions: [
                    { q: { vi: "Khi được lưu trữ trong máy tính, tất cả các loại dữ liệu đều được chuyển đổi thành một dạng biểu diễn thống nhất. Dạng biểu diễn chung này được gọi là gì?", en: "When stored in a computer, all data types are converted into a uniform representation. What is this common representation called?"}, o: [{vi: "Một byte (A byte)", en: "A byte"}, {vi: "Một mẫu bit (A bit pattern)", en: "A bit pattern"}, {vi: "Một từ (A word)", en: "A word"}, {vi: "Một con số (A number)", en: "A number"}], a: 1, explanation: {vi: "Dù là số, chữ, hay hình ảnh, tất cả đều được mã hóa thành các chuỗi 0 và 1, được gọi là mẫu bit.", en: "Whether it's a number, text, or image, everything is encoded into strings of 0s and 1s, known as a bit pattern."} },
                    { q: { vi: "Hầu hết các máy tính ngày nay sử dụng phương pháp biểu diễn số nguyên nào để lưu trữ số nguyên có dấu?", en: "Which integer representation do most computers today use to store signed integers?"}, o: [{vi: "Biểu diễn không dấu (Unsigned representation)", en: "Unsigned representation"}, {vi: "Biểu diễn dấu-lượng (Sign-and-magnitude representation)", en: "Sign-and-magnitude representation"}, {vi: "Biểu diễn bù hai (Two's complement representation)", en: "Two's complement representation"}, {vi: "Biểu diễn bù một (One's complement representation)", en: "One's complement representation"}], a: 2, explanation: {vi: "Bù hai (Two's complement) là tiêu chuẩn vì nó giải quyết vấn đề hai số 0 và đơn giản hóa mạch logic cho phép trừ (biến nó thành phép cộng).", en: "Two's complement is the standard because it solves the two-zeros problem and simplifies the logic circuit for subtraction (by turning it into addition)."}},
                    { q: { vi: "Một biểu diễn dấu phẩy động (floating-point) của một số bao gồm ba phần nào?", en: "A floating-point representation of a number consists of which three parts?"}, o: [{vi: "Dấu, phần nguyên và phần thập phân (Sign, integer, and fraction)", en: "Sign, integer, and fraction"}, {vi: "Dấu, số mũ và phần định trị (Sign, exponent, and mantissa)", en: "Sign, exponent, and mantissa"}, {vi: "Phần định trị, số mũ và dấu thập phân (Mantissa, exponent, and decimal point)", en: "Mantissa, exponent, and decimal point"}, {vi: "Phần nguyên, dấu thập phân và phần thập phân (Integer, decimal point, and fraction)", en: "Integer, decimal point, and fraction"}], a: 1, explanation: {vi: "Ghi nhớ 3 thành phần của ký hiệu khoa học: Dấu (+/-), Định trị (số chính), và Số mũ (lũy thừa của cơ số).", en: "Remember the 3 parts of scientific notation: Sign (+/-), Mantissa (the significant digits), and Exponent (the power of the base)."}},
                    { q: { vi: "Chuẩn Unicode có thể sử dụng tới 32 bit cho mỗi ký hiệu. Ưu điểm chính của việc này so với ASCII 7-bit là gì?", en: "The Unicode standard can use up to 32 bits per symbol. What is the main advantage of this over 7-bit ASCII?"}, o: [{vi: "Nó được nén tốt hơn.", en: "It is better compressed."}, {vi: "Nó có thể biểu diễn các ký hiệu từ nhiều ngôn ngữ hơn.", en: "It can represent symbols from many more languages."}, {vi: "Nó xử lý nhanh hơn.", en: "It processes faster."}, {vi: "Nó tự động bao gồm việc sửa lỗi.", en: "It automatically includes error correction."}], a: 1, explanation: {vi: "ASCII chỉ có 128 ký tự, đủ cho tiếng Anh. Unicode có một không gian mã khổng lồ, cho phép nó bao gồm các ký tự từ hầu hết các ngôn ngữ viết trên thế giới.", en: "ASCII has only 128 characters, enough for English. Unicode has a vast codespace, allowing it to include characters from almost all written languages in the world."}}
                ]
            },
            chapter4: {
                 theory: {
                    vi: `
                        <h2>Chương 4: Các Phép toán trên Dữ liệu</h2>
                        <h3>1. Phép toán Logic (Logic Operations)</h3>
                        <ul>
                            <li>Thực hiện trên từng bit. Các toán tử chính: <strong>NOT, AND, OR, XOR</strong>.</li>
                            <li><strong>Ứng dụng: Dùng mặt nạ (Masking)</strong>
                                <ul>
                                    <li><span class="highlight">Unset (về 0):</span> Dùng phép <strong>AND</strong> với mặt nạ có bit 0.</li>
                                    <li><span class="highlight">Set (về 1):</span> Dùng phép <strong>OR</strong> với mặt nạ có bit 1.</li>
                                    <li><span class="highlight">Flip (đảo bit):</span> Dùng phép <strong>XOR</strong> với mặt nạ có bit 1.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Phép toán Dịch chuyển (Shift Operations)</h3>
                        <ul>
                             <li><strong>Dịch logic (Logical Shift):</strong> Dùng cho số không dấu, chèn số 0 vào chỗ trống.</li>
                             <li><strong>Dịch số học (Arithmetic Shift):</strong> Dùng cho số bù 2. Khi dịch phải, bit dấu được giữ nguyên.</li>
                             <li>Dịch trái 1 bit tương đương nhân 2, dịch phải 1 bit tương đương chia 2.</li>
                        </ul>
                        <h3>3. Phép toán Số học (Arithmetic Operations)</h3>
                        <ul>
                            <li><span class="highlight">Phép trừ A - B được thực hiện bằng phép cộng: A + (Bù 2 của B)</span>.</li>
                            <li>Tràn số (Overflow) xảy ra khi cộng 2 số cùng dấu và kết quả ra khác dấu.</li>
                        </ul>
                    `,
                    en: `
                        <h2>Chapter 4: Operations on Data</h2>
                        <h3>1. Logic Operations</h3>
                        <ul>
                            <li>Performed bit by bit. Main operators: <strong>NOT, AND, OR, XOR</strong>.</li>
                            <li><strong>Application: Masking</strong>
                                <ul>
                                    <li><span class="highlight">Unsetting (to 0):</span> Use <strong>AND</strong> with a mask that has a 0.</li>
                                    <li><span class="highlight">Setting (to 1):</span> Use <strong>OR</strong> with a mask that has a 1.</li>
                                    <li><span class="highlight">Flipping a bit:</span> Use <strong>XOR</strong> with a mask that has a 1.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Shift Operations</h3>
                        <ul>
                             <li><strong>Logical Shift:</strong> For unsigned numbers, inserts a 0 into the empty spot.</li>
                             <li><strong>Arithmetic Shift:</strong> For two's complement numbers. A right shift preserves the sign bit.</li>
                             <li>A left shift by 1 bit is like multiplying by 2; a right shift is like dividing by 2.</li>
                        </ul>
                        <h3>3. Arithmetic Operations</h3>
                        <ul>
                            <li><span class="highlight">Subtraction A - B is performed as an addition: A + (Two's complement of B)</span>.</li>
                            <li>Overflow occurs when adding two numbers of the same sign and the result has a different sign.</li>
                        </ul>
                    `
                },
                questions: [
                    { q: { vi: "Kết quả của phép NOT trên 8-bit 10011000 là:", en: "The result of a NOT operation on the 8-bit pattern 10011000 is:" }, o: [{ vi: "01100111", en: "01100111" }, { vi: "10011000", en: "10011000" }, { vi: "01111000", en: "01111000" }, { vi: "00100111", en: "00100111" }], a: 0, explanation: { vi: "Vì NOT đổi 0↔1: 10011000 → 01100111.", en: "Because NOT inverts 0↔1: 10011000 → 01100111." } },
                    { q: { vi: "10011000 AND 00101010 bằng:", en: "10011000 AND 00101010 equals:" }, o: [{ vi: "00001000", en: "00001000" }, { vi: "10011010", en: "10011010" }, { vi: "00101000", en: "00101000" }, { vi: "00000000", en: "00000000" }], a: 0, explanation: { vi: "AND giữ 1 chỉ khi cả hai là 1; kết quả 00001000.", en: "AND results in 1 only when both bits are 1; the result is 00001000." } },
                    { q: { vi: "10011001 OR 00101110 bằng:", en: "10011001 OR 00101110 equals:" }, o: [{ vi: "10011111", en: "10011111" }, { vi: "10111111", en: "10111111" }, { vi: "00101111", en: "00101111" }, { vi: "10001010", en: "10001010" }], a: 1, explanation: { vi: "Bitwise OR operation results in 10111111.", en: "Bitwise OR operation results in 10111111." } },
                    { q: { vi: "10011001 XOR 00101110 bằng:", en: "10011001 XOR 00101110 equals:" }, o: [{ vi: "10110111", en: "10110111" }, { vi: "10111111", en: "10111111" }, { vi: "10011001", en: "10011001" }, { vi: "00101110", en: "00101110" }], a: 0, explanation: { vi: "XOR = 1 khi các bit khác nhau → 10110111.", en: "XOR = 1 when bits are different → 10110111." } },
                    { q: { vi: "Ta muốn unset (clear) 5 bit trái nhất của 10100110. Mask phù hợp và kết quả là:", en: "We want to unset (clear) the 5 leftmost bits of 10100110. The appropriate mask and result are:" }, o: [{ vi: "Mask 00000111, kết quả 00000110", en: "Mask 00000111, result 00000110" }, { vi: "Mask 11111000, kết quả 11111110", en: "Mask 11111000, result 11111110" }, { vi: "Mask 00011111, kết quả 00000110", en: "Mask 00011111, result 00000110" }, { vi: "Mask 00000111, kết quả 10100110", en: "Mask 00000111, result 10100110" }], a: 0, explanation: { vi: "Để unset 5 bit trái, mask cần có 0 ở 5 vị trí đó và 1 ở các vị trí còn lại: 00000111. 10100110 AND 00000111 = 00000110.", en: "To unset the 5 leftmost bits, the mask needs 0s in those positions and 1s elsewhere: 00000111. 10100110 AND 00000111 = 00000110." } },
                    { q: { vi: "Ta muốn set (force =1) 5 bit trái nhất của 10100110. Mask và kết quả là:", en: "We want to set (force to 1) the 5 leftmost bits of 10100110. The mask and result are:" }, o: [{ vi: "Mask 11111000, kết quả 11111110", en: "Mask 11111000, result 11111110" }, { vi: "Mask 00000111, kết quả 10100111", en: "Mask 00000111, result 10100111" }, { vi: "Mask 11111000, kết quả 10111110", en: "Mask 11111000, result 10111110" }, { vi: "Mask 11111111, kết quả 11111110", en: "Mask 11111111, result 11111110" }], a: 0, explanation: { vi: "Để set bit, dùng OR với mask có 1 ở vị trí cần set. OR với 11111000 → 11111110.", en: "To set bits, use OR with a mask having 1s at the desired positions. OR with 11111000 → 11111110." } },
                    { q: { vi: "Dùng mask 11111000 để flip (XOR) 5 bit trái nhất trên 10100110. Kết quả là:", en: "Using mask 11111000 to flip (XOR) the 5 leftmost bits of 10100110. The result is:" }, o: [{ vi: "01011110", en: "01011110" }, { vi: "11111110", en: "11111110" }, { vi: "00000110", en: "00000110" }, { vi: "10100110", en: "10100110" }], a: 0, explanation: { vi: "10100110 XOR 11111000 = 01011110.", en: "10100110 XOR 11111000 = 01011110." } },
                    { q: { vi: "Simple left shift 1 vị trí của 10011000 (8-bit logical shift) cho kết quả:", en: "A simple left shift by 1 position of 10011000 (8-bit logical shift) results in:" }, o: [{ vi: "00110000", en: "00110000" }, { vi: "00011000", en: "00011000" }, { vi: "00110001", en: "00110001" }, { vi: "10011000", en: "10011000" }], a: 0, explanation: { vi: "Dịch trái làm mất bit trái nhất và chèn 0 vào bên phải → 00110000.", en: "A left shift discards the leftmost bit and inserts a 0 on the right → 00110000." } },
                    { q: { vi: "Circular (rotate) left 1 vị trí của 10011000 cho:", en: "A circular (rotate) left by 1 position of 10011000 gives:" }, o: [{ vi: "00110000", en: "00110000" }, { vi: "00110001", en: "00110001" }, { vi: "11001100", en: "11001100" }, { vi: "00011001", en: "00011001" }], a: 1, explanation: { vi: "Dịch vòng trái: 10011000 → 00110001 (bit trái nhất '1' được đưa về bên phải).", en: "Left rotate: 10011000 → 00110001 (the leftmost bit '1' is moved to the rightmost position)." } },
                    { q: { vi: "Cho mẫu 10110110. Bit thứ 3 từ bên phải (third bit from right) có giá trị:", en: "Given the pattern 10110110. The third bit from the right has a value of:" }, o: [{ vi: "0", en: "0" }, { vi: "1", en: "1" }, { vi: "Không xác định", en: "Undefined" }, { vi: "Phải tính kiểu dấu", en: "Depends on sign type" }], a: 1, explanation: { vi: "Đếm từ phải sang (bắt đầu từ 1): bit thứ nhất là 0, thứ hai là 1, thứ ba là 1.", en: "Counting from the right (starting at 1): the first bit is 0, the second is 1, the third is 1." } },
                    { q: { vi: "Arithmetic left shift 1 vị trí trên số 8-bit two’s complement 11011001 cho kết quả nhị phân và thập phân tương ứng?", en: "An arithmetic left shift by 1 on the 8-bit two's complement number 11011001 gives what binary and decimal result?" }, o: [{ vi: "10110010 (−78)", en: "10110010 (−78)" }, { vi: "01101100 (+108)", en: "01101100 (+108)" }, { vi: "10110010 (+178)", en: "10110010 (+178)" }, { vi: "01011001 (89)", en: "01011001 (89)" }], a: 0, explanation: { vi: "Số ban đầu là -39. Dịch trái số học 1 vị trí tương đương nhân 2. -39 * 2 = -78, là 10110010 trong bù hai.", en: "The original number is -39. An arithmetic left shift by 1 is equivalent to multiplying by 2. -39 * 2 = -78, which is 10110010 in two's complement." } },
                    { q: { vi: "Arithmetic left shift của 01111111 (8-bit) một vị trí tạo ra:", en: "An arithmetic left shift of 01111111 (8-bit) by one position creates:" }, o: [{ vi: "11111110 và xảy ra overflow", en: "11111110 and an overflow occurs" }, { vi: "11111110 và không overflow", en: "11111110 and no overflow" }, { vi: "00111111 và không overflow", en: "00111111 and no overflow" }, { vi: "01111110 và không overflow", en: "01111110 and no overflow" }], a: 0, explanation: { vi: "01111111 (+127) dịch trái 1 bit thành 11111110 (-2). Vì dấu đã thay đổi từ dương sang âm, đã xảy ra tràn số.", en: "01111111 (+127) shifted left by 1 bit becomes 11111110 (-2). Since the sign changed from positive to negative, an overflow occurred." } },
                    { q: { vi: "Để chia một số nguyên (unsigned) cho 4 ta dùng thao tác dịch bit nào?", en: "To divide an unsigned integer by 4, which bit operation is used?" }, o: [{ vi: "Right shift by 2 (logical right shift)", en: "Right shift by 2 (logical right shift)" }, { vi: "Left shift by 2", en: "Left shift by 2" }, { vi: "Circular shift right by 2", en: "Circular shift right by 2" }, { vi: "XOR với 0x03", en: "XOR with 0x03" }], a: 0, explanation: { vi: "Dịch phải 2 vị trí tương đương chia cho 2², tức là chia cho 4 (đối với số không dấu).", en: "A right shift by 2 positions is equivalent to dividing by 2², which is dividing by 4 (for unsigned numbers)." } },
                    { q: { vi: "Để nhân một số nguyên (unsigned) với 8 ta làm:", en: "To multiply an unsigned integer by 8, we do:" }, o: [{ vi: "Left shift by 3", en: "Left shift by 3" }, { vi: "Right shift by 3", en: "Right shift by 3" }, { vi: "Left shift by 2 rồi + chính nó", en: "Left shift by 2 then + itself" }, { vi: "XOR với 0x08", en: "XOR with 0x08" }], a: 0, explanation: { vi: "Dịch trái 3 vị trí tương đương nhân với 2³, tức là nhân với 8.", en: "A left shift by 3 positions is equivalent to multiplying by 2³, which is multiplying by 8." } },
                    { q: { vi: "Với 8-bit two’s complement, 19 + 23 = ? (dạng nhị phân 8-bit)", en: "With 8-bit two's complement, 19 + 23 = ? (in 8-bit binary)" }, o: [{ vi: "00101010", en: "00101010" }, { vi: "11010110", en: "11010110" }, { vi: "11110110", en: "11110110" }, { vi: "00010101", en: "00010101" }], a: 0, explanation: { vi: "19 + 23 = 42. Trong hệ nhị phân 8-bit, 42 được viết là 00101010. Không có tràn số.", en: "19 + 23 = 42. In 8-bit binary, 42 is written as 00101010. There is no overflow." } },
                    { q: { vi: "Với 8-bit two’s complement, 19 − 23 = ? (kết quả dạng nhị phân)", en: "With 8-bit two's complement, 19 - 23 = ? (result in binary)" }, o: [{ vi: "11111100", en: "11111100" }, { vi: "00000100", en: "00000100" }, { vi: "11111011", en: "11111011" }, { vi: "00001100", en: "00001100" }], a: 0, explanation: { vi: "19 - 23 = -4. Biểu diễn bù hai 8-bit của -4 là 11111100.", en: "19 - 23 = -4. The 8-bit two's complement representation of -4 is 11111100." } },
                    { q: { vi: "Với 8-bit two’s complement, −19 + 23 = ?", en: "With 8-bit two's complement, -19 + 23 = ?" }, o: [{ vi: "00000100 (4)", en: "00000100 (4)" }, { vi: "11111100 (−4)", en: "11111100 (−4)" }, { vi: "11101101 (−19)", en: "11101101 (−19)" }, { vi: "00010110 (22)", en: "00010110 (22)" }], a: 0, explanation: { vi: "-19 + 23 = 4. Trong hệ nhị phân 8-bit, 4 được viết là 00000100.", en: "-19 + 23 = 4. In 8-bit binary, 4 is written as 00000100." } },
                    { q: { vi: "Tính (012A)₁₆ + (0E27)₁₆ trong 16-bit (hex):", en: "Calculate (012A)₁₆ + (0E27)₁₆ in 16-bit (hex):" }, o: [{ vi: "0F51", en: "0F51" }, { vi: "100F", en: "100F" }, { vi: "0D51", en: "0D51" }, { vi: "0E51", en: "0E51" }], a: 0, explanation: { vi: "Cộng theo từng cột từ phải sang: A+7=17=11₁₆ (viết 1 nhớ 1), 1+2+2=5, 1+E(14)=15=F, 0+0=0. Kết quả: 0F51.", en: "Adding column by column from the right: A+7=17=11₁₆ (write 1, carry 1), 1+2+2=5, 1+E(14)=15=F, 0+0=0. Result: 0F51." } },
                    { q: { vi: "Trong các phép sau (8-bit two’s complement), phép nào gây overflow?", en: "Among the following operations (8-bit two's complement), which one causes an overflow?" }, o: [{ vi: "01111111 + 00000011", en: "01111111 + 00000011" }, { vi: "11000010 + 00111111", en: "11000010 + 00111111" }, { vi: "00000010 + 00111111", en: "00000010 + 00111111" }, { vi: "00001111 + 00010000", en: "00001111 + 00010000" }], a: 0, explanation: { vi: "01111111 (+127) + 00000011 (+3) = +130. Giá trị này nằm ngoài phạm vi [-128, +127] của số bù hai 8-bit, do đó gây ra tràn số.", en: "01111111 (+127) + 00000011 (+3) = +130. This value is outside the [-128, +127] range of an 8-bit two's complement number, thus causing an overflow." } },
                    { q: { vi: "Kết quả cộng một số với two’s complement của chính nó (A + (A)₂c):", en: "The result of adding a number with its own two's complement (A + (A)₂c) is:" }, o: [{ vi: "0 (và có thể có carry)", en: "0 (and possibly a carry)" }, { vi: "All 1s (−1)", en: "All 1s (−1)" }, { vi: "A (giữ nguyên)", en: "A (unchanged)" }, { vi: "Undefined", en: "Undefined" }], a: 0, explanation: { vi: "Phép toán này tương đương với A + (-A), kết quả luôn là 0. Bit nhớ (carry) cuối cùng sẽ bị loại bỏ.", en: "This operation is equivalent to A + (-A), which always results in 0. The final carry bit is discarded." } },
                    { q: { vi: "Thao tác nào là unary (một toán hạng) trong chương này?", en: "Which operation is unary (one operand) in this chapter?" }, o: [{ vi: "AND", en: "AND" }, { vi: "OR", en: "OR" }, { vi: "XOR", en: "XOR" }, { vi: "NOT", en: "NOT" }], a: 3, explanation: { vi: "NOT là toán tử đơn (unary) vì nó chỉ hoạt động trên một đầu vào.", en: "NOT is a unary operator because it only works on one input." } },
                    { q: { vi: "AND, OR, XOR thuộc loại nào?", en: "What category do AND, OR, and XOR belong to?" }, o: [{ vi: "Unary", en: "Unary" }, { vi: "Binary", en: "Binary" }, { vi: "Ternary", en: "Ternary" }, { vi: "N/A", en: "N/A" }], a: 1, explanation: { vi: "Tất cả chúng đều là toán tử hai ngôi (binary), nghĩa là chúng hoạt động trên hai toán hạng đầu vào.", en: "They are all binary operators, meaning they operate on two input operands." } },
                    { q: { vi: "Trong truth table, AND trả về 1 khi:", en: "In a truth table, AND returns 1 when:" }, o: [{ vi: "ít nhất một input =1", en: "at least one input is 1" }, { vi: "cả hai input =1", en: "both inputs are 1" }, { vi: "chỉ một input =1", en: "only one input is 1" }, { vi: "cả hai input =0", en: "both inputs are 0" }], a: 1, explanation: { vi: "Phép AND chỉ đúng (1) khi tất cả các đầu vào của nó đều đúng (1).", en: "The AND operation is true (1) only when all of its inputs are true (1)." } },
                    { q: { vi: "OR (inclusive-or) trả về 0 khi:", en: "OR (inclusive-or) returns 0 when:" }, o: [{ vi: "cả hai input =0", en: "both inputs are 0" }, { vi: "ít nhất một input =1", en: "at least one input is 1" }, { vi: "cả hai input =1", en: "both inputs are 1" }, { vi: "không bao giờ 0", en: "never 0" }], a: 0, explanation: { vi: "Phép OR chỉ sai (0) khi tất cả các đầu vào của nó đều sai (0).", en: "The OR operation is false (0) only when all of its inputs are false (0)." } },
                    { q: { vi: "XOR trả về 1 khi:", en: "XOR returns 1 when:" }, o: [{ vi: "cả hai input giống nhau", en: "both inputs are the same" }, { vi: "hai input khác nhau", en: "the two inputs are different" }, { vi: "cả hai đều 1", en: "both are 1" }, { vi: "cả hai đều 0", en: "both are 0" }], a: 1, explanation: { vi: "XOR (Exclusive OR) trả về 1 chỉ khi các đầu vào của nó khác nhau (một là 1, một là 0).", en: "XOR (Exclusive OR) returns 1 only when its inputs are different (one is 1, the other is 0)." } },
                    { q: { vi: "Một ứng dụng của AND ở mức pattern là:", en: "An application of AND at the pattern level is:" }, o: [{ vi: "complement toàn bộ pattern", en: "complementing the entire pattern" }, { vi: "set (force to 1) bit cụ thể", en: "setting (force to 1) a specific bit" }, { vi: "unset (force to 0) bit cụ thể bằng mask", en: "unsetting (force to 0) a specific bit using a mask" }, { vi: "flip bit cụ thể", en: "flipping a specific bit" }], a: 2, explanation: { vi: "Phép AND với một mask có bit 0 tại một vị trí sẽ buộc bit tương ứng trong kết quả về 0, hay còn gọi là 'unset' hoặc 'clear'.", en: "The AND operation with a mask that has a 0 at a certain position will force the corresponding bit in the result to be 0, which is called 'unsetting' or 'clearing'." } },
                    { q: { vi: "Một ứng dụng của OR ở mức pattern là:", en: "An application of OR at the pattern level is:" }, o: [{ vi: "unset bit", en: "unsetting a bit" }, { vi: "set bit bằng mask có 1 ở vị trí cần set", en: "setting a bit using a mask with a 1 at the desired position" }, { vi: "lấy complement toàn bộ", en: "complementing the whole pattern" }, { vi: "xoay (rotate) bit", en: "rotating bits" }], a: 1, explanation: { vi: "Phép OR với một mask có bit 1 tại một vị trí sẽ buộc bit tương ứng trong kết quả về 1, hay còn gọi là 'set'.", en: "The OR operation with a mask that has a 1 at a certain position will force the corresponding bit in the result to be 1, which is called 'setting'." } },
                    { q: { vi: "Một ứng dụng của XOR ở mức pattern là:", en: "An application of XOR at the pattern level is:" }, o: [{ vi: "set bit", en: "setting a bit" }, { vi: "unset bit", en: "unsetting a bit" }, { vi: "flip (complement) bit được chọn", en: "flipping (complementing) selected bits" }, { vi: "trả về số bit 1", en: "returning the number of 1s" }], a: 2, explanation: { vi: "Phép XOR với một mask có bit 1 tại một vị trí sẽ đảo (flip) bit tương ứng trong pattern (0 thành 1, 1 thành 0).", en: "The XOR operation with a mask that has a 1 at a certain position will invert (flip) the corresponding bit in the pattern (0 becomes 1, 1 becomes 0)." } },
                    { q: { vi: "NOT trên một pattern tương đương với:", en: "A NOT on a pattern is equivalent to:" }, o: [{ vi: "one's complement", en: "one's complement" }, { vi: "two’s complement", en: "two’s complement" }, { vi: "mask OR", en: "mask OR" }, { vi: "mask AND", en: "mask AND" }], a: 0, explanation: { vi: "Phép NOT đảo tất cả các bit của một pattern, đây chính là định nghĩa của phép bù 1 (one's complement).", en: "The NOT operation inverts all bits of a pattern, which is the definition of the one's complement." } },
                    { q: { vi: "Logical shift được áp dụng cho:", en: "Logical shift is applied to:" }, o: [{ vi: "mẫu không đại diện số dấu", en: "patterns not representing signed numbers" }, { vi: "số dấu (signed) bắt buộc", en: "signed numbers exclusively" }, { vi: "floating point only", en: "floating point only" }, { vi: "tất cả trên", en: "all of the above" }], a: 0, explanation: { vi: "Phép dịch logic xử lý chuỗi bit như một tập hợp các bit đơn thuần, không quan tâm đến bit dấu. Nó phù hợp cho số không dấu.", en: "Logical shift treats the bit string as a simple collection of bits, without regard for a sign bit. It is suitable for unsigned numbers." } },
                    { q: { vi: "Arithmetic shift giả định:", en: "Arithmetic shift assumes:" }, o: [{ vi: "pattern là unsigned integer", en: "the pattern is an unsigned integer" }, { vi: "pattern là signed integer (two’s complement)", en: "the pattern is a signed integer (two's complement)" }, { vi: "pattern là string", en: "the pattern is a string" }, { vi: "pattern là floating point", en: "the pattern is a floating point" }], a: 1, explanation: { vi: "Phép dịch số học được thiết kế đặc biệt để bảo toàn dấu của số bù hai khi thực hiện dịch phải.", en: "Arithmetic shift is specifically designed to preserve the sign of a two's complement number during a right shift." } },
                    { q: { vi: "Simple right shift (logical right) chèn bit gì vào bên trái?", en: "A simple right shift (logical right) inserts what bit on the left?" }, o: [{ vi: "1", en: "1" }, { vi: "0", en: "0" }, { vi: "phụ thuộc sign", en: "depends on the sign" }, { vi: "giữ bit cũ", en: "keeps the old bit" }], a: 1, explanation: { vi: "Trong phép dịch logic, bit 0 luôn được chèn vào vị trí trống.", en: "In a logical shift, a 0 is always inserted into the vacant position." } },
                    { q: { vi: "Circular shift (rotate) khác simple shift ở điểm:", en: "A circular shift (rotate) differs from a simple shift in that:" }, o: [{ vi: "mất bit trái nhất", en: "it loses the leftmost bit" }, { vi: "không mất/không thêm bit — bit bị dịch được quay vòng", en: "it neither loses nor adds bits — the shifted bit is rotated" }, { vi: "luôn chèn 0", en: "it always inserts a 0" }, { vi: "chỉ áp dụng cho signed numbers", en: "it only applies to signed numbers" }], a: 1, explanation: { vi: "Phép dịch vòng (rotate) bảo toàn tất cả các bit bằng cách di chuyển bit bị đẩy ra từ một đầu sang đầu kia.", en: "A rotate operation preserves all bits by moving the bit that falls off one end to the other end." } },
                    { q: { vi: "Trong arithmetic right shift (two’s complement), khi shift phải, bit mới chèn vào trái là:", en: "In an arithmetic right shift (two's complement), when shifting right, the new bit inserted on the left is:" }, o: [{ vi: "0 luôn", en: "always 0" }, { vi: "bit dấu cũ (sign bit) — giữ dấu", en: "the old sign bit — preserving the sign" }, { vi: "bit ngẫu nhiên", en: "a random bit" }, { vi: "1 luôn", en: "always 1" }], a: 1, explanation: { vi: "Để giữ đúng giá trị của số âm (ví dụ, chia một số âm cho 2), bit dấu phải được sao chép vào vị trí trống bên trái.", en: "To maintain the correct value of a negative number (e.g., dividing a negative number by 2), the sign bit must be copied into the vacant leftmost position." } },
                    { q: { vi: "Overflow khi cộng hai số two's complement xảy ra khi:", en: "Overflow when adding two two's complement numbers occurs when:" }, o: [{ vi: "hai số cùng dấu và kết quả khác dấu", en: "two numbers of the same sign result in a different sign" }, { vi: "hai số khác dấu", en: "the two numbers have different signs" }, { vi: "luôn khi có carry out từ MSB", en: "always when there is a carry out from the MSB" }, { vi: "chỉ khi cả hai âm", en: "only when both are negative" }], a: 0, explanation: { vi: "Đây là quy tắc phát hiện tràn số: cộng hai số dương ra kết quả âm, hoặc cộng hai số âm ra kết quả dương.", en: "This is the rule for overflow detection: adding two positive numbers yields a negative result, or adding two negative numbers yields a positive result." } },
                    { q: { vi: "Khi cộng hai two's complement 8-bit, carry ra khỏi cột trái cùng (MSB carry) được:", en: "When adding two 8-bit two's complement numbers, the carry out of the leftmost column (MSB carry) is:" }, o: [{ vi: "giữ làm một bit của kết quả 9-bit", en: "kept as a bit of a 9-bit result" }, { vi: "bỏ (discard)", en: "discarded" }, { vi: "nhân với 2", en: "multiplied by 2" }, { vi: "chuyển sang LSB", en: "moved to the LSB" }], a: 1, explanation: { vi: "Trong phép toán số học với kích thước cố định, bit nhớ cuối cùng không phải là một phần của kết quả và bị loại bỏ.", en: "In fixed-size arithmetic, the final carry bit is not part of the result and is discarded." } },
                    { q: { vi: "Lợi thế chính của two’s complement là:", en: "The main advantage of two's complement is:" }, o: [{ vi: "cần 2 biểu diễn cho 0", en: "it needs 2 representations for 0" }, { vi: "có phép cộng và phép trừ khác nhau phức tạp", en: "it has complex and different addition and subtraction operations" }, { vi: "phép cộng và trừ xử lý giống nhau (dễ hiện thực)", en: "addition and subtraction are handled the same way (easy to implement)" }, { vi: "không thể biểu diễn số âm", en: "it cannot represent negative numbers" }], a: 2, explanation: { vi: "Việc có thể thực hiện phép trừ A-B bằng cách tính A + (bù hai của B) cho phép sử dụng cùng một mạch cộng cho cả hai phép toán, đơn giản hóa thiết kế CPU.", en: "Being able to perform subtraction A-B by calculating A + (two's complement of B) allows the same adder circuit to be used for both operations, simplifying CPU design." } },
                    { q: { vi: "Giá trị biểu diễn lớn nhất của 8-bit two’s complement là:", en: "The largest representable value of an 8-bit two's complement is:" }, o: [{ vi: "255", en: "255" }, { vi: "127", en: "127" }, { vi: "−1", en: "-1" }, { vi: "128", en: "128" }], a: 1, explanation: { vi: "Phạm vi của số bù hai n-bit là từ -2ⁿ⁻¹ đến +2ⁿ⁻¹-1. Với n=8, giá trị lớn nhất là +2⁷-1 = 127.", en: "The range of an n-bit two's complement number is from -2ⁿ⁻¹ to +2ⁿ⁻¹-1. For n=8, the maximum value is +2⁷-1 = 127." } },
                    { q: { vi: "Giá trị nhỏ nhất (most negative) của 8-bit two’s complement là:", en: "The smallest (most negative) value of an 8-bit two's complement is:" }, o: [{ vi: "−128", en: "-128" }, { vi: "−127", en: "-127" }, { vi: "0", en: "0" }, { vi: "−256", en: "-256" }], a: 0, explanation: { vi: "Phạm vi của số bù hai n-bit là từ -2ⁿ⁻¹ đến +2ⁿ⁻¹-1. Với n=8, giá trị nhỏ nhất là -2⁷ = -128.", en: "The range of an n-bit two's complement number is from -2ⁿ⁻¹ to +2ⁿ⁻¹-1. For n=8, the minimum value is -2⁷ = -128." } },
                    { q: { vi: "Một truth table mô tả:", en: "A truth table describes:" }, o: [{ vi: "cách biểu diễn số thập phân", en: "how to represent decimal numbers" }, { vi: "cách xác định output cho mọi tổ hợp input", en: "how to determine the output for all input combinations" }, { vi: "bảng mã hóa ký tự", en: "a character encoding table" }, { vi: "đồ thị liên kết", en: "a linkage graph" }], a: 1, explanation: { vi: "Một bảng chân lý (truth table) liệt kê một cách có hệ thống tất cả các kết quả đầu ra có thể có của một hàm logic cho mọi kết hợp đầu vào có thể có.", en: "A truth table systematically lists all possible outputs of a logical function for every possible combination of inputs." } },
                    { q: { vi: "Biểu thức x XOR 1 cho kết quả:", en: "The expression x XOR 1 results in:" }, o: [{ vi: "x (không đổi)", en: "x (unchanged)" }, { vi: "NOT x (lật bit)", en: "NOT x (flipped bit)" }, { vi: "1", en: "1" }, { vi: "0", en: "0" }], a: 1, explanation: { vi: "0 XOR 1 = 1 (NOT 0). 1 XOR 1 = 0 (NOT 1). Do đó, XOR với 1 luôn đảo ngược giá trị của x.", en: "0 XOR 1 = 1 (NOT 0). 1 XOR 1 = 0 (NOT 1). Therefore, XORing with 1 always inverts the value of x." } },
                    { q: { vi: "Biểu thức x OR 1 cho kết quả:", en: "The expression x OR 1 results in:" }, o: [{ vi: "1", en: "1" }, { vi: "x", en: "x" }, { vi: "NOT x", en: "NOT x" }, { vi: "0", en: "0" }], a: 0, explanation: { vi: "Bất kỳ giá trị nào OR với 1 cũng sẽ cho kết quả là 1. Đây là thuộc tính 'annihilator' của OR.", en: "Any value ORed with 1 will result in 1. This is the 'annihilator' property of OR." } },
                    { q: { vi: "Mask dùng để unset (clear) bit i (0-index LSB) phải có:", en: "A mask used to unset (clear) bit i (0-indexed from LSB) must have:" }, o: [{ vi: "1 ở bit i", en: "a 1 at bit i" }, { vi: "0 ở bit i và 1 ở các bit khác", en: "a 0 at bit i and 1s at other bits" }, { vi: "0 ở tất cả bit", en: "0s at all bits" }, { vi: "1 ở tất cả bit", en: "1s at all bits" }], a: 1, explanation: { vi: "Để unset một bit, ta dùng phép AND. AND với 0 sẽ cho kết quả là 0, trong khi AND với 1 sẽ giữ nguyên bit ban đầu.", en: "To unset a bit, we use the AND operation. ANDing with 0 results in 0, while ANDing with 1 preserves the original bit." } },
                    { q: { vi: "Mask để flip (complement) một số bit là dùng phép:", en: "A mask to flip (complement) some bits uses which operation?" }, o: [{ vi: "AND", en: "AND" }, { vi: "OR", en: "OR" }, { vi: "XOR", en: "XOR" }, { vi: "NOT", en: "NOT" }], a: 2, explanation: { vi: "Phép XOR với 1 sẽ đảo bit, trong khi XOR với 0 sẽ giữ nguyên bit. Điều này cho phép lật bit một cách có chọn lọc.", en: "XORing with 1 flips a bit, while XORing with 0 preserves it. This allows for selective bit flipping." } },
                    { q: { vi: "Dịch trái logic một pattern thường tương đương với phép toán số nguyên:", en: "A logical left shift on a pattern is often equivalent to which integer operation?" }, o: [{ vi: "chia cho 2", en: "division by 2" }, { vi: "nhân ×2 (nếu không overflow)", en: "multiplication by 2 (if no overflow)" }, { vi: "XOR với 2", en: "XOR with 2" }, { vi: "cộng 1", en: "adding 1" }], a: 1, explanation: { vi: "Mỗi lần dịch trái một vị trí sẽ nhân giá trị của số (không dấu) lên 2, miễn là bit quan trọng nhất không bị mất.", en: "Each left shift by one position multiplies the value of the (unsigned) number by 2, as long as the most significant bit is not lost." } },
                    { q: { vi: "Dịch phải logic một pattern unsigned tương đương với:", en: "A logical right shift on an unsigned pattern is equivalent to:" }, o: [{ vi: "nhân ×2", en: "multiplication by 2" }, { vi: "chia cho 2 (floor)", en: "division by 2 (floor)" }, { vi: "invert bits", en: "inverting bits" }, { vi: "rotate right", en: "rotating right" }], a: 1, explanation: { vi: "Mỗi lần dịch phải một vị trí sẽ chia giá trị của số không dấu cho 2, làm tròn xuống (floor division).", en: "Each right shift by one position divides the value of the unsigned number by 2, performing a floor division." } },
                    { q: { vi: "Trong floating-point addition, bước quan trọng để thực hiện phép cộng là:", en: "In floating-point addition, what is the crucial step to perform the addition?" }, o: [{ vi: "đổi sang two’s complement trước", en: "converting to two's complement first" }, { vi: "align (căn) các exponent trước khi cộng mantissa", en: "aligning the exponents before adding the mantissas" }, { vi: "dùng XOR để cộng mantissa", en: "using XOR to add the mantissas" }, { vi: "swap bits", en: "swapping bits" }], a: 1, explanation: { vi: "Không thể cộng trực tiếp các phần định trị (mantissa) trừ khi các số mũ (exponent) của chúng bằng nhau. Do đó, cần phải dịch chuyển một trong các mantissa để làm cho các số mũ khớp nhau.", en: "The mantissas cannot be added directly unless their exponents are equal. Therefore, one of the mantissas must be shifted to make the exponents match." } },
                    { q: { vi: "Phép toán để kiểm tra “bit i có 1 hay không” thường là:", en: "The operation to check 'if bit i is 1' is usually:" }, o: [{ vi: "shift phải i lần rồi AND với 1", en: "shift right i times then AND with 1" }, { vi: "shift trái i lần rồi AND với 1", en: "shift left i times then AND with 1" }, { vi: "OR với 1 rồi so sánh", en: "OR with 1 and then compare" }, { vi: "XOR với 1 rồi so sánh", en: "XOR with 1 and then compare" }], a: 0, explanation: { vi: "Đây là một kỹ thuật phổ biến: dịch chuyển bit cần kiểm tra đến vị trí cuối cùng (LSB), sau đó dùng mask '1' để cô lập nó. Nếu kết quả khác không, bit đó là 1.", en: "This is a common technique: shift the bit to be tested to the last position (LSB), then use a mask of '1' to isolate it. If the result is non-zero, the bit was 1." } },
                    { q: { vi: "“Arithmetic shift” và “logical shift” khác nhau chủ yếu ở việc:", en: "'Arithmetic shift' and 'logical shift' differ mainly in that:" }, o: [{ vi: "arithmetic chèn sign bit khi shift phải", en: "arithmetic inserts the sign bit when shifting right" }, { vi: "logical chèn sign bit khi shift phải", en: "logical inserts the sign bit when shifting right" }, { vi: "arithmetic chỉ dùng cho rotate", en: "arithmetic is only for rotation" }, { vi: "không khác nhau", en: "there is no difference" }], a: 0, explanation: { vi: "Sự khác biệt cốt lõi là cách xử lý bit được chèn vào khi dịch phải. Dịch số học (arithmetic) bảo toàn bit dấu, trong khi dịch logic luôn chèn 0.", en: "The core difference is how the inserted bit is handled on a right shift. Arithmetic shift preserves the sign bit, while logical shift always inserts a 0." } },
                    { q: { vi: "Nếu x OR (NOT x) cho kết quả:", en: "If x OR (NOT x), the result is:" }, o: [{ vi: "0", en: "0" }, { vi: "1 (all 1s tại mọi bit)", en: "1 (all 1s at every bit)" }, { vi: "x", en: "x" }, { vi: "NOT x", en: "NOT x" }], a: 1, explanation: { vi: "Tại mỗi vị trí bit, một trong hai toán hạng (x hoặc NOT x) phải là 1. Do đó, kết quả của phép OR sẽ luôn là 1 ở mọi vị trí.", en: "At every bit position, one of the two operands (x or NOT x) must be 1. Therefore, the result of the OR operation will always be 1 at every position." } },
                    { q: { vi: "Nếu x AND (NOT x) luôn cho:", en: "If x AND (NOT x), the result is always:" }, o: [{ vi: "all 1s", en: "all 1s" }, { vi: "all 0s", en: "all 0s" }, { vi: "x", en: "x" }, { vi: "NOT x", en: "NOT x" }], a: 1, explanation: { vi: "Tại mỗi vị trí bit, nếu bit của x là 1, bit của NOT x là 0, và ngược lại. Do đó, không có vị trí nào cả hai bit đều là 1, nên kết quả là 0 ở mọi vị trí.", en: "At every bit position, if the bit of x is 1, the bit of NOT x is 0, and vice-versa. Therefore, at no position are both bits 1, so the result is 0 at every position." } }
                ]
            },
            chapter5: {
                 theory: {
                    vi: `
                        <h2>Chương 5: Tổ chức Máy tính</h2>
                        <h3>1. Các thành phần chính</h3>
                        <ul>
                            <li><strong>CPU (Central Processing Unit):</strong> "Bộ não" của máy tính. Gồm 3 phần: ALU (tính toán), Control Unit (điều khiển), và Registers (thanh ghi).</li>
                            <li><strong>Bộ nhớ chính (Main Memory):</strong> Thường là RAM, lưu trữ chương trình và dữ liệu đang chạy.</li>
                            <li><strong>Hệ thống Vào/Ra (I/O Subsystem):</strong> Giao tiếp với các thiết bị ngoại vi.</li>
                        </ul>
                        <h3>2. Phân cấp bộ nhớ (Memory Hierarchy)</h3>
                        <p>Tốc độ và giá thành giảm dần, dung lượng tăng dần khi đi ra xa CPU:</p>
                        <p><span class="highlight">Registers → Cache → Main Memory → Storage (Ổ cứng)</span></p>
                        <h3>3. Chu kỳ máy (Machine Cycle)</h3>
                        <ul>
                             <li>Quá trình CPU thực thi một lệnh. Gồm 3 bước cơ bản:
                                <ol>
                                    <li><span class="highlight">Fetch (Nạp lệnh):</span> Lấy lệnh từ bộ nhớ.</li>
                                    <li><span class="highlight">Decode (Giải mã):</span> Hiểu xem lệnh yêu cầu làm gì.</li>
                                    <li><span class="highlight">Execute (Thực thi):</span> Thực hiện lệnh đó.</li>
                                </ol>
                            </li>
                        </ul>
                    `,
                    en: `
                        <h2>Chapter 5: Computer Organization</h2>
                        <h3>1. Main Components</h3>
                        <ul>
                           <li><strong>CPU (Central Processing Unit):</strong> The "brain" of the computer. Contains 3 parts: ALU (calculation), Control Unit (control), and Registers.</li>
                            <li><strong>Main Memory:</strong> Usually RAM, stores currently running programs and data.</li>
                            <li><strong>I/O Subsystem:</strong> Communicates with peripheral devices.</li>
                        </ul>
                        <h3>2. Memory Hierarchy</h3>
                        <p>Speed and cost decrease, while capacity increases, moving away from the CPU:</p>
                        <p><span class="highlight">Registers → Cache → Main Memory → Storage (Hard Drive)</span></p>
                        <h3>3. Machine Cycle</h3>
                        <ul>
                             <li>The repetitive process by which the CPU executes one instruction. Consists of 3 basic steps:
                                <ol>
                                    <li><span class="highlight">Fetch:</span> Get the instruction from memory.</li>
                                    <li><span class="highlight">Decode:</span> Understand what the instruction wants to do.</li>
                                    <li><span class="highlight">Execute:</span> Perform the instruction.</li>
                                </ol>
                            </li>
                        </ul>
                    `
                },
                questions: [
                    { q: { vi: "Máy tính gồm mấy hệ thống con chính?", en: "How many main subsystems does a computer consist of?" }, o: [{ vi: "2 — CPU và Memory", en: "2 — CPU and Memory" }, { vi: "3 — CPU, Main memory, I/O subsystem", en: "3 — CPU, Main memory, I/O subsystem" }, { vi: "4 — CPU, Memory, I/O, GPU", en: "4 — CPU, Memory, I/O, GPU" }, { vi: "5 — CPU, Memory, I/O, Cache, Bus", en: "5 — CPU, Memory, I/O, Cache, Bus" }], a: 1, explanation: { vi: "Theo mô hình đơn giản hóa, máy tính có 3 thành phần chính: CPU để xử lý, Main Memory để lưu trữ tạm thời, và I/O Subsystem để giao tiếp.", en: "According to the simplified model, a computer has 3 main components: the CPU for processing, Main Memory for temporary storage, and the I/O Subsystem for communication." } },
                    { q: { vi: "CPU thường gồm những thành phần nào?", en: "What components does a CPU typically consist of?" }, o: [{ vi: "ALU, Control unit, Registers", en: "ALU, Control unit, Registers" }, { vi: "ALU, Hard drive, Network card", en: "ALU, Hard drive, Network card" }, { vi: "Cache, Disk controller, Monitor", en: "Cache, Disk controller, Monitor" }, { vi: "Keyboard, Mouse, Printer", en: "Keyboard, Mouse, Printer" }], a: 0, explanation: { vi: "CPU có ba khối chức năng cốt lõi: ALU (tính toán), Control Unit (điều khiển), và Registers (lưu trữ siêu nhanh).", en: "The CPU has three core functional blocks: the ALU (arithmetic/logic), the Control Unit (coordination), and Registers (super-fast storage)." } },
                    { q: { vi: "Chức năng chính của Program Counter (PC) là gì?", en: "What is the main function of the Program Counter (PC)?" }, o: [{ vi: "Lưu dữ liệu tạm thời", en: "To store temporary data" }, { vi: "Giữ địa chỉ lệnh tiếp theo cần thực thi", en: "To hold the address of the next instruction to be executed" }, { vi: "Thực hiện phép toán số học", en: "To perform arithmetic operations" }, { vi: "Điều khiển tốc độ bus", en: "To control the bus speed" }], a: 1, explanation: { vi: "PC luôn trỏ đến lệnh tiếp theo trong bộ nhớ, cho phép CPU thực thi chương trình một cách tuần tự.", en: "The PC always points to the next instruction in memory, allowing the CPU to execute a program sequentially." } },
                    { q: { vi: "Instruction Register (IR) dùng để làm gì?", en: "What is the Instruction Register (IR) used for?" }, o: [{ vi: "Lưu toàn bộ chương trình", en: "To store the entire program" }, { vi: "Lưu lệnh hiện đang được thực thi (mã lệnh)", en: "To store the instruction currently being executed (opcode)" }, { vi: "Tăng/giảm giá trị của thanh ghi", en: "To increment/decrement the value of a register" }, { vi: "Kết nối I/O với bộ nhớ", en: "To connect I/O with memory" }], a: 1, explanation: { vi: "Sau khi lệnh được nạp (fetch) từ bộ nhớ, nó được đặt vào IR để Control Unit có thể giải mã và thực thi.", en: "After an instruction is fetched from memory, it is placed in the IR so the Control Unit can decode and execute it." } },
                    { q: { vi: "ALU không thực hiện tác vụ nào dưới đây?", en: "Which of the following tasks is NOT performed by the ALU?" }, o: [{ vi: "Toán học (cộng, trừ)", en: "Arithmetic (add, subtract)" }, { vi: "Phép logic (AND, OR, NOT)", en: "Logic operations (AND, OR, NOT)" }, { vi: "Ghi/đọc đĩa cứng (disk I/O)", en: "Reading/writing to the hard disk (disk I/O)" }, { vi: "Dịch bit (shift, rotate)", en: "Bit shifting (shift, rotate)" }], a: 2, explanation: { vi: "ALU là đơn vị tính toán và logic. Việc giao tiếp với thiết bị lưu trữ như đĩa cứng là nhiệm vụ của I/O subsystem và controllers.", en: "The ALU is the arithmetic and logic unit. Communicating with storage devices like hard disks is the job of the I/O subsystem and controllers." } },
                    { q: { vi: "Data bus có nhiệm vụ gì chính?", en: "What is the main task of the data bus?" }, o: [{ vi: "Mang địa chỉ bộ nhớ", en: "To carry memory addresses" }, { vi: "Mang dữ liệu giữa CPU và bộ nhớ", en: "To carry data between the CPU and memory" }, { vi: "Mang tín hiệu điều khiển (read/write)", en: "To carry control signals (read/write)" }, { vi: "Mang tín hiệu đồng hồ (clock)", en: "To carry clock signals" }], a: 1, explanation: { vi: "Đúng như tên gọi, data bus là con đường để di chuyển dữ liệu thực tế (các bit của chương trình hoặc dữ liệu) qua lại.", en: "As its name implies, the data bus is the pathway for moving the actual data (the bits of a program or data) back and forth." } },
                    { q: { vi: "Nếu bộ nhớ có 2^n words thì address bus cần bao nhiêu dây?", en: "If a memory has 2^n words, how many wires does the address bus need?" }, o: [{ vi: "n/2 dây", en: "n/2 wires" }, { vi: "2^n dây", en: "2^n wires" }, { vi: "n dây", en: "n wires" }, { vi: "1 dây", en: "1 wire" }], a: 2, explanation: { vi: "Để có thể định danh duy nhất 2^n vị trí khác nhau, bạn cần n bit địa chỉ. Mỗi bit cần một dây dẫn.", en: "To uniquely identify 2^n different locations, you need n bits of address. Each bit requires one wire." } },
                    { q: { vi: "Control bus dùng để:", en: "The control bus is used to:" }, o: [{ vi: "Truyền dữ liệu 8 bit mỗi lần", en: "Transmit 8 bits of data at a time" }, { vi: "Gửi các tín hiệu điều khiển như read/write, interrupts", en: "Send control signals like read/write, interrupts" }, { vi: "Chứa địa chỉ của thiết bị I/O", en: "Contain the address of an I/O device" }, { vi: "Lưu chương trình tạm thời", en: "Store a program temporarily" }], a: 1, explanation: { vi: "Control bus điều phối hoạt động của hệ thống, mang các tín hiệu như 'bộ nhớ đọc', 'bộ nhớ ghi', 'thiết bị I/O đã sẵn sàng', v.v.", en: "The control bus coordinates the system's activities, carrying signals like 'memory read', 'memory write', 'I/O device is ready', etc." } },
                    { q: { vi: "Trong hệ thống phân cấp bộ nhớ, thành phần nào nhanh nhất nhưng đắt nhất?", en: "In the memory hierarchy, which component is the fastest but also the most expensive?" }, o: [{ vi: "Main memory", en: "Main memory" }, { vi: "Cache", en: "Cache" }, { vi: "Registers (thanh ghi)", en: "Registers" }, { vi: "Disk", en: "Disk" }], a: 2, explanation: { vi: "Thanh ghi (registers) nằm ngay bên trong lõi CPU, được làm từ công nghệ nhanh nhất (và đắt nhất), do đó có tốc độ truy cập gần như tức thời.", en: "Registers are located right inside the CPU core, made from the fastest (and most expensive) technology, giving them near-instant access speeds." } },
                    { q: { vi: "Đâu là nhiệm vụ chính của address bus?", en: "What is the main task of the address bus?" }, o: [{ vi: "Chỉ ra địa chỉ ô nhớ cần truy xuất", en: "To specify the address of the memory location to be accessed" }, { vi: "Truyền dữ liệu giữa CPU và I/O", en: "To transfer data between the CPU and I/O" }, { vi: "Thực hiện phép cộng nhị phân", en: "To perform binary addition" }, { vi: "Điều khiển tốc độ quạt CPU", en: "To control the CPU fan speed" }], a: 0, explanation: { vi: "Address bus chỉ có một chiều (từ CPU ra ngoài) và mang địa chỉ của ô nhớ hoặc cổng I/O mà CPU muốn tương tác.", en: "The address bus is unidirectional (from the CPU outwards) and carries the address of the memory location or I/O port that the CPU wants to interact with." } },
                    { q: { vi: "Điểm khác nhau cơ bản giữa RAM và ROM là gì?", en: "What is the fundamental difference between RAM and ROM?" }, o: [{ vi: "RAM chỉ đọc, ROM đọc/ghi", en: "RAM is read-only, ROM is read/write" }, { vi: "RAM volatile (mất khi tắt), ROM non-volatile", en: "RAM is volatile (lost on power-off), ROM is non-volatile" }, { vi: "RAM là thiết bị lưu trữ lâu dài, ROM là bộ nhớ tạm thời", en: "RAM is long-term storage, ROM is temporary memory" }, { vi: "RAM chỉ dùng cho I/O, ROM chỉ dùng cho CPU", en: "RAM is only for I/O, ROM is only for the CPU" }], a: 1, explanation: { vi: "Volatile (khả biến) là đặc tính quan trọng nhất. Dữ liệu trong RAM biến mất khi mất điện, trong khi dữ liệu trong ROM (như firmware BIOS) vẫn còn.", en: "Volatility is the most important characteristic. Data in RAM vanishes when power is lost, while data in ROM (like BIOS firmware) persists." } },
                    { q: { vi: "SRAM khác DRAM ở chỗ nào?", en: "How does SRAM differ from DRAM?" }, o: [{ vi: "SRAM dùng tụ điện, DRAM dùng flip-flop", en: "SRAM uses capacitors, DRAM uses flip-flops" }, { vi: "SRAM cần refresh định kỳ, DRAM không cần", en: "SRAM needs periodic refreshing, DRAM does not" }, { vi: "SRAM dùng flip-flop (không cần refresh) và nhanh hơn; DRAM dùng capacitor (cần refresh) và rẻ hơn", en: "SRAM uses flip-flops (no refresh needed) and is faster; DRAM uses capacitors (needs refresh) and is cheaper" }, { vi: "SRAM là lưu trữ ngoài, DRAM là trong CPU", en: "SRAM is external storage, DRAM is in the CPU" }], a: 2, explanation: { vi: "SRAM (Static RAM) dùng mạch flip-flop để giữ bit, nhanh nhưng tốn diện tích và đắt. DRAM (Dynamic RAM) dùng tụ điện, cần được làm tươi (refresh) liên tục, chậm hơn nhưng rẻ và có mật độ cao hơn.", en: "SRAM (Static RAM) uses flip-flop circuits to hold a bit, which is fast but bulky and expensive. DRAM (Dynamic RAM) uses a capacitor, needs constant refreshing, is slower, but is cheaper and denser." } },
                    { q: { vi: "EEPROM khác EPROM ở điểm nào?", en: "How does EEPROM differ from EPROM?" }, o: [{ vi: "EEPROM không thể xóa, EPROM có thể xóa điện tử", en: "EEPROM cannot be erased, EPROM can be erased electronically" }, { vi: "EPROM xóa bằng ánh sáng UV; EEPROM có thể xóa bằng xung điện mà không tháo IC ra", en: "EPROM is erased by UV light; EEPROM can be erased by an electrical pulse without removing the IC" }, { vi: "EEPROM chỉ đọc, EPROM đọc/ghi", en: "EEPROM is read-only, EPROM is read/write" }, { vi: "Không khác nhau", en: "There is no difference" }], a: 1, explanation: { vi: "EPROM (Erasable PROM) cần tháo ra và chiếu tia cực tím để xóa. EEPROM (Electrically Erasable PROM) tiện lợi hơn nhiều vì nó có thể được xóa và lập trình lại bằng điện ngay trên bo mạch.", en: "EPROM (Erasable PROM) needs to be removed and exposed to UV light for erasure. EEPROM (Electrically Erasable PROM) is much more convenient as it can be erased and reprogrammed electrically while still on the circuit board." } },
                    { q: { vi: "Một máy có bộ nhớ 32 MB (byte-addressable). Cần bao nhiêu bit để địa chỉ từng byte?", en: "A machine has 32 MB of byte-addressable memory. How many bits are needed to address each byte?" }, o: [{ vi: "20 bit", en: "20 bits" }, { vi: "24 bit", en: "24 bits" }, { vi: "25 bit", en: "25 bits" }, { vi: "32 bit", en: "32 bits" }], a: 2, explanation: { vi: "32 MB = 32 * 2^20 bytes = 2^5 * 2^20 bytes = 2^25 bytes. Do đó, cần 25 bit để địa chỉ 2^25 byte khác nhau.", en: "32 MB = 32 * 2^20 bytes = 2^5 * 2^20 bytes = 2^25 bytes. Therefore, 25 bits are needed to address 2^25 different bytes." } },
                    { q: { vi: "Máy có 128 MB bộ nhớ, mỗi từ (word) dài 8 bytes. Cần bao nhiêu bit để địa chỉ mỗi word?", en: "A machine has 128 MB of memory, and each word is 8 bytes. How many bits are needed to address each word?" }, o: [{ vi: "21 bit", en: "21 bits" }, { vi: "24 bit", en: "24 bits" }, { vi: "27 bit", en: "27 bits" }, { vi: "30 bit", en: "30 bits" }], a: 1, explanation: { vi: "Tổng số byte = 128 MB = 2^7 * 2^20 = 2^27 bytes. Số lượng từ = (Tổng số byte) / (Số byte mỗi từ) = 2^27 / 8 = 2^27 / 2^3 = 2^24 từ. Cần 24 bit để địa chỉ 2^24 từ.", en: "Total bytes = 128 MB = 2^7 * 2^20 = 2^27 bytes. Number of words = (Total bytes) / (Bytes per word) = 2^27 / 8 = 2^27 / 2^3 = 2^24 words. 24 bits are needed to address 2^24 words." } },
                    { q: { vi: "Cache thường đặt ở đâu trong hệ thống bộ nhớ?", en: "Where is the cache typically placed in the memory system?" }, o: [{ vi: "Sau ổ cứng", en: "After the hard disk" }, { vi: "Giữa CPU và main memory", en: "Between the CPU and main memory" }, { vi: "Trước keyboard", en: "Before the keyboard" }, { vi: "Bên ngoài hệ thống I/O", en: "Outside the I/O system" }], a: 1, explanation: { vi: "Cache đóng vai trò là bộ đệm tốc độ cao giữa CPU cực nhanh và main memory (RAM) chậm hơn đáng kể.", en: "The cache acts as a high-speed buffer between the extremely fast CPU and the significantly slower main memory (RAM)." } },
                    { q: { vi: "Khi CPU cần truy xuất một từ ở main memory, trình tự đúng là:", en: "When the CPU needs to access a word in main memory, the correct sequence is:" }, o: [{ vi: "Truy cập main memory trực tiếp", en: "Access main memory directly" }, { vi: "Kiểm tra cache; nếu có thì lấy, nếu không thì đọc block từ main memory vào cache rồi lấy", en: "Check the cache; if present (hit), get it. If not (miss), read a block from main memory into the cache, then get it." }, { vi: "Gửi lệnh cho I/O controller", en: "Send a command to the I/O controller" }, { vi: "Dừng CPU và chờ interrupt", en: "Halt the CPU and wait for an interrupt" }], a: 1, explanation: { vi: "Đây là nguyên tắc hoạt động cơ bản của cache. Luôn kiểm tra cache trước. Nếu 'cache miss', mới phải truy cập main memory chậm hơn.", en: "This is the fundamental principle of cache operation. Always check the cache first. A 'cache miss' necessitates an access to the slower main memory." } },
                    { q: { vi: "“80–20 rule” trong ngữ cảnh cache ám chỉ gì?", en: "What does the '80-20 rule' imply in the context of a cache?" }, o: [{ vi: "80% dữ liệu lưu trữ ở 20% địa chỉ của disk", en: "80% of data is stored in 20% of the disk's addresses" }, { vi: "80% thời gian CPU truy cập 20% dữ liệu — cache giữ vùng 20% đó để tăng tốc ~80% thời gian", en: "80% of the time, the CPU accesses 20% of the data — the cache holds that 20% region to speed up ~80% of accesses" }, { vi: "Cache chiếm 80% bộ nhớ chính", en: "The cache takes up 80% of the main memory" }, { vi: "20% bộ nhớ là non-volatile", en: "20% of the memory is non-volatile" }], a: 1, explanation: { vi: "Quy tắc này là một cách diễn đạt của nguyên lý cục bộ (locality principle). Hầu hết các chương trình dành phần lớn thời gian hoạt động trên một phần nhỏ mã và dữ liệu. Cache tận dụng điều này bằng cách lưu trữ phần nhỏ đó.", en: "This rule is an expression of the locality principle. Most programs spend most of their time in a small fraction of their code and data. The cache exploits this by storing that small fraction." } },
                    { q: { vi: "So sánh tốc độ: registers, cache, main memory, disk — thứ tự nào đúng từ nhanh nhất đến chậm nhất?", en: "Compare the speeds: registers, cache, main memory, disk — which order is correct from fastest to slowest?" }, o: [{ vi: "Disk → Main memory → Cache → Registers", en: "Disk → Main memory → Cache → Registers" }, { vi: "Registers → Cache → Main memory → Disk", en: "Registers → Cache → Main memory → Disk" }, { vi: "Cache → Registers → Disk → Main memory", en: "Cache → Registers → Disk → Main memory" }, { vi: "Main memory → Cache → Registers → Disk", en: "Main memory → Cache → Registers → Disk" }], a: 1, explanation: { vi: "Đây là hệ thống phân cấp bộ nhớ. Tốc độ giảm dần và dung lượng tăng dần khi di chuyển ra xa CPU: Registers (trong CPU) > Cache (gần CPU) > Main Memory (RAM) > Disk (lưu trữ).", en: "This is the memory hierarchy. Speed decreases and capacity increases as you move away from the CPU: Registers (in CPU) > Cache (near CPU) > Main Memory (RAM) > Disk (storage)." } },
                    { q: { vi: "Tại sao cache thường tải cả một block chứ không chỉ một từ?", en: "Why does a cache typically load an entire block, not just one word?" }, o: [{ vi: "Vì công nghệ không thể truyền single byte", en: "Because the technology cannot transfer a single byte" }, { vi: "Do tính cục bộ không gian/thời gian (locality): có khả năng truy cập tiếp những từ gần đó → tiết kiệm truy xuất main memory", en: "Due to spatial/temporal locality: it's likely that nearby words will be accessed soon → saves main memory accesses" }, { vi: "Để tăng kích thước cache vật lý", en: "To increase the physical cache size" }, { vi: "Để giảm số thanh ghi CPU", en: "To reduce the number of CPU registers" }], a: 1, explanation: { vi: "Nguyên lý cục bộ không gian (spatial locality) cho rằng nếu bạn truy cập một địa chỉ, rất có thể bạn sẽ sớm truy cập các địa chỉ lân cận. Tải cả một khối (block) sẽ nạp sẵn các dữ liệu này vào cache.", en: "The principle of spatial locality suggests that if you access one address, you are very likely to access nearby addresses soon. Loading an entire block pre-fetches this data into the cache." } },
                    { q: { vi: "Thiết bị nào sau đây là non-storage I/O device?", en: "Which of the following is a non-storage I/O device?" }, o: [{ vi: "Hard disk", en: "Hard disk" }, { vi: "CD-ROM", en: "CD-ROM" }, { vi: "Keyboard", en: "Keyboard" }, { vi: "Magnetic tape", en: "Magnetic tape" }], a: 2, explanation: { vi: "Thiết bị lưu trữ (storage) có thể giữ lại dữ liệu. Bàn phím (keyboard) chỉ truyền dữ liệu vào tại một thời điểm, nó không lưu trữ dữ liệu.", en: "A storage device can retain data. A keyboard only transmits data at a moment in time; it does not store it." } },
                    { q: { vi: "Storage devices được phân thành mấy loại chính trong chương này?", en: "Storage devices are divided into how many main categories in this chapter?" }, o: [{ vi: "1 — chỉ magnetic", en: "1 — only magnetic" }, { vi: "2 — magnetic và optical", en: "2 — magnetic and optical" }, { vi: "3 — magnetic, optical, và flash (không nhắc đến)", en: "3 — magnetic, optical, and flash (not mentioned)" }, { vi: "4 — magnetic, optical, tape, và RAM", en: "4 — magnetic, optical, tape, and RAM" }], a: 1, explanation: { vi: "Chương này tập trung vào hai công nghệ lưu trữ truyền thống: từ tính (magnetic) như đĩa cứng và băng từ, và quang học (optical) như CD/DVD.", en: "This chapter focuses on two traditional storage technologies: magnetic (like hard disks and tapes) and optical (like CDs/DVDs)." } },
                    { q: { vi: "Thiết bị lưu trữ dạng đĩa từ (magnetic disk): điểm nào đúng?", en: "Regarding magnetic disk storage devices: which point is correct?" }, o: [{ vi: "Là thiết bị truy cập tuần tự như tape", en: "It is a sequential access device like tape" }, { vi: "Mỗi mặt đĩa chia thành track và sector; truy cập là ngẫu nhiên (random) theo sector", en: "Each platter is divided into tracks and sectors; access is random by sector" }, { vi: "Không cần head để đọc/ghi", en: "It does not need a head to read/write" }, { vi: "Là bộ nhớ volatile", en: "It is volatile memory" }], a: 1, explanation: { vi: "Đĩa từ cho phép đầu đọc/ghi di chuyển trực tiếp đến bất kỳ track và sector nào, cho phép truy cập ngẫu nhiên, nhanh hơn nhiều so với truy cập tuần tự của băng từ.", en: "A magnetic disk allows the read/write head to move directly to any track and sector, enabling random access, which is much faster than the sequential access of a tape." } },
                    { q: { vi: "Magnetic tape có kiểu truy cập nào?", en: "What type of access does a magnetic tape have?" }, o: [{ vi: "Random access", en: "Random access" }, { vi: "Memory-mapped access", en: "Memory-mapped access" }, { vi: "Sequential access", en: "Sequential access" }, { vi: "Parallel access", en: "Parallel access" }], a: 2, explanation: { vi: "Giống như băng cassette, để đọc dữ liệu ở giữa, bạn phải tua qua tất cả dữ liệu ở phía trước. Đây là truy cập tuần tự (sequential).", en: "Like a cassette tape, to read data in the middle, you must wind through all the data before it. This is sequential access." } },
                    { q: { vi: "CD-ROM ghi dữ liệu bằng cách tạo:", en: "A CD-ROM stores data by creating:" }, o: [{ vi: "Tụ điện trên bề mặt", en: "Capacitors on the surface" }, { vi: "Pit (hố) và land (bề mặt) tạo độ phản xạ khác nhau đọc bằng laser", en: "Pits and lands that create different reflections read by a laser" }, { vi: "Từ hóa bề mặt bằng nam châm", en: "Magnetized areas on the surface" }, { vi: "Ghi điện áp trên đĩa kim loại", en: "Voltage levels on a metal disk" }], a: 1, explanation: { vi: "Dữ liệu trên CD được biểu diễn bằng các hố (pits) nhỏ được ép lên bề mặt. Một tia laser đọc sự khác biệt về độ phản xạ giữa các hố và bề mặt phẳng (lands) để diễn giải thành 0 và 1.", en: "Data on a CD is represented by tiny pits pressed into the surface. A laser reads the difference in reflectivity between the pits and the flat surface (lands) to interpret them as 0s and 1s." } },
                    { q: { vi: "SCSI là loại giao diện nào và yêu cầu gì đặc biệt?", en: "What type of interface is SCSI and what special requirement does it have?" }, o: [{ vi: "Serial, không cần terminator", en: "Serial, no terminator needed" }, { vi: "Parallel, daisy-chain, cả hai đầu chuỗi phải có terminator", en: "Parallel, daisy-chain, both ends of the chain must have a terminator" }, { vi: "USB, tree topology", en: "USB, tree topology" }, { vi: "FireWire, hỗ trợ hot-plug", en: "FireWire, supports hot-plugging" }], a: 1, explanation: { vi: "SCSI song song sử dụng kết nối chuỗi (daisy-chain). Để ngăn tín hiệu bị dội lại, đầu cuối của chuỗi bus phải được kết thúc bằng một điện trở gọi là terminator.", en: "Parallel SCSI uses a daisy-chain connection. To prevent signal reflections, the physical end of the bus chain must be capped with a resistor called a terminator." } },
                    { q: { vi: "FireWire (IEEE 1394) có thể kết nối tối đa bao nhiêu thiết bị theo tài liệu?", en: "According to the documentation, FireWire (IEEE 1394) can connect a maximum of how many devices?" }, o: [{ vi: "16", en: "16" }, { vi: "32", en: "32" }, { vi: "63", en: "63" }, { vi: "127", en: "127" }], a: 2, explanation: { vi: "FireWire cho phép kết nối chuỗi (daisy-chaining) lên đến 63 thiết bị.", en: "FireWire allows for the daisy-chaining of up to 63 devices." } },
                    { q: { vi: "USB-2 cho phép tối đa bao nhiêu thiết bị trên một controller (root hub)?", en: "How many devices does USB-2 allow on a single controller (root hub)?" }, o: [{ vi: "63", en: "63" }, { vi: "127", en: "127" }, { vi: "256", en: "256" }, { vi: "512", en: "512" }], a: 1, explanation: { vi: "Kiến trúc USB hỗ trợ lên đến 127 thiết bị (bao gồm cả các hub) được kết nối với một bộ điều khiển duy nhất.", en: "The USB architecture supports up to 127 devices (including hubs) connected to a single host controller." } },
                    { q: { vi: "HDMI được mô tả là:", en: "HDMI is described as:" }, o: [{ vi: "Giao diện analog cho tín hiệu âm thanh", en: "An analog interface for audio signals" }, { vi: "Giao diện digital thay thế cho các chuẩn video analog, truyền audio & video số", en: "A digital interface replacing analog video standards, transmitting digital audio & video" }, { vi: "Giao diện cho ổ cứng", en: "An interface for hard drives" }, { vi: "Giao diện cho bàn phím cơ", en: "An interface for mechanical keyboards" }], a: 1, explanation: { vi: "HDMI (High-Definition Multimedia Interface) là tiêu chuẩn hiện đại để truyền cả video và âm thanh kỹ thuật số không nén qua một cáp duy nhất.", en: "HDMI (High-Definition Multimedia Interface) is the modern standard for transmitting uncompressed digital video and audio over a single cable." } },
                    { q: { vi: "Trong số: SCSI, USB, FireWire — cái nào là giao diện song song (parallel) theo tài liệu?", en: "Among SCSI, USB, and FireWire — which is a parallel interface according to the text?" }, o: [{ vi: "USB", en: "USB" }, { vi: "FireWire", en: "FireWire" }, { vi: "SCSI", en: "SCSI" }, { vi: "HDMI", en: "HDMI" }], a: 2, explanation: { vi: "SCSI (Small Computer System Interface) truyền thống là một giao diện song song, truyền nhiều bit cùng một lúc. USB và FireWire là giao diện nối tiếp (serial).", en: "Traditional SCSI (Small Computer System Interface) is a parallel interface, transferring multiple bits at once. USB and FireWire are serial interfaces." } },
                    { q: { vi: "Phương pháp isolated I/O có đặc điểm gì?", en: "What is a characteristic of the isolated I/O method?" }, o: [{ vi: "I/O dùng cùng lệnh với truy xuất memory", en: "I/O uses the same instructions as memory access" }, { vi: "Có tập lệnh riêng cho I/O (input/output) tách biệt với lệnh memory", en: "It has a separate set of I/O instructions (input/output) distinct from memory instructions" }, { vi: "I/O không có địa chỉ", en: "I/O has no address" }, { vi: "Là cách mà ROM được truy xuất", en: "It is the way ROM is accessed" }], a: 1, explanation: { vi: "Trong isolated I/O, CPU có các lệnh đặc biệt (như IN, OUT) chỉ dành cho việc giao tiếp với các thiết bị I/O, tách biệt hoàn toàn với các lệnh đọc/ghi bộ nhớ.", en: "In isolated I/O, the CPU has special instructions (like IN, OUT) used only for communicating with I/O devices, completely separate from memory read/write instructions." } },
                    { q: { vi: "Phương pháp memory-mapped I/O là gì?", en: "What is the memory-mapped I/O method?" }, o: [{ vi: "Mỗi thanh ghi của controller được ánh xạ như một ô nhớ → dùng cùng lệnh đọc/ghi như memory", en: "Each controller register is mapped as a memory location → uses the same read/write instructions as memory" }, { vi: "I/O không bao giờ dùng bus hệ thống", en: "I/O never uses the system bus" }, { vi: "I/O luôn dùng interrupt-driven I/O", en: "I/O always uses interrupt-driven I/O" }, { vi: "Là một loại disk format", en: "It is a type of disk format" }], a: 0, explanation: { vi: "Với memory-mapped I/O, CPU không phân biệt giữa một ô nhớ và một thanh ghi của thiết bị. Nó dùng cùng các lệnh (ví dụ: LOAD, STORE) cho cả hai.", en: "With memory-mapped I/O, the CPU does not distinguish between a memory cell and a device's register. It uses the same instructions (e.g., LOAD, STORE) for both." } },
                    { q: { vi: "Một nhược điểm của memory-mapped I/O?", en: "What is a disadvantage of memory-mapped I/O?" }, o: [{ vi: "Không thể dùng DMA", en: "Cannot use DMA" }, { vi: "Cần nhiều lệnh hơn so với isolated I/O", en: "Needs more instructions than isolated I/O" }, { vi: "Chiếm 1 phần không gian địa chỉ memory cho registers → giảm dung lượng memory dùng cho dữ liệu/chương trình", en: "It occupies part of the memory address space for registers → reduces memory available for data/programs" }, { vi: "Không thể hot-plug thiết bị", en: "Cannot hot-plug devices" }], a: 2, explanation: { vi: "Vì các thanh ghi của thiết bị I/O chiếm các địa chỉ trong không gian bộ nhớ, nên các địa chỉ đó không thể được sử dụng cho RAM thực tế.", en: "Because the I/O device registers occupy addresses in the memory space, those addresses cannot be used for actual RAM." } },
                    { q: { vi: "Ví dụ minh họa isolated I/O: để đọc từ thiết bị có địa chỉ 101, lệnh nào hợp lý?", en: "Illustrating isolated I/O: to read from a device with address 101, which instruction is appropriate?" }, o: [{ vi: "READ 101 (chỉ dành cho memory)", en: "READ 101 (only for memory)" }, { vi: "INPUT 101 (lệnh I/O riêng)", en: "INPUT 101 (a separate I/O instruction)" }, { vi: "STORE 101", en: "STORE 101" }, { vi: "JUMP 101", en: "JUMP 101" }], a: 1, explanation: { vi: "Lệnh INPUT là một ví dụ về một lệnh dành riêng cho I/O, tách biệt với các lệnh truy cập bộ nhớ như READ hoặc LOAD.", en: "The INPUT instruction is an example of a dedicated I/O command, separate from memory access instructions like READ or LOAD." } },
                    { q: { vi: "Ưu điểm của memory-mapped I/O là:", en: "An advantage of memory-mapped I/O is:" }, o: [{ vi: "Số lượng instructions giảm do có thể dùng chung lệnh memory cho I/O", en: "The number of instructions is reduced as memory instructions can be used for I/O" }, { vi: "Không cần controller cho I/O", en: "No controller is needed for I/O" }, { vi: "Không cần bus dữ liệu", en: "No data bus is needed" }, { vi: "Tốc độ luôn nhanh hơn isolated I/O", en: "It is always faster than isolated I/O" }], a: 0, explanation: { vi: "Bằng cách cho phép tất cả các lệnh thao tác bộ nhớ cũng hoạt động trên các thiết bị I/O, nó làm cho tập lệnh của CPU đơn giản hơn và lập trình linh hoạt hơn.", en: "By allowing all memory-manipulation instructions to also work on I/O devices, it makes the CPU's instruction set simpler and programming more flexible." } },
                    { q: { vi: "Máy thực hiện một chu kỳ (machine cycle) gồm những pha cơ bản nào?", en: "A machine performs a cycle (machine cycle) consisting of which basic phases?" }, o: [{ vi: "Read → Write → Store", en: "Read → Write → Store" }, { vi: "Fetch → Decode → Execute", en: "Fetch → Decode → Execute" }, { vi: "Input → Output → Transfer", en: "Input → Output → Transfer" }, { vi: "Start → Stop → Reset", en: "Start → Stop → Reset" }], a: 1, explanation: { vi: "Đây là 3 bước lặp đi lặp lại cốt lõi của CPU: Lấy lệnh từ bộ nhớ (Fetch), hiểu lệnh đó là gì (Decode), và thực hiện hành động được yêu cầu (Execute).", en: "These are the 3 core repetitive steps of the CPU: Get an instruction from memory (Fetch), understand what it is (Decode), and perform the requested action (Execute)." } },
                    { q: { vi: "Trong programmed I/O, CPU làm gì khi gặp lệnh I/O?", en: "In programmed I/O, what does the CPU do when it encounters an I/O instruction?" }, o: [{ vi: "Gửi interrupt và làm việc khác", en: "Sends an interrupt and does other work" }, { vi: "Đợi/poll liên tục trạng thái thiết bị → CPU bị chặn (busy-wait)", en: "Waits/polls the device status continuously → the CPU is blocked (busy-wait)" }, { vi: "Dùng DMA ngay lập tức", en: "Uses DMA immediately" }, { vi: "Tự động bỏ qua lệnh I/O", en: "Automatically skips the I/O instruction" }], a: 1, explanation: { vi: "Programmed I/O là phương pháp đơn giản nhất nhưng kém hiệu quả nhất. CPU bị kẹt trong một vòng lặp, liên tục hỏi 'Xong chưa?', không thể làm việc khác.", en: "Programmed I/O is the simplest but least efficient method. The CPU gets stuck in a loop, constantly asking 'Are you done yet?', unable to do other work." } },
                    { q: { vi: "Trong interrupt-driven I/O, điều gì xảy ra?", en: "In interrupt-driven I/O, what happens?" }, o: [{ vi: "Thiết bị gửi interrupt khi sẵn sàng, CPU có thể làm việc khác trong lúc chờ", en: "The device sends an interrupt when ready, the CPU can do other work while waiting" }, { vi: "CPU phải poll thường xuyên thiết bị", en: "The CPU must poll the device frequently" }, { vi: "Không có giao tiếp DMA", en: "There is no DMA communication" }, { vi: "CPU dừng hoàn toàn cho đến khi xong I/O", en: "The CPU halts completely until I/O is finished" }], a: 0, explanation: { vi: "Đây là một cải tiến lớn. CPU ra lệnh cho thiết bị và đi làm việc khác. Khi thiết bị hoàn thành, nó sẽ 'ngắt' (interrupt) CPU để báo hiệu.", en: "This is a major improvement. The CPU commands the device and goes off to do other work. When the device is finished, it 'interrupts' the CPU to signal completion." } },
                    { q: { vi: "Direct Memory Access (DMA) có tác dụng gì?", en: "What is the purpose of Direct Memory Access (DMA)?" }, o: [{ vi: "Chuyển khối dữ liệu lớn trực tiếp giữa I/O và memory mà không qua CPU (hoặc chỉ qua mức tối thiểu)", en: "To transfer large blocks of data directly between I/O and memory without CPU intervention (or with minimal intervention)" }, { vi: "Thay thế cache hoàn toàn", en: "To completely replace the cache" }, { vi: "Là một loại controller cho keyboard", en: "It is a type of controller for the keyboard" }, { vi: "Chỉ dùng cho CD-ROM", en: "It is only used for CD-ROMs" }], a: 0, explanation: { vi: "DMA giải phóng CPU khỏi công việc truyền dữ liệu tẻ nhạt. CPU chỉ cần khởi tạo việc truyền, và bộ điều khiển DMA sẽ tự xử lý, cho phép CPU làm những việc hữu ích hơn.", en: "DMA frees the CPU from the tedious job of data transfer. The CPU only needs to initiate the transfer, and the DMA controller handles it, allowing the CPU to do more useful work." } },
                    { q: { vi: "Khi DMA thực hiện truyền khối dữ liệu, CPU:", en: "When DMA performs a block data transfer, the CPU:" }, o: [{ vi: "Bận hoàn toàn và không làm gì khác", en: "Is completely busy and does nothing else" }, { vi: "Luôn phải chờ cho đến khi DMA xong mới tiếp tục", en: "Must always wait until DMA is finished to continue" }, { vi: "Thường chỉ nhường bus trong thời gian ngắn (CPU tạm dừng dùng bus), còn có thể làm các công việc khác không cần bus", en: "Usually only yields the bus for short periods (cycle stealing), and can do other work that doesn't require the bus" }, { vi: "Phải xử lý từng byte một bằng polling", en: "Must process each byte via polling" }], a: 2, explanation: { vi: "DMA và CPU chia sẻ bus. DMA 'đánh cắp' các chu kỳ bus từ CPU để truyền dữ liệu. Trong thời gian đó, CPU vẫn có thể thực hiện các lệnh không cần truy cập bộ nhớ (ví dụ: các phép toán trên thanh ghi).", en: "DMA and the CPU share the bus. DMA 'steals' bus cycles from the CPU to transfer data. During that time, the CPU can still execute instructions that don't require memory access (e.g., operations on registers)." } },
                    { q: { vi: "Đặc trưng chính của CISC là gì?", en: "What is the main characteristic of CISC?" }, o: [{ vi: "Tập lệnh nhỏ, đơn giản, thực thi nhanh từng lệnh", en: "A small, simple instruction set, with fast execution for each instruction" }, { vi: "Tập lệnh phức tạp, nhiều chức năng — dùng microprogramming để phân giải thành micro-operations", en: "A complex instruction set with many functions — using microprogramming to resolve into micro-operations" }, { vi: "Không có ALU", en: "No ALU" }, { vi: "Chỉ dùng cho supercomputers", en: "Only used for supercomputers" }], a: 1, explanation: { vi: "CISC (Complex Instruction Set Computer) có các lệnh mạnh mẽ, có thể thực hiện các tác vụ phức tạp trong một lệnh duy nhất. Bên trong, các lệnh này được chia thành các bước nhỏ hơn gọi là micro-operations.", en: "CISC (Complex Instruction Set Computer) has powerful instructions that can perform complex tasks in a single command. Internally, these are broken down into smaller steps called micro-operations." } },
                    { q: { vi: "RISC tập trung vào:", en: "RISC focuses on:" }, o: [{ vi: "Tập lệnh lớn phức tạp", en: "A large, complex instruction set" }, { vi: "Tập lệnh giảm thiểu, mỗi lệnh đơn giản và nhanh", en: "A reduced instruction set, where each instruction is simple and fast" }, { vi: "Loại bỏ cache", en: "Eliminating the cache" }, { vi: "Dùng micromemory cho mỗi lệnh", en: "Using micromemory for each instruction" }], a: 1, explanation: { vi: "RISC (Reduced Instruction Set Computer) có triết lý ngược lại với CISC. Nó sử dụng một tập lệnh nhỏ gồm các lệnh rất đơn giản, mỗi lệnh có thể được thực thi rất nhanh (thường trong một chu kỳ xung nhịp).", en: "RISC (Reduced Instruction Set Computer) has the opposite philosophy of CISC. It uses a small set of very simple instructions, each of which can be executed very quickly (often in a single clock cycle)." } },
                    { q: { vi: "Mục đích của pipelining là:", en: "The purpose of pipelining is:" }, o: [{ vi: "Giảm kích thước RAM", en: "To reduce RAM size" }, { vi: "Tăng throughput bằng cách chồng lấp các pha fetch/decode/execute của nhiều lệnh khác nhau", en: "To increase throughput by overlapping the fetch/decode/execute phases of different instructions" }, { vi: "Thay thế ALU bằng nhiều ALU nhỏ", en: "To replace the ALU with many smaller ALUs" }, { vi: "Làm cho CPU chạy chậm hơn để tiết kiệm điện", en: "To make the CPU run slower to save power" }], a: 1, explanation: { vi: "Pipelining giống như một dây chuyền lắp ráp. Trong khi một lệnh đang được thực thi, lệnh tiếp theo đang được giải mã, và lệnh sau đó nữa đang được nạp. Điều này làm tăng đáng kể số lượng lệnh được hoàn thành trong một đơn vị thời gian (throughput).", en: "Pipelining is like an assembly line. While one instruction is being executed, the next one is being decoded, and the one after that is being fetched. This greatly increases the number of instructions completed per unit of time (throughput)." } },
                    { q: { vi: "Theo Flynn, dạng nào là Single Instruction-stream, Multiple Data-stream?", en: "According to Flynn, which category is Single Instruction-stream, Multiple Data-stream?" }, o: [{ vi: "SISD", en: "SISD" }, { vi: "SIMD", en: "SIMD" }, { vi: "MISD", en: "MISD" }, { vi: "MIMD", en: "MIMD" }], a: 1, explanation: { vi: "SIMD (Single Instruction, Multiple Data) thực hiện cùng một lệnh trên nhiều phần dữ liệu khác nhau cùng một lúc. Điều này rất phổ biến trong xử lý đồ họa và khoa học.", en: "SIMD (Single Instruction, Multiple Data) performs the same instruction on multiple different pieces of data simultaneously. This is very common in graphics and scientific processing." } },
                    { q: { vi: "MISD (Multiple Instruction-stream, Single Data-stream) là:", en: "MISD (Multiple Instruction-stream, Single Data-stream) is:" }, o: [{ vi: "Rất phổ biến trong hệ thống desktop", en: "Very common in desktop systems" }, { vi: "Thường ít hoặc chưa được thực thi thực tế (hiếm gặp)", en: "Rarely or not practically implemented" }, { vi: "Là kiến trúc USB", en: "The architecture of USB" }, { vi: "Tương đương với SIMD", en: "Equivalent to SIMD" }], a: 1, explanation: { vi: "Kiến trúc MISD, trong đó nhiều lệnh hoạt động trên cùng một luồng dữ liệu, có rất ít ứng dụng trong thực tế và chủ yếu mang tính lý thuyết.", en: "The MISD architecture, where multiple instructions operate on the same stream of data, has very few practical applications and is mostly theoretical." } },
                    { q: { vi: "Định dạng lệnh của máy đơn giản trong chương có độ dài bao nhiêu bit?", en: "What is the instruction format length of the simple computer in the chapter?" }, o: [{ vi: "8 bit", en: "8 bits" }, { vi: "12 bit", en: "12 bits" }, { vi: "16 bit (chia làm 4 trường, mỗi trường 4 bit)", en: "16 bits (divided into 4 fields, each 4 bits)" }, { vi: "32 bit", en: "32 bits" }], a: 2, explanation: { vi: "Máy tính giả định trong sách sử dụng các lệnh 16-bit, được chia thành một opcode 4-bit và ba toán hạng 4-bit.", en: "The hypothetical computer in the book uses 16-bit instructions, divided into a 4-bit opcode and three 4-bit operands." } },
                    { q: { vi: "Trong bảng mã lệnh mẫu, opcode của LOAD là số nào?", en: "In the sample instruction table, what is the opcode for LOAD?" }, o: [{ vi: "0", en: "0" }, { vi: "1", en: "1" }, { vi: "2", en: "2" }, { vi: "3", en: "3" }], a: 1, explanation: { vi: "Theo bảng mã lệnh được cung cấp trong chương, lệnh LOAD được gán mã opcode là 1.", en: "According to the instruction set table provided in the chapter, the LOAD instruction is assigned opcode 1." } },
                    { q: { vi: "Opcode của HALT trong máy đơn giản là gì?", en: "What is the opcode for HALT in the simple computer?" }, o: [{ vi: "0", en: "0" }, { vi: "1", en: "1" }, { vi: "F", en: "F" }, { vi: "8", en: "8" }], a: 0, explanation: { vi: "Lệnh HALT (dừng máy) được gán mã opcode là 0.", en: "The HALT instruction (stop the machine) is assigned opcode 0." } },
                    { q: { vi: "Ở máy đơn giản, địa chỉ memory-mapped của keyboard và monitor lần lượt là?", en: "In the simple computer, what are the memory-mapped addresses of the keyboard and monitor, respectively?" }, o: [{ vi: "00 và 01", en: "00 and 01" }, { vi: "FE và FF", en: "FE and FF" }, { vi: "7F và 80", en: "7F and 80" }, { vi: "A0 và A1", en: "A0 and A1" }], a: 1, explanation: { vi: "Sách quy ước hai địa chỉ cuối cùng của không gian 256-byte (FE và FF) được dành riêng cho việc giao tiếp với bàn phím và màn hình.", en: "The book specifies that the last two addresses of the 256-byte space (FE and FF) are reserved for communicating with the keyboard and monitor." } },
                    { q: { vi: "Trong máy đơn giản này, kích thước (size) của Program Counter (PC) là bao nhiêu bit?", en: "In this simple computer, what is the size of the Program Counter (PC)?" }, o: [{ vi: "4 bit", en: "4 bits" }, { vi: "8 bit", en: "8 bits" }, { vi: "16 bit", en: "16 bits" }, { vi: "32 bit", en: "32 bits" }], a: 1, explanation: { vi: "Vì máy có 256 byte bộ nhớ (2^8), Program Counter cần 8 bit để có thể trỏ đến bất kỳ địa chỉ nào trong số đó.", en: "Since the machine has 256 bytes of memory (2^8), the Program Counter needs 8 bits to be able to point to any of those addresses." } }
                ]
            }
        };
        // --- END: NGÂN HÀNG CÂU HỎI VÀ LÝ THUYẾT ---

        // --- START: JAVASCRIPT LOGIC (HOÀN CHỈNH) ---
        let currentLang = 'vi';
        let currentChapter = 'chapter1';
        let quizState = {};

        document.addEventListener('DOMContentLoaded', () => {
            renderAllContent();
        });

        function renderAllContent() {
            const tabContent = document.querySelector('.tab-content');
            tabContent.innerHTML = '';
            let isFirstChapter = true;
            for (const chapterId in contentData) {
                const chapterDiv = document.createElement('div');
                chapterDiv.id = chapterId;
                chapterDiv.className = isFirstChapter ? 'tab-pane active' : 'tab-pane';
                isFirstChapter = false;

                chapterDiv.innerHTML = `
                    <div class="theory-view">
                        <div class="theory-content"></div>
                        <div class="button-group">
                            <button class="primary-button" onclick="showQuizSetup('${chapterId}')" data-lang-key="startQuiz"></button>
                            <button class="info-button" onclick="askAI()" data-lang-key="askAI"></button>
                        </div>
                    </div>
                    <div class="quiz-view">
                        <div class="quiz-setup">
                            <h3 data-lang-key="quizSetupTitle"></h3>
                            <div>
                                <label data-lang-key="numQuestions"></label>
                                <input type="number" id="num-questions-${chapterId}" value="10" min="1" max="${contentData[chapterId].questions.length}">
                            </div>
                            <div>
                                <button class="primary-button" onclick="startQuiz('${chapterId}')" data-lang-key="start"></button>
                                <button class="secondary-button" onclick="showTheory('${chapterId}')" data-lang-key="backToTheory"></button>
                            </div>
                        </div>
                        <div class="quiz-container" style="display:none;">
                            <div id="question-text-${chapterId}" class="quiz-question"></div>
                            <div id="quiz-options-${chapterId}" class="quiz-options"></div>
                            <div id="explanation-${chapterId}"></div>
                            <div class="button-group">
                                <button onclick="nextQuestion('${chapterId}')" id="next-btn-${chapterId}" class="primary-button" data-lang-key="nextQuestion" style="display:none;"></button>
                            </div>
                        </div>
                        <div class="quiz-results" style="display:none;">
                            <h3 data-lang-key="resultsTitle"></h3>
                            <p id="score-${chapterId}"></p>
                            <button class="secondary-button" onclick="showTheory('${chapterId}')" data-lang-key="backToTheory"></button>
                            <button class="primary-button" onclick="showQuizSetup('${chapterId}')" data-lang-key="retakeQuiz"></button>
                        </div>
                    </div>
                `;
                tabContent.appendChild(chapterDiv);
            }
            updateAllVisibleText();
        }

        function switchTab(chapterId) {
            currentChapter = chapterId;
            document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
            document.getElementById(chapterId).classList.add('active');
            
            document.querySelectorAll('.tab-link').forEach(l => l.classList.remove('active'));
            document.querySelector(`.tab-link[onclick="switchTab('${chapterId}')"]`).classList.add('active');
        }

        function switchLanguage(lang) {
            if (currentLang === lang) return;
            currentLang = lang;
            document.querySelectorAll('.lang-switcher button').forEach(b => b.classList.remove('active'));
            document.querySelector(`.lang-switcher button[onclick="switchLanguage('${lang}')"]`).classList.add('active');
            updateAllVisibleText();
        }
        
        const translations = {
            vi: {
                title: "CSI FPTU - Công cụ Ôn tập Nâng cao",
                subtitle: "Chọn chương để học lý thuyết hoặc làm bài tập trắc nghiệm.",
                vietnamese: "Tiếng Việt", english: "English",
                ch1: "Chương 1", ch2: "Chương 2", ch3: "Chương 3", ch4: "Chương 4", ch5: "Chương 5",
                startQuiz: "Làm bài tập", quizSetupTitle: "Thiết lập bài trắc nghiệm",
                numQuestions: "Số lượng câu hỏi:", start: "Bắt đầu",
                backToTheory: "Quay lại Lý thuyết", nextQuestion: "Câu tiếp theo",
                resultsTitle: "Kết quả", scoreText: "Bạn đã trả lời đúng",
                retakeQuiz: "Làm lại bài", askAI: "Hỏi AI"
            },
            en: {
                title: "CSI FPTU - Advanced Study Tool",
                subtitle: "Select a chapter to study theory or take a multiple-choice quiz.",
                vietnamese: "Vietnamese", english: "English",
                ch1: "Chapter 1", ch2: "Chapter 2", ch3: "Chapter 3", ch4: "Chapter 4", ch5: "Chapter 5",
                startQuiz: "Start Quiz", quizSetupTitle: "Quiz Setup",
                numQuestions: "Number of questions:", start: "Start",
                backToTheory: "Back to Theory", nextQuestion: "Next Question",
                resultsTitle: "Results", scoreText: "You answered correctly",
                retakeQuiz: "Retake Quiz", askAI: "Ask AI"
            }
        };

        function updateAllVisibleText() {
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.getAttribute('data-lang-key');
                if (translations[currentLang][key]) {
                    el.textContent = translations[currentLang][key];
                }
            });

            for (const chapterId in contentData) {
                const theoryDiv = document.querySelector(`#${chapterId} .theory-content`);
                if (theoryDiv) {
                    theoryDiv.innerHTML = contentData[chapterId].theory[currentLang];
                }
            }

            if (quizState[currentChapter] && quizState[currentChapter].isActive) {
                redisplayCurrentQuestion();
            }
        }

        function redisplayCurrentQuestion() {
            const state = quizState[currentChapter];
            if (!state || !state.isActive || state.currentQuestionIndex >= state.questions.length) return;

            const question = state.questions[state.currentQuestionIndex];
            document.getElementById(`question-text-${currentChapter}`).textContent = `(${state.currentQuestionIndex + 1}/${state.questions.length}) ${question.q[currentLang]}`;
            
            const options = document.querySelectorAll(`#quiz-options-${currentChapter} button`);
            options.forEach((button, index) => {
                button.textContent = question.o[index][currentLang];
            });

            const explanationDiv = document.getElementById(`explanation-${currentChapter}`);
            if (explanationDiv.innerHTML !== '') {
                const explanationText = question.explanation ? question.explanation[currentLang] : '';
                explanationDiv.innerHTML = `<div class="explanation-box"><strong>💡 ${currentLang === 'vi' ? 'Giải thích' : 'Explanation'}:</strong> ${explanationText}</div>`;
            }
        }
        
        function showQuizSetup(chapterId) {
            document.querySelector(`#${chapterId} .theory-view`).style.display = 'none';
            document.querySelector(`#${chapterId} .quiz-view`).style.display = 'block';
            document.querySelector(`#${chapterId} .quiz-setup`).style.display = 'block';
            document.querySelector(`#${chapterId} .quiz-container`).style.display = 'none';
            document.querySelector(`#${chapterId} .quiz-results`).style.display = 'none';
        }

        function showTheory(chapterId) {
            if(quizState[chapterId]) quizState[chapterId].isActive = false;
            document.querySelector(`#${chapterId} .theory-view`).style.display = 'block';
            document.querySelector(`#${chapterId} .quiz-view`).style.display = 'none';
        }

        function startQuiz(chapterId) {
            const allQuestions = contentData[chapterId].questions;
            const numQuestionsInput = document.getElementById(`num-questions-${chapterId}`);
            let numQuestions = parseInt(numQuestionsInput.value);
            if (isNaN(numQuestions) || numQuestions <= 0 || numQuestions > allQuestions.length) {
                numQuestions = Math.min(10, allQuestions.length);
                numQuestionsInput.value = numQuestions;
            }
            
            const questions = [...allQuestions].sort(() => 0.5 - Math.random()).slice(0, numQuestions);

            quizState[chapterId] = { questions, currentQuestionIndex: 0, score: 0, isActive: true };

            document.querySelector(`#${chapterId} .quiz-setup`).style.display = 'none';
            document.querySelector(`#${chapterId} .quiz-container`).style.display = 'block';
            document.querySelector(`#${chapterId} .quiz-results`).style.display = 'none';
            
            displayQuestion(chapterId);
        }

        function displayQuestion(chapterId) {
            const state = quizState[chapterId];
            if (state.currentQuestionIndex >= state.questions.length) {
                showResults(chapterId);
                return;
            }

            const question = state.questions[state.currentQuestionIndex];
            document.getElementById(`question-text-${chapterId}`).textContent = `(${state.currentQuestionIndex + 1}/${state.questions.length}) ${question.q[currentLang]}`;
            
            const optionsDiv = document.getElementById(`quiz-options-${chapterId}`);
            optionsDiv.innerHTML = '';
            question.o.forEach((option, index) => {
                const button = document.createElement('button');
                button.textContent = option[currentLang];
                button.onclick = () => selectAnswer(chapterId, index);
                optionsDiv.appendChild(button);
            });

            document.getElementById(`explanation-${chapterId}`).innerHTML = '';
            document.getElementById(`next-btn-${chapterId}`).style.display = 'none';
        }

        function selectAnswer(chapterId, selectedIndex) {
            const state = quizState[chapterId];
            const question = state.questions[state.currentQuestionIndex];
            const correctIndex = question.a;
            
            const options = document.querySelectorAll(`#${chapterId} .quiz-options button`);
            options.forEach(button => button.disabled = true);

            if (selectedIndex === correctIndex) {
                options[selectedIndex].classList.add('correct');
                state.score++;
            } else {
                options[selectedIndex].classList.add('incorrect');
                options[correctIndex].classList.add('correct');
                const explanationDiv = document.getElementById(`explanation-${chapterId}`);
                if(question.explanation) {
                    explanationDiv.innerHTML = `<div class="explanation-box"><strong>💡 ${currentLang === 'vi' ? 'Giải thích' : 'Explanation'}:</strong> ${question.explanation[currentLang]}</div>`;
                }
            }
            document.getElementById(`next-btn-${chapterId}`).style.display = 'inline-block';
        }

        function nextQuestion(chapterId) {
            quizState[chapterId].currentQuestionIndex++;
            displayQuestion(chapterId);
        }

        function showResults(chapterId) {
            const state = quizState[chapterId];
            state.isActive = false;
            document.querySelector(`#${chapterId} .quiz-container`).style.display = 'none';
            const resultsDiv = document.querySelector(`#${chapterId} .quiz-results`);
            resultsDiv.style.display = 'block';
            
            const scoreText = translations[currentLang].scoreText;
            document.getElementById(`score-${chapterId}`).textContent = `${scoreText} ${state.score} / ${state.questions.length} câu.`;
        }

        function askAI() {
            const activeChapter = document.querySelector('.tab-pane.active');
            const titleElement = activeChapter.querySelector('.theory-content h2');
            if (titleElement) {
                let topic = titleElement.textContent.trim();
                topic = topic.replace(/Chapter \d+:|Chương \d+:/i, '').trim();

                const promptText = currentLang === 'vi' 
                    ? `Hãy giải thích chi tiết về chủ đề sau trong môn Khoa học máy tính: "${topic}". Vui lòng giải thích các khái niệm cốt lõi, cho ví dụ minh họa và nêu bật những điểm quan trọng nhất mà sinh viên cần nắm vững.`
                    : `Please provide a detailed explanation of the following topic in Computer Science: "${topic}". Explain the core concepts, provide illustrative examples, and highlight the most important points a student needs to master.`;

                const encodedPrompt = encodeURIComponent(promptText);
                const url = `https://gemini.google.com/app?prompt=${encodedPrompt}`;
                
                window.open(url, '_blank');
            }
        }
    </script>
</body>
</html>
