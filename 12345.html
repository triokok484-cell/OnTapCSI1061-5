<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSI FPTU - Công cụ Ôn tập Nâng cao</title>
    <style>
        :root {
            --fpt-blue: #0055a5;
            --fpt-orange: #f26f21;
            --info-blue: #007bff;
            --text-color: #333;
            --bg-color: #f8f9fa;
            --container-bg: #ffffff;
            --highlight-bg: #fff3cd;
            --highlight-text: #856404;
            --correct-bg: #d4edda;
            --correct-border: #c3e6cb;
            --incorrect-bg: #f8d7da;
            --incorrect-border: #f5c6cb;
            --explanation-bg: #e2e3e5;
        }
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            line-height: 1.7;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        .container {
            max-width: 960px;
            margin: auto;
            background: var(--container-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        header {
            text-align: center;
            border-bottom: 3px solid var(--fpt-blue);
            padding-bottom: 15px;
            margin-bottom: 25px;
        }
        header h1 {
            color: var(--fpt-blue);
            margin: 0 0 5px 0;
        }
        .lang-switcher {
            margin-top: 15px;
        }
        .lang-switcher button {
            padding: 6px 12px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            cursor: pointer;
            margin: 0 5px;
            border-radius: 5px;
            font-size: 14px;
        }
        .lang-switcher button.active {
            background-color: var(--fpt-blue);
            color: white;
            border-color: var(--fpt-blue);
        }
        .tab-nav {
            display: flex;
            margin-bottom: 25px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .tab-link {
            flex: 1;
            padding: 15px;
            cursor: pointer;
            border: none;
            background-color: #e9ecef;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.3s, color 0.3s;
            text-align: center;
        }
        .tab-link.active {
            background-color: var(--fpt-orange);
            color: white;
        }
        .tab-link:hover:not(.active) {
            background-color: #dee2e6;
        }
        .tab-pane { display: none; }
        .tab-pane.active { display: block; }
        
        .theory-content h2 { color: var(--fpt-blue); border-bottom: 2px solid var(--fpt-orange); padding-bottom: 5px; }
        .theory-content h3 { color: #333; margin-top: 25px; }
        .theory-content h4 { color: #555; margin-top: 20px; }
        .theory-content ul { list-style-type: none; padding-left: 0; }
        .theory-content li { background: #f8f9fa; margin-bottom: 10px; padding: 15px; border-left: 4px solid var(--fpt-blue); border-radius: 5px; }
        .theory-content ul ul { margin-top: 10px; }
        .theory-content li li { background: #e9ecef; border-left-color: var(--fpt-orange); }
        .theory-content code, .theory-content pre {
            font-family: Consolas, 'Courier New', monospace;
            background-color: #e9ecef;
            padding: 2px 5px;
            border-radius: 4px;
        }
        .theory-content pre {
            padding: 15px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            border-left: 4px solid #ccc;
        }

        .highlight {
            background-color: var(--highlight-bg);
            padding: 3px 6px;
            border-radius: 4px;
            font-weight: bold;
            color: var(--highlight-text);
        }
        .quiz-view, .quiz-setup, .quiz-results { display: none; }
        .quiz-container, .quiz-setup, .quiz-results {
            border: 1px solid #dee2e6;
            padding: 25px;
            margin-top: 25px;
            border-radius: 8px;
            background-color: #fafafa;
        }
        .quiz-question {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .quiz-options button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 14px;
            margin: 8px 0;
            border: 1px solid #ccc;
            background-color: var(--container-bg);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            font-size: 16px;
        }
        .quiz-options button:hover:not([disabled]) {
            background-color: #e9e9e9;
            border-color: #aaa;
        }
        .quiz-options button.correct {
            background-color: var(--correct-bg);
            border-color: var(--correct-border);
            font-weight: bold;
        }
        .quiz-options button.incorrect {
            background-color: var(--incorrect-bg);
            border-color: var(--incorrect-border);
        }
        .explanation-box {
            margin-top: 15px;
            padding: 15px;
            background-color: var(--explanation-bg);
            border-radius: 6px;
            border: 1px solid #ced4da;
        }
        .button-group button, .quiz-setup button, .quiz-results button, .quiz-setup input {
            padding: 12px 22px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 6px;
            margin: 10px 5px 10px 0;
            border: none;
            font-weight: 500;
        }
        .quiz-setup input {
            width: 80px;
            border: 1px solid #ccc;
            border-radius: 6px;
            text-align: center;
        }
        .primary-button { background-color: var(--fpt-blue); color: white; }
        .secondary-button { background-color: #6c757d; color: white; }
        .info-button { background-color: var(--info-blue); color: white; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 data-lang-key="title">CSI FPTU - Công cụ Ôn tập Nâng cao</h1>
            <p data-lang-key="subtitle">Chọn chương để học lý thuyết hoặc làm bài tập trắc nghiệm.</p>
            <div class="lang-switcher">
                <button onclick="switchLanguage('vi')" class="active" data-lang-key="vietnamese">Tiếng Việt</button>
                <button onclick="switchLanguage('en')" data-lang-key="english">English</button>
            </div>
        </header>

        <div class="tab-nav">
            <button class="tab-link active" onclick="switchTab('chapter1')" data-lang-key="ch1">Chương 1</button>
            <button class="tab-link" onclick="switchTab('chapter2')" data-lang-key="ch2">Chương 2</button>
            <button class="tab-link" onclick="switchTab('chapter3')" data-lang-key="ch3">Chương 3</button>
            <button class="tab-link" onclick="switchTab('chapter4')" data-lang-key="ch4">Chương 4</button>
            <button class="tab-link" onclick="switchTab('chapter5')" data-lang-key="ch5">Chương 5</button>
        </div>

        <div class="tab-content">
            <!-- Content will be generated by JavaScript -->
        </div>
    </div>

    <script>
        // --- START: NGÂN HÀNG CÂU HỎI VÀ LÝ THUYẾT ---
        const contentData = {
            chapter1: {
                theory: {
                    vi: `
                        <h2>Chương 1: Giới thiệu Tổng quan</h2>
                        <h3>1. Các mô hình máy tính cơ bản</h3>
                        <ul>
                            <li>
                                <strong>Mô hình Turing (Turing Model):</strong>
                                <ul>
                                    <li>Định nghĩa máy tính như một <span class="highlight">bộ xử lý dữ liệu có thể lập trình được (programmable data processor)</span>.</li>
                                    <li>Đây là một mô hình lý thuyết, toán học, không phải kiến trúc vật lý.</li>
                                    <li>Công thức cốt lõi: <strong>Dữ liệu đầu vào + Chương trình -> Máy tính -> Dữ liệu đầu ra</strong>.</li>
                                    <li>Ý nghĩa: Cùng một dữ liệu đầu vào, nếu thay đổi chương trình, ta sẽ có kết quả đầu ra khác nhau. Điều này định nghĩa nên một máy tính đa năng (general-purpose).</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Mô hình von Neumann (von Neumann Model):</strong>
                                <ul>
                                    <li>Mô hình kiến trúc cho hầu hết các máy tính hiện đại.</li>
                                    <li><span class="highlight">Khái niệm đột phá: Chương trình được lưu trong bộ nhớ (Stored Program Concept)</span>. Cả chương trình (tập lệnh) và dữ liệu đều được lưu trữ trong cùng một bộ nhớ và có cùng định dạng (nhị phân).</li>
                                    <li>Kiến trúc bao gồm 4 hệ thống con (subsystems):
                                        <ol>
                                            <li><strong>Bộ nhớ (Memory):</strong> Lưu trữ chương trình và dữ liệu.</li>
                                            <li><strong>Đơn vị Số học & Logic (Arithmetic Logic Unit - ALU):</strong> Thực hiện các phép tính và so sánh logic.</li>
                                            <li><strong>Đơn vị Điều khiển (Control Unit):</strong> Điều phối hoạt động của tất cả các thành phần khác.</li>
                                            <li><strong>Hệ thống Vào/Ra (Input/Output Subsystem):</strong> Giao tiếp với thế giới bên ngoài (bàn phím, màn hình, ổ cứng...).</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Ba thành phần của máy tính</h3>
                        <ul>
                            <li><strong>Phần cứng (Hardware):</strong> Các thành phần vật lý của máy tính (CPU, RAM, ổ đĩa, ...).</li>
                            <li><strong>Dữ liệu (Data):</strong> Các thông tin thô (số, văn bản, hình ảnh) được máy tính xử lý. Dữ liệu được biểu diễn dưới dạng nhị phân.</li>
                            <li><strong>Phần mềm (Software):</strong> Tập hợp các chương trình (tập lệnh) hướng dẫn phần cứng phải làm gì. Phần mềm là cầu nối giữa người dùng và phần cứng.</li>
                        </ul>
                    `,
                    en: `
                        <h2>Chapter 1: Introduction</h2>
                        <h3>1. Basic Computer Models</h3>
                        <ul>
                            <li>
                                <strong>Turing Model:</strong>
                                <ul>
                                    <li>Defines a computer as a <span class="highlight">programmable data processor</span>.</li>
                                    <li>This is a theoretical, mathematical model, not a physical architecture.</li>
                                    <li>Core formula: <strong>Input Data + Program -> Computer -> Output Data</strong>.</li>
                                    <li>Significance: With the same input data, changing the program yields a different output. This defines a general-purpose computer.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>von Neumann Model:</strong>
                                <ul>
                                    <li>The architectural model for most modern computers.</li>
                                    <li><span class="highlight">Breakthrough concept: The Stored Program Concept</span>. Both the program (instructions) and data are stored in the same memory and share the same format (binary).</li>
                                    <li>The architecture consists of four subsystems:
                                        <ol>
                                            <li><strong>Memory:</strong> Stores programs and data.</li>
                                            <li><strong>Arithmetic Logic Unit (ALU):</strong> Performs calculations and logical comparisons.</li>
                                            <li><strong>Control Unit:</strong> Coordinates the operations of all other components.</li>
                                            <li><strong>Input/Output (I/O) Subsystem:</strong> Communicates with the outside world (keyboard, monitor, drives...).</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Three Components of a Computer</h3>
                        <ul>
                            <li><strong>Hardware:</strong> The physical parts of the computer (CPU, RAM, disk drive, etc.).</li>
                            <li><strong>Data:</strong> Raw information (numbers, text, images) that the computer processes. Data is represented in binary format.</li>
                            <li><strong>Software:</strong> A collection of programs (sets of instructions) that tells the hardware what to do. Software is the bridge between the user and the hardware.</li>
                        </ul>
                    `
                },
                questions: [
                    { q: { vi: "Mô hình nào định nghĩa khái niệm 'Stored Program Concept' (Chương trình được lưu trong bộ nhớ)?", en: "Which model defines the 'Stored Program Concept'?" }, o: [{ vi: "Mô hình Turing", en: "Turing Model" }, { vi: "Mô hình von Neumann", en: "von Neumann Model" }, { vi: "Mô hình Pascal", en: "Pascal Model" }, { vi: "Mô hình Babbage", en: "Babbage Model" }], a: 1, explanation: { vi: "Ghi nhớ: Von Neumann = Chương trình trong Bộ nhớ. Đây là kiến trúc máy tính hiện đại.", en: "Remember: Von Neumann = Program in Memory. This is the modern computer architecture." } },
                    { q: { vi: "Theo mô hình Turing, đầu ra phụ thuộc vào yếu tố nào?", en: "According to the Turing model, what does the output depend on?" }, o: [{ vi: "Chỉ dữ liệu đầu vào", en: "Only the input data" }, { vi: "Chỉ chương trình", en: "Only the program" }, { vi: "Sự kết hợp của dữ liệu đầu vào và chương trình", en: "The combination of input data and the program" }, { vi: "Tốc độ của máy tính", en: "The speed of the computer" }], a: 2, explanation: { vi: "Máy Turing là một 'bộ xử lý dữ liệu LẬP TRÌNH ĐƯỢC'. 'Lập trình được' có nghĩa là chương trình quyết định cách xử lý dữ liệu.", en: "A Turing machine is a 'PROGRAMMABLE data processor'. 'Programmable' means the program dictates how the data is handled." } },
                    { q: { vi: "Bốn thành phần của máy tính theo kiến trúc von Neumann là gì?", en: "What are the four components of a computer according to the von Neumann architecture?"}, o: [ {vi: "CPU, RAM, Bàn phím, Màn hình", en: "CPU, RAM, Keyboard, Monitor"}, {vi: "Bộ nhớ, ALU, Đơn vị điều khiển, Thiết bị Vào/Ra", en: "Memory, ALU, Control Unit, Input/Output Subsystem"}, {vi: "Phần cứng, Phần mềm, Dữ liệu, Mạng", en: "Hardware, Software, Data, Network"}, {vi: "Hệ điều hành, Ứng dụng, Driver, Firmware", en: "Operating System, Application, Driver, Firmware"}], a: 1, explanation: {vi: "Kiến trúc von Neumann định nghĩa 4 khối chức năng chính: Memory (bộ nhớ), ALU (đơn vị số học logic), Control Unit (đơn vị điều khiển), và I/O (vào/ra).", en: "The von Neumann architecture defines 4 main functional blocks: Memory, ALU (Arithmetic Logic Unit), Control Unit, and I/O (Input/Output)."}},
                    { q: { vi: "Thành phần nào của CPU chịu trách nhiệm thực hiện các phép toán số học và logic?", en: "Which component of the CPU is responsible for performing arithmetic and logic operations?"}, o: [ {vi: "Control Unit", en: "Control Unit"}, {vi: "Registers", en: "Registers"}, {vi: "ALU (Arithmetic Logic Unit)", en: "ALU (Arithmetic Logic Unit)"}, {vi: "Main Memory", en: "Main Memory"}], a: 2, explanation: {vi: "ALU là viết tắt của Arithmetic Logic Unit, chuyên thực hiện các phép tính toán (+, -, *, /) và các phép so sánh logic (AND, OR, NOT).", en: "ALU stands for Arithmetic Logic Unit, which specializes in performing calculations (+, -, *, /) and logical operations (AND, OR, NOT)."}},
                    { q: { vi: "Sự khác biệt chính giữa máy tính đa năng (general-purpose) và máy tính chuyên dụng (specific-purpose) là gì?", en: "What is the main difference between a general-purpose and a specific-purpose computer?"}, o: [ {vi: "Kích thước vật lý", en: "Physical size"}, {vi: "Khả năng chạy các chương trình khác nhau", en: "The ability to run different programs"}, {vi: "Giá thành", en: "Cost"}, {vi: "Tốc độ xử lý", en: "Processing speed"}], a: 1, explanation: {vi: "Máy tính đa năng (như PC) có thể thực hiện nhiều tác vụ bằng cách chạy các chương trình khác nhau. Máy tính chuyên dụng (như máy tính trong lò vi sóng) chỉ được thiết kế cho một nhiệm vụ duy nhất.", en: "A general-purpose computer (like a PC) can perform many tasks by running different programs. A specific-purpose computer (like one in a microwave) is designed for only one task."}}
                ]
            },
            chapter2: {
                 theory: {
                     vi: `
                        <h2>Chương 2: Hệ thống Số</h2>
                        <h3>1. Các hệ đếm cơ bản (Positional Number Systems)</h3>
                        <ul>
                            <li><strong>Khái niệm:</strong> Giá trị của một chữ số phụ thuộc vào <span class="highlight">vị trí (position)</span> của nó trong chuỗi số. Mỗi vị trí có một trọng số (place value) là lũy thừa của cơ số (base/radix).</li>
                            <li><strong>Các hệ đếm chính:</strong>
                                <ul>
                                    <li><strong>Thập phân (Decimal - Base 10):</strong> Dùng 10 ký tự {0, 1, ..., 9}.</li>
                                    <li><strong>Nhị phân (Binary - Base 2):</strong> Dùng 2 ký tự {0, 1}. Đây là <span class="highlight">ngôn ngữ tự nhiên của máy tính</span>.</li>
                                    <li><strong>Bát phân (Octal - Base 8):</strong> Dùng 8 ký tự {0, 1, ..., 7}.</li>
                                    <li><strong>Thập lục phân (Hexadecimal - Base 16):</strong> Dùng 16 ký tự {0, 1, ..., 9, A, B, C, D, E, F}.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Ví dụ về Chuyển đổi</h3>
                        <h4>Chuyển từ hệ bất kỳ sang Thập phân</h4>
                        <p>Quy tắc: Lấy từng chữ số nhân với (cơ số)<sup>vị trí</sup> rồi cộng tất cả lại.</p>
                        <pre><strong>Ví dụ 1: (11001)₂ sang thập phân</strong>
N = 1×2⁴ + 1×2³ + 0×2² + 0×2¹ + 1×2⁰
  = 16  +  8   +  0   +  0   +  1
  = 25₁₀

<strong>Ví dụ 2: (2AE)₁₆ sang thập phân (A=10, E=14)</strong>
N = 2×16² + 10×16¹ + 14×16⁰
  = 2×256 + 10×16  + 14×1
  = 512   + 160    + 14
  = 686₁₀</pre>
                        <h4>Chuyển từ Thập phân sang hệ bất kỳ (Phần nguyên)</h4>
                        <p>Quy tắc: <span class="highlight">Chia liên tiếp</span> cho cơ số mới, lấy phần dư theo thứ tự ngược lại.</p>
                        <pre><strong>Ví dụ: 35₁₀ sang nhị phân (chia cho 2)</strong>
35 / 2 = 17 dư 1  ↑
17 / 2 = 8  dư 1  |
 8 / 2 = 4  dư 0  | Đọc ngược
 4 / 2 = 2  dư 0  | từ dưới lên
 2 / 2 = 1  dư 0  |
 1 / 2 = 0  dư 1  ↑
Kết quả: (100011)₂</pre>
                        <h4>Chuyển đổi nhanh giữa Binary ↔ Octal ↔ Hexadecimal</h4>
                        <p>Quy tắc: Gom nhóm <span class="highlight">3 bits</span> cho Octal và <span class="highlight">4 bits</span> cho Hexadecimal.</p>
                        <pre><strong>Ví dụ 1: (10011100010)₂ sang Hexadecimal (gom nhóm 4)</strong>
   100  1110  0010   (Thêm 2 số 0 vào đầu cho đủ nhóm)
→ 0100  1110  0010
    ↓     ↓     ↓
    4     E     2
Kết quả: (4E2)₁₆

<strong>Ví dụ 2: (101110010)₂ sang Octal (gom nhóm 3)</strong>
  101  110  010
   ↓    ↓    ↓
   5    6    2
Kết quả: (562)₈</pre>
                    `,
                    en: `
                        <h2>Chapter 2: Number Systems</h2>
                        <h3>1. Positional Number Systems</h3>
                        <ul>
                            <li><strong>Concept:</strong> The value of a digit depends on its <span class="highlight">position</span> within the number string. Each position has a place value, which is a power of the base (radix).</li>
                            <li><strong>Main Systems:</strong>
                                <ul>
                                    <li><strong>Decimal (Base 10):</strong> Uses 10 symbols {0, 1, ..., 9}.</li>
                                    <li><strong>Binary (Base 2):</strong> Uses 2 symbols {0, 1}. This is the <span class="highlight">natural language of computers</span>.</li>
                                    <li><strong>Octal (Base 8):</strong> Uses 8 symbols {0, 1, ..., 7}.</li>
                                    <li><strong>Hexadecimal (Base 16):</strong> Uses 16 symbols {0, 1, ..., 9, A, B, C, D, E, F}.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Conversion Examples</h3>
                        <h4>Convert from Any Base to Decimal</h4>
                        <p>Rule: Multiply each digit by (base)<sup>position</sup> and sum the results.</p>
                        <pre><strong>Example 1: (11001)₂ to decimal</strong>
N = 1×2⁴ + 1×2³ + 0×2² + 0×2¹ + 1×2⁰
  = 16  +  8   +  0   +  0   +  1
  = 25₁₀

<strong>Example 2: (2AE)₁₆ to decimal (A=10, E=14)</strong>
N = 2×16² + 10×16¹ + 14×16⁰
  = 2×256 + 10×16  + 14×1
  = 512   + 160    + 14
  = 686₁₀</pre>
                        <h4>Convert from Decimal to Any Base (Integer Part)</h4>
                        <p>Rule: <span class="highlight">Repeatedly divide</span> by the new base, take the remainders in reverse order.</p>
                        <pre><strong>Example: 35₁₀ to binary (divide by 2)</strong>
35 / 2 = 17 rem 1  ↑
17 / 2 = 8  rem 1  |
 8 / 2 = 4  rem 0  | Read in reverse
 4 / 2 = 2  rem 0  | order
 2 / 2 = 1  rem 0  |
 1 / 2 = 0  rem 1  ↑
Result: (100011)₂</pre>
                        <h4>Quick Conversion between Binary ↔ Octal ↔ Hexadecimal</h4>
                        <p>Rule: Group <span class="highlight">3 bits</span> for Octal and <span class="highlight">4 bits</span> for Hexadecimal.</p>
                        <pre><strong>Example 1: (10011100010)₂ to Hexadecimal (group of 4)</strong>
   100  1110  0010   (Pad with two leading zeros)
→ 0100  1110  0010
    ↓     ↓     ↓
    4     E     2
Result: (4E2)₁₆

<strong>Example 2: (101110010)₂ to Octal (group of 3)</strong>
  101  110  010
   ↓    ↓    ↓
   5    6    2
Result: (562)₈</pre>
                    `
                },
                questions: [
                     { q: { vi: "Trong một hệ số vị (positional number system), radix (base) là gì?", en: "In a positional number system, what is the radix (base)?"}, o: [ {vi: "Giá trị lớn nhất có thể biểu diễn bằng một chữ số.", en: "The maximum value representable by a single digit."}, {vi: "Số chữ số tối đa cho biểu diễn số nguyên.", en: "The maximum number of digits for an integer representation."}, {vi: "Số kí hiệu (symbols) trong hệ (số lượng chữ số khác nhau).", en: "The number of symbols in the system (the count of different digits)."}, {vi: "Tổng các giá trị chữ số trong một số.", en: "The sum of the digit values in a number."}], a: 2, explanation: {vi: "Radix (base) định nghĩa số lượng ký hiệu duy nhất được sử dụng trong hệ đếm đó. Ví dụ, hệ thập phân có base 10 vì nó dùng 10 ký hiệu (0-9).", en: "The radix (base) defines the number of unique symbols used in that number system. For example, the decimal system has a base of 10 because it uses 10 symbols (0-9)."}},
                    { q: { vi: "Hệ thập phân (decimal) có base bằng bao nhiêu?", en: "What is the base of the decimal system?"}, o: [ {vi: "2", en: "2"}, {vi: "8", en: "8"}, {vi: "10", en: "10"}, {vi: "16", en: "16"}], a: 2, explanation: {vi: "Hệ thập phân (decimal) quen thuộc với chúng ta sử dụng 10 chữ số từ 0 đến 9, do đó cơ số (base) của nó là 10.", en: "The familiar decimal system uses 10 digits from 0 to 9, so its base is 10."}},
                    { q: { vi: "Trong hệ nhị phân (binary), mỗi chữ số gọi là gì?", en: "In the binary system, what is each digit called?"}, o: [ {vi: "nibble", en: "nibble"}, {vi: "digit", en: "digit"}, {vi: "byte", en: "byte"}, {vi: "bit", en: "bit"}], a: 3, explanation: {vi: "Một chữ số trong hệ nhị phân được gọi là 'bit', viết tắt của 'binary digit'.", en: "A digit in the binary system is called a 'bit', which is short for 'binary digit'."}},
                    { q: { vi: "Ký tự 'B' trong hệ thập lục phân (hex) tương đương với giá trị thập phân nào?", en: "The character 'B' in the hexadecimal system is equivalent to which decimal value?"}, o: [ {vi: "10", en: "10"}, {vi: "11", en: "11"}, {vi: "12", en: "12"}, {vi: "13", en: "13"}], a: 1, explanation: {vi: "Trong hệ thập lục phân, các chữ cái A, B, C, D, E, F lần lượt biểu diễn các giá trị 10, 11, 12, 13, 14, 15.", en: "In hexadecimal, the letters A, B, C, D, E, F represent the values 10, 11, 12, 13, 14, 15, respectively."}},
                    { q: { vi: "Giá trị thập phân của (11001)₂ là:", en: "The decimal value of (11001)₂ is:"}, o: [ {vi: "25", en: "25"}, {vi: "27", en: "27"}, {vi: "29", en: "29"}, {vi: "31", en: "31"}], a: 0, explanation: {vi: "Tính toán: (1 × 2⁴) + (1 × 2³) + (0 × 2²) + (0 × 2¹) + (1 × 2⁰) = 16 + 8 + 0 + 0 + 1 = 25.", en: "Calculation: (1 × 2⁴) + (1 × 2³) + (0 × 2²) + (0 × 2¹) + (1 × 2⁰) = 16 + 8 + 0 + 0 + 1 = 25."}}
                ]
            },
            chapter3: {
                theory: {
                    vi: `
                        <h2>Chương 3: Lưu trữ Dữ liệu</h2>
                        <h3>1. Các kiểu dữ liệu cơ bản</h3>
                        <ul>
                            <li>Máy tính xử lý nhiều loại dữ liệu: Số (Numbers), Văn bản (Text), Âm thanh (Audio), Hình ảnh (Images), Video.</li>
                            <li>Tất cả các loại dữ liệu này đều được chuyển đổi thành một dạng duy nhất để lưu trữ: <span class="highlight">chuỗi bit (bit pattern)</span>.</li>
                        </ul>
                        <h3>2. Lưu trữ số nguyên (Storing Integers)</h3>
                        <ul>
                            <li><strong>Số nguyên không dấu (Unsigned Integers):</strong>
                                <ul><li>Chỉ biểu diễn số không âm (0 và các số dương). Một chuỗi n bit có thể biểu diễn các giá trị từ 0 đến 2ⁿ-1.</li></ul>
                            </li>
                            <li><strong>Số nguyên có dấu (Signed Integers):</strong>
                                <ul>
                                    <li><strong>Sign-and-Magnitude:</strong> Bit ngoài cùng bên trái dùng cho dấu (0 là +, 1 là -), các bit còn lại biểu diễn độ lớn. Nhược điểm: có hai giá trị zero (+0 và -0).</li>
                                    <li><span class="highlight">Two's Complement (Bù 2):</span> Phương pháp chuẩn hiện nay.
                                        <ul>
                                            <li>Số dương được biểu diễn như số không dấu (với bit dấu là 0).</li>
                                            <li>Số âm được biểu diễn bằng cách lấy bù 2 của số dương tương ứng. (Cách lấy bù 2: Đảo tất cả các bit rồi cộng 1).</li>
                                            <li>Ưu điểm: Chỉ có một giá trị zero, phép trừ có thể thực hiện bằng phép cộng, giúp đơn giản hóa mạch logic.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                             <li><strong>Tràn số (Overflow):</strong> Xảy ra khi kết quả của một phép toán vượt ra ngoài phạm vi biểu diễn cho phép. Ví dụ: cộng hai số 8-bit dương lớn ra kết quả có bit dấu là 1 (số âm).</li>
                        </ul>
                        <h3>3. Lưu trữ số thực (Storing Reals)</h3>
                        <ul>
                            <li>
                                <strong>Floating-Point (Dấu phẩy động) - Chuẩn IEEE 754:</strong>
                                <ul>
                                    <li>Biểu diễn một số dưới dạng khoa học: (Dấu) × (Định trị) × (Cơ số)<sup>Số mũ</sup>.</li>
                                    <li>Một số thực được lưu trữ thành 3 phần:
                                        <ol>
                                            <li><strong>Sign (S):</strong> 1 bit (0 cho dương, 1 cho âm).</li>
                                            <li><strong>Exponent (E):</strong> Số mũ, được lưu trữ bằng phương pháp <span class="highlight">Excess representation</span> (cộng một số bias để luôn là số dương).</li>
                                            <li><strong>Mantissa (M):</strong> Phần định trị (phần sau dấu chấm của số đã được chuẩn hóa).</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    `,
                    en: `
                        <h2>Chapter 3: Data Storage</h2>
                        <h3>1. Basic Data Types</h3>
                        <ul>
                            <li>Computers process various data types: Numbers, Text, Audio, Images, Video.</li>
                            <li>All these data types are converted into a single uniform representation for storage: the <span class="highlight">bit pattern</span>.</li>
                        </ul>
                        <h3>2. Storing Integers</h3>
                        <ul>
                            <li><strong>Unsigned Integers:</strong>
                                <ul><li>Represent only non-negative numbers (0 and positives). An n-bit pattern can represent values from 0 to 2ⁿ-1.</li></ul>
                            </li>
                            <li><strong>Signed Integers:</strong>
                                <ul>
                                    <li><strong>Sign-and-Magnitude:</strong> The leftmost bit is for the sign (0 for +, 1 for -), the rest represent the magnitude. Drawback: has two representations of zero (+0 and -0).</li>
                                    <li><span class="highlight">Two's Complement:</span> The standard method today.
                                        <ul>
                                            <li>Positive numbers are represented like unsigned integers (with a sign bit of 0).</li>
                                            <li>Negative numbers are represented by taking the two's complement of the corresponding positive number. (How to take two's complement: Invert all bits then add 1).</li>
                                            <li>Advantages: Only one representation of zero, subtraction can be performed by addition, simplifying logic circuits.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Overflow:</strong> Occurs when the result of an operation falls outside the representable range. E.g., adding two large positive 8-bit numbers results in a number with a sign bit of 1 (negative).</li>
                        </ul>
                        <h3>3. Storing Reals</h3>
                        <ul>
                            <li>
                                <strong>Floating-Point - IEEE 754 Standard:</strong>
                                <ul>
                                    <li>Represents a number in scientific notation: (Sign) × (Mantissa) × (Base)<sup>Exponent</sup>.</li>
                                    <li>A real number is stored in 3 parts:
                                        <ol>
                                            <li><strong>Sign (S):</strong> 1 bit (0 for positive, 1 for negative).</li>
                                            <li><strong>Exponent (E):</strong> Stored using <span class="highlight">Excess representation</span> (a bias is added to make it always positive).</li>
                                            <li><strong>Mantissa (M):</strong> The fractional part of the normalized number.</li>
                                        </ol>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    `
                },
                questions: [
                    { q: { vi: "Khi được lưu trữ trong máy tính, tất cả các loại dữ liệu đều được chuyển đổi thành một dạng biểu diễn thống nhất. Dạng biểu diễn chung này được gọi là gì?", en: "When stored in a computer, all data types are converted into a uniform representation. What is this common representation called?"}, o: [{vi: "Một byte (A byte)", en: "A byte"}, {vi: "Một mẫu bit (A bit pattern)", en: "A bit pattern"}, {vi: "Một từ (A word)", en: "A word"}, {vi: "Một con số (A number)", en: "A number"}], a: 1, explanation: {vi: "Dù là số, chữ, hay hình ảnh, tất cả đều được mã hóa thành các chuỗi 0 và 1, được gọi là mẫu bit.", en: "Whether it's a number, text, or image, everything is encoded into strings of 0s and 1s, known as a bit pattern."} },
                    { q: { vi: "Đơn vị dữ liệu nhỏ nhất có thể được lưu trữ trong máy tính là gì?", en: "What is the smallest unit of data that can be stored in a computer?"}, o: [{vi: "Byte", en: "Byte"}, {vi: "Bit", en: "Bit"}, {vi: "Word", en: "Word"}, {vi: "Nibble", en: "Nibble"}], a: 1, explanation: {vi: "Một bit (binary digit) là đơn vị cơ bản nhất, chỉ có thể có giá trị 0 hoặc 1.", en: "A bit (binary digit) is the most fundamental unit, capable of holding only a value of 0 or 1."} },
                    { q: { vi: "Theo quy ước, một mẫu bit gồm tám bit được gọi là một ________.", en: "By tradition, a bit pattern with eight bits is called a ________."}, o: [{vi: "Từ (Word)", en: "Word"}, {vi: "Bit", en: "Bit"}, {vi: "Số nguyên (Integer)", en: "Integer"}, {vi: "Byte", en: "Byte"}], a: 3, explanation: {vi: "8 bit được nhóm lại thành một đơn vị gọi là byte. Đây là đơn vị đo lường bộ nhớ phổ biến nhất.", en: "8 bits are grouped into a unit called a byte. It's the most common unit of memory measurement."} },
                    { q: { vi: "Phương pháp biểu diễn nào thường được sử dụng để lưu trữ số nguyên trong bộ nhớ máy tính, trong đó dấu thập phân được giả định nhưng không được lưu trữ?", en: "Which representation is typically used to store integers in computer memory, where the decimal point is assumed but not stored?"}, o: [{vi: "Biểu diễn dấu phẩy động (Floating-point representation)", en: "Floating-point representation"}, {vi: "Ký hiệu khoa học (Scientific notation)", en: "Scientific notation"}, {vi: "Biểu diễn dấu phẩy tĩnh (Fixed-point representation)", en: "Fixed-point representation"}, {vi: "Biểu diễn dấu-lượng (Sign-and-magnitude representation)", en: "Sign-and-magnitude representation"}], a: 2, explanation: {vi: "Số nguyên được coi là có dấu phẩy ở cuối (ví dụ: 123.), vị trí này là cố định, do đó gọi là biểu diễn dấu phẩy tĩnh (fixed-point).", en: "An integer is considered to have a decimal point at the end (e.g., 123.). This position is fixed, hence the name fixed-point representation."} },
                    { q: { vi: "Hầu hết các máy tính ngày nay sử dụng phương pháp biểu diễn số nguyên nào để lưu trữ số nguyên có dấu?", en: "Which integer representation do most computers today use to store signed integers?"}, o: [{vi: "Biểu diễn không dấu (Unsigned representation)", en: "Unsigned representation"}, {vi: "Biểu diễn dấu-lượng (Sign-and-magnitude representation)", en: "Sign-and-magnitude representation"}, {vi: "Biểu diễn bù hai (Two's complement representation)", en: "Two's complement representation"}, {vi: "Biểu diễn bù một (One's complement representation)", en: "One's complement representation"}], a: 2, explanation: {vi: "Bù hai (Two's complement) là tiêu chuẩn vì nó giải quyết vấn đề hai số 0 và đơn giản hóa mạch logic cho phép trừ (biến nó thành phép cộng).", en: "Two's complement is the standard because it solves the two-zeros problem and simplifies the logic circuit for subtraction (by turning it into addition)."}}
                ]
            },
            chapter4: {
                 theory: {
                    vi: `
                        <h2>Chương 4: Các Phép toán trên Dữ liệu</h2>
                        <h3>1. Phép toán Logic (Logic Operations)</h3>
                        <ul>
                            <li>Thực hiện trên từng bit của một hoặc hai chuỗi bit. Các toán tử chính:
                                <ul>
                                    <li><strong>NOT:</strong> Đảo bit (0 thành 1, 1 thành 0).</li>
                                    <li><strong>AND:</strong> Kết quả là 1 chỉ khi cả hai bit đầu vào đều là 1.</li>
                                    <li><strong>OR:</strong> Kết quả là 1 nếu ít nhất một trong hai bit đầu vào là 1.</li>
                                    <li><strong>XOR (Exclusive OR):</strong> Kết quả là 1 chỉ khi hai bit đầu vào khác nhau.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Ứng dụng: Dùng mặt nạ (Masking)</strong>
                                <ul>
                                    <li><span class="highlight">Unsetting (Xóa bit về 0):</span> Dùng phép <strong>AND</strong> với mặt nạ có bit 0 tại vị trí cần xóa.</li>
                                    <li><span class="highlight">Setting (Bật bit lên 1):</span> Dùng phép <strong>OR</strong> với mặt nạ có bit 1 tại vị trí cần bật.</li>
                                    <li><span class="highlight">Flipping (Lật bit):</span> Dùng phép <strong>XOR</strong> với mặt nạ có bit 1 tại vị trí cần lật.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Ví dụ về Masking</h3>
                        <pre><strong>Ví dụ: Xóa (unset) 5 bit ngoài cùng bên trái của 10100110</strong>
  1010 0110   (Dữ liệu gốc)
& 0000 0111   (Mặt nạ AND - 0 ở vị trí cần xóa)
-----------
  0000 0110   (Kết quả)

<strong>Ví dụ: Lật (flip) 5 bit ngoài cùng bên trái của 10100110</strong>
  1010 0110   (Dữ liệu gốc)
^ 1111 1000   (Mặt nạ XOR - 1 ở vị trí cần lật)
-----------
  0101 1110   (Kết quả)</pre>
                        <h3>3. Phép toán Dịch chuyển (Shift Operations)</h3>
                        <ul>
                             <li><strong>Dịch logic (Logical Shift):</strong> Dịch chuyển các bit, chèn số 0 vào chỗ trống. Dùng cho số không dấu.</li>
                             <li><strong>Dịch số học (Arithmetic Shift):</strong> Dùng cho số bù 2. Khi dịch phải, bit dấu được giữ nguyên để bảo toàn giá trị âm/dương. Dịch trái tương đương nhân 2, dịch phải tương đương chia 2.</li>
                        </ul>
                        <h3>4. Phép toán Số học (Arithmetic Operations)</h3>
                        <ul>
                            <li>Phép cộng số Bù 2 được thực hiện như cộng nhị phân thông thường, bit nhớ cuối cùng (nếu có) sẽ bị bỏ đi.</li>
                            <li><span class="highlight">Phép trừ A - B được thực hiện bằng phép cộng: A + (Bù 2 của B)</span>.</li>
                        </ul>
                         <pre><strong>Ví dụ: (+24) + (-17) dùng số bù 2 8-bit</strong>
+24       = 0001 1000
-17       = 1110 1111  (Bù 2 của 17)
-------------------
Kết quả: (1)0000 0111  (Bỏ bit nhớ cuối)
          = 7₁₀ (Đúng)</pre>
                    `,
                    en: `
                        <h2>Chapter 4: Operations on Data</h2>
                        <h3>1. Logic Operations</h3>
                        <ul>
                            <li>Performed on individual bits of one or two bit patterns. Main operators:
                                <ul>
                                    <li><strong>NOT:</strong> Inverts the bit (0 becomes 1, 1 becomes 0).</li>
                                    <li><strong>AND:</strong> The result is 1 only if both input bits are 1.</li>
                                    <li><strong>OR:</strong> The result is 1 if at least one of the input bits is 1.</li>
                                    <li><strong>XOR (Exclusive OR):</strong> The result is 1 only if the input bits are different.</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Application: Masking</strong>
                                <ul>
                                    <li><span class="highlight">Unsetting a bit (to 0):</span> Use <strong>AND</strong> with a mask that has a 0 at the desired position.</li>
                                    <li><span class="highlight">Setting a bit (to 1):</span> Use <strong>OR</strong> with a mask that has a 1 at the desired position.</li>
                                    <li><span class="highlight">Flipping a bit:</span> Use <strong>XOR</strong> with a mask that has a 1 at the desired position.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>2. Masking Examples</h3>
                        <pre><strong>Example: Unset the five leftmost bits of 10100110</strong>
  1010 0110   (Original Data)
& 0000 0111   (AND Mask - 0s where you want to clear)
-----------
  0000 0110   (Result)

<strong>Example: Flip the five leftmost bits of 10100110</strong>
  1010 0110   (Original Data)
^ 1111 1000   (XOR Mask - 1s where you want to flip)
-----------
  0101 1110   (Result)</pre>
                        <h3>3. Shift Operations</h3>
                        <ul>
                             <li><strong>Logical Shift:</strong> Shifts bits and inserts a 0 into the empty spot. Used for unsigned numbers.</li>
                             <li><strong>Arithmetic Shift:</strong> Used for two's complement numbers. A right shift preserves the sign bit. Left shift is equivalent to multiplying by 2, right shift is equivalent to dividing by 2.</li>
                        </ul>
                        <h3>4. Arithmetic Operations</h3>
                        <ul>
                            <li>Two's Complement addition is performed like normal binary addition, and the final carry bit (if any) is discarded.</li>
                            <li><span class="highlight">Subtraction A - B is performed as an addition: A + (Two's complement of B)</span>.</li>
                        </ul>
                         <pre><strong>Example: (+24) + (-17) using 8-bit two's complement</strong>
+24       = 0001 1000
-17       = 1110 1111  (Two's complement of 17)
-------------------
Result: (1)0000 0111  (Discard final carry)
          = 7₁₀ (Correct)</pre>
                    `
                },
                questions: [
                    { q: { vi: "Kết quả của phép NOT trên 8-bit 10011000 là:", en: "The result of a NOT operation on the 8-bit pattern 10011000 is:" }, o: [{ vi: "01100111", en: "01100111" }, { vi: "10011000", en: "10011000" }, { vi: "01111000", en: "01111000" }, { vi: "00100111", en: "00100111" }], a: 0, explanation: { vi: "Vì NOT đổi 0↔1: 10011000 → 01100111.", en: "Because NOT inverts 0↔1: 10011000 → 01100111." } },
                    { q: { vi: "10011000 AND 00101010 bằng:", en: "10011000 AND 00101010 equals:" }, o: [{ vi: "00001000", en: "00001000" }, { vi: "10011010", en: "10011010" }, { vi: "00101000", en: "00101000" }, { vi: "00000000", en: "00000000" }], a: 0, explanation: { vi: "AND giữ 1 chỉ khi cả hai là 1; kết quả 00001000.", en: "AND results in 1 only when both bits are 1; the result is 00001000." } },
                    { q: { vi: "10011001 OR 00101110 bằng:", en: "10011001 OR 00101110 equals:" }, o: [{ vi: "10011111", en: "10011111" }, { vi: "10111111", en: "10111111" }, { vi: "00101111", en: "00101111" }, { vi: "10001010", en: "10001010" }], a: 1, explanation: { vi: "Bitwise OR operation results in 10111111.", en: "Bitwise OR operation results in 10111111." } },
                    { q: { vi: "10011001 XOR 00101110 bằng:", en: "10011001 XOR 00101110 equals:" }, o: [{ vi: "10110111", en: "10110111" }, { vi: "10111111", en: "10111111" }, { vi: "10011001", en: "10011001" }, { vi: "00101110", en: "00101110" }], a: 0, explanation: { vi: "XOR = 1 khi các bit khác nhau → 10110111.", en: "XOR = 1 when bits are different → 10110111." } },
                    { q: { vi: "Ta muốn unset (clear) 5 bit trái nhất của 10100110. Mask phù hợp và kết quả là:", en: "We want to unset (clear) the 5 leftmost bits of 10100110. The appropriate mask and result are:" }, o: [{ vi: "Mask 00000111, kết quả 00000110", en: "Mask 00000111, result 00000110" }, { vi: "Mask 11111000, kết quả 11111110", en: "Mask 11111000, result 11111110" }, { vi: "Mask 00011111, kết quả 00000110", en: "Mask 00011111, result 00000110" }, { vi: "Mask 00000111, kết quả 10100110", en: "Mask 00000111, result 10100110" }], a: 0, explanation: { vi: "Để unset 5 bit trái, mask cần có 0 ở 5 vị trí đó và 1 ở các vị trí còn lại: 00000111. 10100110 AND 00000111 = 00000110.", en: "To unset the 5 leftmost bits, the mask needs 0s in those positions and 1s elsewhere: 00000111. 10100110 AND 00000111 = 00000110." } },
                    { q: { vi: "Ta muốn set (force =1) 5 bit trái nhất của 10100110. Mask và kết quả là:", en: "We want to set (force to 1) the 5 leftmost bits of 10100110. The mask and result are:" }, o: [{ vi: "Mask 11111000, kết quả 11111110", en: "Mask 11111000, result 11111110" }, { vi: "Mask 00000111, kết quả 10100111", en: "Mask 00000111, result 10100111" }, { vi: "Mask 11111000, kết quả 10111110", en: "Mask 11111000, result 10111110" }, { vi: "Mask 11111111, kết quả 11111110", en: "Mask 11111111, result 11111110" }], a: 0, explanation: { vi: "Để set bit, dùng OR với mask có 1 ở vị trí cần set. OR với 11111000 → 11111110.", en: "To set bits, use OR with a mask having 1s at the desired positions. OR with 11111000 → 11111110." } },
                    { q: { vi: "Dùng mask 11111000 để flip (XOR) 5 bit trái nhất trên 10100110. Kết quả là:", en: "Using mask 11111000 to flip (XOR) the 5 leftmost bits of 10100110. The result is:" }, o: [{ vi: "01011110", en: "01011110" }, { vi: "11111110", en: "11111110" }, { vi: "00000110", en: "00000110" }, { vi: "10100110", en: "10100110" }], a: 0, explanation: { vi: "10100110 XOR 11111000 = 01011110.", en: "10100110 XOR 11111000 = 01011110." } },
                    { q: { vi: "Simple left shift 1 vị trí của 10011000 (8-bit logical shift) cho kết quả:", en: "A simple left shift by 1 position of 10011000 (8-bit logical shift) results in:" }, o: [{ vi: "00110000", en: "00110000" }, { vi: "00011000", en: "00011000" }, { vi: "00110001", en: "00110001" }, { vi: "10011000", en: "10011000" }], a: 0, explanation: { vi: "Dịch trái làm mất bit trái nhất và chèn 0 vào bên phải → 00110000.", en: "A left shift discards the leftmost bit and inserts a 0 on the right → 00110000." } },
                    { q: { vi: "Circular (rotate) left 1 vị trí của 10011000 cho:", en: "A circular (rotate) left by 1 position of 10011000 gives:" }, o: [{ vi: "00110000", en: "00110000" }, { vi: "00110001", en: "00110001" }, { vi: "11001100", en: "11001100" }, { vi: "00011001", en: "00011001" }], a: 1, explanation: { vi: "Dịch vòng trái: 10011000 → 00110001 (bit trái nhất '1' được đưa về bên phải).", en: "Left rotate: 10011000 → 00110001 (the leftmost bit '1' is moved to the rightmost position)." } },
                    { q: { vi: "Arithmetic left shift 1 vị trí trên số 8-bit two’s complement 11011001 cho kết quả nhị phân và thập phân tương ứng?", en: "An arithmetic left shift by 1 on the 8-bit two's complement number 11011001 gives what binary and decimal result?" }, o: [{ vi: "10110010 (−78)", en: "10110010 (−78)" }, { vi: "01101100 (+108)", en: "01101100 (+108)" }, { vi: "10110010 (+178)", en: "10110010 (+178)" }, { vi: "01011001 (89)", en: "01011001 (89)" }], a: 0, explanation: { vi: "Số ban đầu là -39. Dịch trái số học 1 vị trí tương đương nhân 2. -39 * 2 = -78, là 10110010 trong bù hai.", en: "The original number is -39. An arithmetic left shift by 1 is equivalent to multiplying by 2. -39 * 2 = -78, which is 10110010 in two's complement." } },
                    { q: { vi: "Để chia một số nguyên (unsigned) cho 4 ta dùng thao tác dịch bit nào?", en: "To divide an unsigned integer by 4, which bit operation is used?" }, o: [{ vi: "Right shift by 2 (logical right shift)", en: "Right shift by 2 (logical right shift)" }, { vi: "Left shift by 2", en: "Left shift by 2" }, { vi: "Circular shift right by 2", en: "Circular shift right by 2" }, { vi: "XOR với 0x03", en: "XOR with 0x03" }], a: 0, explanation: { vi: "Dịch phải 2 vị trí tương đương chia cho 2², tức là chia cho 4 (đối với số không dấu).", en: "A right shift by 2 positions is equivalent to dividing by 2², which is dividing by 4 (for unsigned numbers)." } },
                    { q: { vi: "Để nhân một số nguyên (unsigned) với 8 ta làm:", en: "To multiply an unsigned integer by 8, we do:" }, o: [{ vi: "Left shift by 3", en: "Left shift by 3" }, { vi: "Right shift by 3", en: "Right shift by 3" }, { vi: "Left shift by 2 rồi + chính nó", en: "Left shift by 2 then + itself" }, { vi: "XOR với 0x08", en: "XOR with 0x08" }], a: 0, explanation: { vi: "Dịch trái 3 vị trí tương đương nhân với 2³, tức là nhân với 8.", en: "A left shift by 3 positions is equivalent to multiplying by 2³, which is multiplying by 8." } },
                    { q: { vi: "Với 8-bit two’s complement, 19 − 23 = ? (kết quả dạng nhị phân)", en: "With 8-bit two's complement, 19 - 23 = ? (result in binary)" }, o: [{ vi: "11111100", en: "11111100" }, { vi: "00000100", en: "00000100" }, { vi: "11111011", en: "11111011" }, { vi: "00001100", en: "00001100" }], a: 0, explanation: { vi: "19 - 23 = -4. Biểu diễn bù hai 8-bit của -4 là 11111100.", en: "19 - 23 = -4. The 8-bit two's complement representation of -4 is 11111100." } },
                    { q: { vi: "Trong các phép sau (8-bit two’s complement), phép nào gây overflow?", en: "Among the following operations (8-bit two's complement), which one causes an overflow?" }, o: [{ vi: "01111111 + 00000011", en: "01111111 + 00000011" }, { vi: "11000010 + 00111111", en: "11000010 + 00111111" }, { vi: "00000010 + 00111111", en: "00000010 + 00111111" }, { vi: "00001111 + 00010000", en: "00001111 + 00010000" }], a: 0, explanation: { vi: "01111111 (+127) + 00000011 (+3) = +130. Giá trị này nằm ngoài phạm vi [-128, +127] của số bù hai 8-bit, do đó gây ra tràn số.", en: "01111111 (+127) + 00000011 (+3) = +130. This value is outside the [-128, +127] range of an 8-bit two's complement number, thus causing an overflow." } },
                    { q: { vi: "Thao tác nào là unary (một toán hạng) trong chương này?", en: "Which operation is unary (one operand) in this chapter?" }, o: [{ vi: "AND", en: "AND" }, { vi: "OR", en: "OR" }, { vi: "XOR", en: "XOR" }, { vi: "NOT", en: "NOT" }], a: 3, explanation: { vi: "NOT là toán tử đơn (unary) vì nó chỉ hoạt động trên một đầu vào.", en: "NOT is a unary operator because it only works on one input." } },
                    { q: { vi: "Trong truth table, AND trả về 1 khi:", en: "In a truth table, AND returns 1 when:" }, o: [{ vi: "ít nhất một input =1", en: "at least one input is 1" }, { vi: "cả hai input =1", en: "both inputs are 1" }, { vi: "chỉ một input =1", en: "only one input is 1" }, { vi: "cả hai input =0", en: "both inputs are 0" }], a: 1, explanation: { vi: "Phép AND chỉ đúng (1) khi tất cả các đầu vào của nó đều đúng (1).", en: "The AND operation is true (1) only when all of its inputs are true (1)." } },
                    { q: { vi: "XOR trả về 1 khi:", en: "XOR returns 1 when:" }, o: [{ vi: "cả hai input giống nhau", en: "both inputs are the same" }, { vi: "hai input khác nhau", en: "the two inputs are different" }, { vi: "cả hai đều 1", en: "both are 1" }, { vi: "cả hai đều 0", en: "both are 0" }], a: 1, explanation: { vi: "XOR (Exclusive OR) trả về 1 chỉ khi các đầu vào của nó khác nhau (một là 1, một là 0).", en: "XOR (Exclusive OR) returns 1 only when its inputs are different (one is 1, the other is 0)." } },
                    { q: "Một ứng dụng của AND ở mức pattern là:", "An application of AND at the pattern level is:", o: [{ vi: "complement toàn bộ pattern", en: "complementing the entire pattern" }, { vi: "set (force to 1) bit cụ thể", en: "setting (force to 1) a specific bit" }, { vi: "unset (force to 0) bit cụ thể bằng mask", en: "unsetting (force to 0) a specific bit using a mask" }, { vi: "flip bit cụ thể", en: "flipping a specific bit" }], a: 2, explanation: { vi: "Phép AND với một mask có bit 0 tại một vị trí sẽ buộc bit tương ứng trong kết quả về 0, hay còn gọi là 'unset' hoặc 'clear'.", en: "The AND operation with a mask that has a 0 at a certain position will force the corresponding bit in the result to be 0, which is called 'unsetting' or 'clearing'." } },
                    { q: { vi: "Một ứng dụng của XOR ở mức pattern là:", en: "An application of XOR at the pattern level is:" }, o: [{ vi: "set bit", en: "setting a bit" }, { vi: "unset bit", en: "unsetting a bit" }, { vi: "flip (complement) bit được chọn", en: "flipping (complementing) selected bits" }, { vi: "trả về số bit 1", en: "returning the number of 1s" }], a: 2, explanation: { vi: "Phép XOR với một mask có bit 1 tại một vị trí sẽ đảo (flip) bit tương ứng trong pattern (0 thành 1, 1 thành 0).", en: "The XOR operation with a mask that has a 1 at a certain position will invert (flip) the corresponding bit in the pattern (0 becomes 1, 1 becomes 0)." } },
                    { q: { vi: "Logical shift được áp dụng cho:", en: "Logical shift is applied to:" }, o: [{ vi: "mẫu không đại diện số dấu", en: "patterns not representing signed numbers" }, { vi: "số dấu (signed) bắt buộc", en: "signed numbers exclusively" }, { vi: "floating point only", en: "floating point only" }, { vi: "tất cả trên", en: "all of the above" }], a: 0, explanation: { vi: "Phép dịch logic xử lý chuỗi bit như một tập hợp các bit đơn thuần, không quan tâm đến bit dấu. Nó phù hợp cho số không dấu.", en: "Logical shift treats the bit string as a simple collection of bits, without regard for a sign bit. It is suitable for unsigned numbers." } },
                    { q: { vi: "Arithmetic shift giả định:", en: "Arithmetic shift assumes:" }, o: [{ vi: "pattern là unsigned integer", en: "the pattern is an unsigned integer" }, { vi: "pattern là signed integer (two’s complement)", en: "the pattern is a signed integer (two's complement)" }, { vi: "pattern là string", en: "the pattern is a string" }, { vi: "pattern là floating point", en: "the pattern is a floating point" }], a: 1, explanation: { vi: "Phép dịch số học được thiết kế đặc biệt để bảo toàn dấu của số bù hai khi thực hiện dịch phải.", en: "Arithmetic shift is specifically designed to preserve the sign of a two's complement number during a right shift." } },
                    { q: { vi: "Trong arithmetic right shift (two’s complement), khi shift phải, bit mới chèn vào trái là:", en: "In an arithmetic right shift (two's complement), when shifting right, the new bit inserted on the left is:" }, o: [{ vi: "0 luôn", en: "always 0" }, { vi: "bit dấu cũ (sign bit) — giữ dấu", en: "the old sign bit — preserving the sign" }, { vi: "bit ngẫu nhiên", en: "a random bit" }, { vi: "1 luôn", en: "always 1" }], a: 1, explanation: { vi: "Để giữ đúng giá trị của số âm (ví dụ, chia một số âm cho 2), bit dấu phải được sao chép vào vị trí trống bên trái.", en: "To maintain the correct value of a negative number (e.g., dividing a negative number by 2), the sign bit must be copied into the vacant leftmost position." } },
                    { q: { vi: "Overflow khi cộng hai số two's complement xảy ra khi:", en: "Overflow when adding two two's complement numbers occurs when:" }, o: [{ vi: "hai số cùng dấu và kết quả khác dấu", en: "two numbers of the same sign result in a different sign" }, { vi: "hai số khác dấu", en: "the two numbers have different signs" }, { vi: "luôn khi có carry out từ MSB", en: "always when there is a carry out from the MSB" }, { vi: "chỉ khi cả hai âm", en: "only when both are negative" }], a: 0, explanation: { vi: "Đây là quy tắc phát hiện tràn số: cộng hai số dương ra kết quả âm, hoặc cộng hai số âm ra kết quả dương.", en: "This is the rule for overflow detection: adding two positive numbers yields a negative result, or adding two negative numbers yields a positive result." } },
                    { q: { vi: "Giá trị biểu diễn lớn nhất của 8-bit two’s complement là:", en: "The largest representable value of an 8-bit two's complement is:" }, o: [{ vi: "255", en: "255" }, { vi: "127", en: "127" }, { vi: "−1", en: "-1" }, { vi: "128", en: "128" }], a: 1, explanation: { vi: "Phạm vi của số bù hai n-bit là từ -2ⁿ⁻¹ đến +2ⁿ⁻¹-1. Với n=8, giá trị lớn nhất là +2⁷-1 = 127.", en: "The range of an n-bit two's complement number is from -2ⁿ⁻¹ to +2ⁿ⁻¹-1. For n=8, the maximum value is +2⁷-1 = 127." } },
                    { q: { vi: "Giá trị nhỏ nhất (most negative) của 8-bit two’s complement là:", en: "The smallest (most negative) value of an 8-bit two's complement is:" }, o: [{ vi: "−128", en: "-128" }, { vi: "−127", en: "-127" }, { vi: "0", en: "0" }, { vi: "−256", en: "-256" }], a: 0, explanation: { vi: "Phạm vi của số bù hai n-bit là từ -2ⁿ⁻¹ đến +2ⁿ⁻¹-1. Với n=8, giá trị nhỏ nhất là -2⁷ = -128.", en: "The range of an n-bit two's complement number is from -2ⁿ⁻¹ to +2ⁿ⁻¹-1. For n=8, the minimum value is -2⁷ = -128." } },
                    { q: { vi: "Dịch trái logic một pattern thường tương đương với phép toán số nguyên:", en: "A logical left shift on a pattern is often equivalent to which integer operation?" }, o: [{ vi: "chia cho 2", en: "division by 2" }, { vi: "nhân ×2 (nếu không overflow)", en: "multiplication by 2 (if no overflow)" }, { vi: "XOR với 2", en: "XOR with 2" }, { vi: "cộng 1", en: "adding 1" }], a: 1, explanation: { vi: "Mỗi lần dịch trái một vị trí sẽ nhân giá trị của số (không dấu) lên 2, miễn là bit quan trọng nhất không bị mất.", en: "Each left shift by one position multiplies the value of the (unsigned) number by 2, as long as the most significant bit is not lost." } },
                    { q: { vi: "Trong floating-point addition, bước quan trọng để thực hiện phép cộng là:", en: "In floating-point addition, what is the crucial step to perform the addition?" }, o: [{ vi: "đổi sang two’s complement trước", en: "converting to two's complement first" }, { vi: "align (căn) các exponent trước khi cộng mantissa", en: "aligning the exponents before adding the mantissas" }, { vi: "dùng XOR để cộng mantissa", en: "using XOR to add the mantissas" }, { vi: "swap bits", en: "swapping bits" }], a: 1, explanation: { vi: "Không thể cộng trực tiếp các phần định trị (mantissa) trừ khi các số mũ (exponent) của chúng bằng nhau. Do đó, cần phải dịch chuyển một trong các mantissa để làm cho các số mũ khớp nhau.", en: "The mantissas cannot be added directly unless their exponents are equal. Therefore, one of the mantissas must be shifted to make the exponents match." } },
                    { q: { vi: "Phép toán để kiểm tra “bit i có 1 hay không” thường là:", en: "The operation to check 'if bit i is 1' is usually:" }, o: [{ vi: "shift phải i lần rồi AND với 1", en: "shift right i times then AND with 1" }, { vi: "shift trái i lần rồi AND với 1", en: "shift left i times then AND with 1" }, { vi: "OR với 1 rồi so sánh", en: "OR with 1 and then compare" }, { vi: "XOR với 1 rồi so sánh", en: "XOR with 1 and then compare" }], a: 0, explanation: { vi: "Đây là một kỹ thuật phổ biến: dịch chuyển bit cần kiểm tra đến vị trí cuối cùng (LSB), sau đó dùng mask '1' để cô lập nó. Nếu kết quả khác không, bit đó là 1.", en: "This is a common technique: shift the bit to be tested to the last position (LSB), then use a mask of '1' to isolate it. If the result is non-zero, the bit was 1." } }
                ]
            },
            chapter5: {
                 theory: {
                    vi: `
                        <h2>Chương 5: Tổ chức Máy tính</h2>
                        <h3>1. Các thành phần chính</h3>
                        <ul>
                            <li><strong>CPU (Central Processing Unit):</strong> "Bộ não" của máy tính. Gồm 3 phần: ALU (tính toán), Control Unit (điều khiển), và Registers (thanh ghi).</li>
                            <li><strong>Bộ nhớ chính (Main Memory):</strong> Thường là RAM, lưu trữ chương trình và dữ liệu đang chạy.</li>
                        </ul>
                        <h3>2. Phân cấp bộ nhớ (Memory Hierarchy)</h3>
                        <p>Tốc độ và giá thành giảm dần, dung lượng tăng dần:</p>
                        <p><span class="highlight">Registers → Cache → Main Memory → Storage (Ổ cứng)</span></p>
                        <h3>3. Chu kỳ máy (Machine Cycle)</h3>
                        <ul>
                             <li>Quá trình CPU thực thi một lệnh. Gồm 3 bước cơ bản:
                                <ol>
                                    <li><span class="highlight">Fetch (Nạp lệnh):</span> Lấy lệnh từ bộ nhớ.</li>
                                    <li><span class="highlight">Decode (Giải mã):</span> Hiểu xem lệnh yêu cầu làm gì.</li>
                                    <li><span class="highlight">Execute (Thực thi):</span> Thực hiện lệnh đó.</li>
                                </ol>
                            </li>
                        </ul>
                    `,
                    en: `
                        <h2>Chapter 5: Computer Organization</h2>
                        <h3>1. Main Components</h3>
                        <ul>
                           <li><strong>CPU (Central Processing Unit):</strong> The "brain" of the computer. Contains 3 parts: ALU (calculation), Control Unit (control), and Registers.</li>
                            <li><strong>Main Memory:</strong> Usually RAM, stores currently running programs and data.</li>
                        </ul>
                        <h3>2. Memory Hierarchy</h3>
                        <p>Speed and cost decrease, while capacity increases:</p>
                        <p><span class="highlight">Registers → Cache → Main Memory → Storage (Hard Drive)</span></p>
                        <h3>3. Machine Cycle</h3>
                        <ul>
                             <li>The repetitive process by which the CPU executes one instruction. Consists of 3 basic steps:
                                <ol>
                                    <li><span class="highlight">Fetch:</span> Get the instruction from memory.</li>
                                    <li><span class="highlight">Decode:</span> Understand what the instruction wants to do.</li>
                                    <li><span class="highlight">Execute:</span> Perform the instruction.</li>
                                </ol>
                            </li>
                        </ul>
                    `
                },
                questions: [
                    { q: { vi: "Máy tính gồm mấy hệ thống con chính?", en: "How many main subsystems does a computer consist of?" }, o: [{ vi: "2 — CPU và Memory", en: "2 — CPU and Memory" }, { vi: "3 — CPU, Main memory, I/O subsystem", en: "3 — CPU, Main memory, I/O subsystem" }, { vi: "4 — CPU, Memory, I/O, GPU", en: "4 — CPU, Memory, I/O, GPU" }, { vi: "5 — CPU, Memory, I/O, Cache, Bus", en: "5 — CPU, Memory, I/O, Cache, Bus" }], a: 1, explanation: { vi: "Theo mô hình đơn giản hóa, máy tính có 3 thành phần chính: CPU để xử lý, Main Memory để lưu trữ tạm thời, và I/O Subsystem để giao tiếp.", en: "According to the simplified model, a computer has 3 main components: the CPU for processing, Main Memory for temporary storage, and the I/O Subsystem for communication." } },
                    { q: { vi: "CPU thường gồm những thành phần nào?", en: "What components does a CPU typically consist of?" }, o: [{ vi: "ALU, Control unit, Registers", en: "ALU, Control unit, Registers" }, { vi: "ALU, Hard drive, Network card", en: "ALU, Hard drive, Network card" }, { vi: "Cache, Disk controller, Monitor", en: "Cache, Disk controller, Monitor" }, { vi: "Keyboard, Mouse, Printer", en: "Keyboard, Mouse, Printer" }], a: 0, explanation: { vi: "CPU có ba khối chức năng cốt lõi: ALU (tính toán), Control Unit (điều khiển), và Registers (lưu trữ siêu nhanh).", en: "The CPU has three core functional blocks: the ALU (arithmetic/logic), the Control Unit (coordination), and Registers (super-fast storage)." } },
                    { q: { vi: "Chức năng chính của Program Counter (PC) là gì?", en: "What is the main function of the Program Counter (PC)?" }, o: [{ vi: "Lưu dữ liệu tạm thời", en: "To store temporary data" }, { vi: "Giữ địa chỉ lệnh tiếp theo cần thực thi", en: "To hold the address of the next instruction to be executed" }, { vi: "Thực hiện phép toán số học", en: "To perform arithmetic operations" }, { vi: "Điều khiển tốc độ bus", en: "To control the bus speed" }], a: 1, explanation: { vi: "PC luôn trỏ đến lệnh tiếp theo trong bộ nhớ, cho phép CPU thực thi chương trình một cách tuần tự.", en: "The PC always points to the next instruction in memory, allowing the CPU to execute a program sequentially." } },
                    { q: { vi: "Instruction Register (IR) dùng để làm gì?", en: "What is the Instruction Register (IR) used for?" }, o: [{ vi: "Lưu toàn bộ chương trình", en: "To store the entire program" }, { vi: "Lưu lệnh hiện đang được thực thi (mã lệnh)", en: "To store the instruction currently being executed (opcode)" }, { vi: "Tăng/giảm giá trị của thanh ghi", en: "To increment/decrement the value of a register" }, { vi: "Kết nối I/O với bộ nhớ", en: "To connect I/O with memory" }], a: 1, explanation: { vi: "Sau khi lệnh được nạp (fetch) từ bộ nhớ, nó được đặt vào IR để Control Unit có thể giải mã và thực thi.", en: "After an instruction is fetched from memory, it is placed in the IR so the Control Unit can decode and execute it." } },
                    { q: { vi: "ALU không thực hiện tác vụ nào dưới đây?", en: "Which of the following tasks is NOT performed by the ALU?" }, o: [{ vi: "Toán học (cộng, trừ)", en: "Arithmetic (add, subtract)" }, { vi: "Phép logic (AND, OR, NOT)", en: "Logic operations (AND, OR, NOT)" }, { vi: "Ghi/đọc đĩa cứng (disk I/O)", en: "Reading/writing to the hard disk (disk I/O)" }, { vi: "Dịch bit (shift, rotate)", en: "Bit shifting (shift, rotate)" }], a: 2, explanation: { vi: "ALU là đơn vị tính toán và logic. Việc giao tiếp với thiết bị lưu trữ như đĩa cứng là nhiệm vụ của I/O subsystem và controllers.", en: "The ALU is the arithmetic and logic unit. Communicating with storage devices like hard disks is the job of the I/O subsystem and controllers." } },
                    { q: { vi: "Data bus có nhiệm vụ gì chính?", en: "What is the main task of the data bus?" }, o: [{ vi: "Mang địa chỉ bộ nhớ", en: "To carry memory addresses" }, { vi: "Mang dữ liệu giữa CPU và bộ nhớ", en: "To carry data between the CPU and memory" }, { vi: "Mang tín hiệu điều khiển (read/write)", en: "To carry control signals (read/write)" }, { vi: "Mang tín hiệu đồng hồ (clock)", en: "To carry clock signals" }], a: 1, explanation: { vi: "Đúng như tên gọi, data bus là con đường để di chuyển dữ liệu thực tế (các bit của chương trình hoặc dữ liệu) qua lại.", en: "As its name implies, the data bus is the pathway for moving the actual data (the bits of a program or data) back and forth." } },
                    { q: { vi: "Nếu bộ nhớ có 2^n words thì address bus cần bao nhiêu dây?", en: "If a memory has 2^n words, how many wires does the address bus need?" }, o: [{ vi: "n/2 dây", en: "n/2 wires" }, { vi: "2^n dây", en: "2^n wires" }, { vi: "n dây", en: "n wires" }, { vi: "1 dây", en: "1 wire" }], a: 2, explanation: { vi: "Để có thể định danh duy nhất 2^n vị trí khác nhau, bạn cần n bit địa chỉ. Mỗi bit cần một dây dẫn.", en: "To uniquely identify 2^n different locations, you need n bits of address. Each bit requires one wire." } },
                    { q: { vi: "Trong hệ thống phân cấp bộ nhớ, thành phần nào nhanh nhất nhưng đắt nhất?", en: "In the memory hierarchy, which component is the fastest but also the most expensive?" }, o: [{ vi: "Main memory", en: "Main memory" }, { vi: "Cache", en: "Cache" }, { vi: "Registers (thanh ghi)", en: "Registers" }, { vi: "Disk", en: "Disk" }], a: 2, explanation: { vi: "Thanh ghi (registers) nằm ngay bên trong lõi CPU, được làm từ công nghệ nhanh nhất (và đắt nhất), do đó có tốc độ truy cập gần như tức thời.", en: "Registers are located right inside the CPU core, made from the fastest (and most expensive) technology, giving them near-instant access speeds." } },
                    { q: { vi: "Điểm khác nhau cơ bản giữa RAM và ROM là gì?", en: "What is the fundamental difference between RAM and ROM?" }, o: [{ vi: "RAM chỉ đọc, ROM đọc/ghi", en: "RAM is read-only, ROM is read/write" }, { vi: "RAM volatile (mất khi tắt), ROM non-volatile", en: "RAM is volatile (lost on power-off), ROM is non-volatile" }, { vi: "RAM là thiết bị lưu trữ lâu dài, ROM là bộ nhớ tạm thời", en: "RAM is long-term storage, ROM is temporary memory" }, { vi: "RAM chỉ dùng cho I/O, ROM chỉ dùng cho CPU", en: "RAM is only for I/O, ROM is only for the CPU" }], a: 1, explanation: { vi: "Volatile (khả biến) là đặc tính quan trọng nhất. Dữ liệu trong RAM biến mất khi mất điện, trong khi dữ liệu trong ROM (như firmware BIOS) vẫn còn.", en: "Volatility is the most important characteristic. Data in RAM vanishes when power is lost, while data in ROM (like BIOS firmware) persists." } },
                    { q: { vi: "SRAM khác DRAM ở chỗ nào?", en: "How does SRAM differ from DRAM?" }, o: [{ vi: "SRAM dùng tụ điện, DRAM dùng flip-flop", en: "SRAM uses capacitors, DRAM uses flip-flops" }, { vi: "SRAM cần refresh định kỳ, DRAM không cần", en: "SRAM needs periodic refreshing, DRAM does not" }, { vi: "SRAM dùng flip-flop (không cần refresh) và nhanh hơn; DRAM dùng capacitor (cần refresh) và rẻ hơn", en: "SRAM uses flip-flops (no refresh needed) and is faster; DRAM uses capacitors (needs refresh) and is cheaper" }, { vi: "SRAM là lưu trữ ngoài, DRAM là trong CPU", en: "SRAM is external storage, DRAM is in the CPU" }], a: 2, explanation: { vi: "SRAM (Static RAM) dùng mạch flip-flop để giữ bit, nhanh nhưng tốn diện tích và đắt. DRAM (Dynamic RAM) dùng tụ điện, cần được làm tươi (refresh) liên tục, chậm hơn nhưng rẻ và có mật độ cao hơn.", en: "SRAM (Static RAM) uses flip-flop circuits to hold a bit, which is fast but bulky and expensive. DRAM (Dynamic RAM) uses a capacitor, needs constant refreshing, is slower, but is cheaper and denser." } },
                    { q: { vi: "Một máy có bộ nhớ 32 MB (byte-addressable). Cần bao nhiêu bit để địa chỉ từng byte?", en: "A machine has 32 MB of byte-addressable memory. How many bits are needed to address each byte?" }, o: [{ vi: "20 bit", en: "20 bits" }, { vi: "24 bit", en: "24 bits" }, { vi: "25 bit", en: "25 bits" }, { vi: "32 bit", en: "32 bits" }], a: 2, explanation: { vi: "32 MB = 32 * 2^20 bytes = 2^5 * 2^20 bytes = 2^25 bytes. Do đó, cần 25 bit để địa chỉ 2^25 byte khác nhau.", en: "32 MB = 32 * 2^20 bytes = 2^5 * 2^20 bytes = 2^25 bytes. Therefore, 25 bits are needed to address 2^25 different bytes." } },
                    { q: { vi: "Cache thường đặt ở đâu trong hệ thống bộ nhớ?", en: "Where is the cache typically placed in the memory system?" }, o: [{ vi: "Sau ổ cứng", en: "After the hard disk" }, { vi: "Giữa CPU và main memory", en: "Between the CPU and main memory" }, { vi: "Trước keyboard", en: "Before the keyboard" }, { vi: "Bên ngoài hệ thống I/O", en: "Outside the I/O system" }], a: 1, explanation: { vi: "Cache đóng vai trò là bộ đệm tốc độ cao giữa CPU cực nhanh và main memory (RAM) chậm hơn đáng kể.", en: "The cache acts as a high-speed buffer between the extremely fast CPU and the significantly slower main memory (RAM)." } },
                    { q: { vi: "Khi CPU cần truy xuất một từ ở main memory, trình tự đúng là:", en: "When the CPU needs to access a word in main memory, the correct sequence is:" }, o: [{ vi: "Truy cập main memory trực tiếp", en: "Access main memory directly" }, { vi: "Kiểm tra cache; nếu có thì lấy, nếu không thì đọc block từ main memory vào cache rồi lấy", en: "Check the cache; if present (hit), get it. If not (miss), read a block from main memory into the cache, then get it." }, { vi: "Gửi lệnh cho I/O controller", en: "Send a command to the I/O controller" }, { vi: "Dừng CPU và chờ interrupt", en: "Halt the CPU and wait for an interrupt" }], a: 1, explanation: { vi: "Đây là nguyên tắc hoạt động cơ bản của cache. Luôn kiểm tra cache trước. Nếu 'cache miss', mới phải truy cập main memory chậm hơn.", en: "This is the fundamental principle of cache operation. Always check the cache first. A 'cache miss' necessitates an access to the slower main memory." } },
                    { q: { vi: "So sánh tốc độ: registers, cache, main memory, disk — thứ tự nào đúng từ nhanh nhất đến chậm nhất?", en: "Compare the speeds: registers, cache, main memory, disk — which order is correct from fastest to slowest?" }, o: [{ vi: "Disk → Main memory → Cache → Registers", en: "Disk → Main memory → Cache → Registers" }, { vi: "Registers → Cache → Main memory → Disk", en: "Registers → Cache → Main memory → Disk" }, { vi: "Cache → Registers → Disk → Main memory", en: "Cache → Registers → Disk → Main memory" }, { vi: "Main memory → Cache → Registers → Disk", en: "Main memory → Cache → Registers → Disk" }], a: 1, explanation: { vi: "Đây là hệ thống phân cấp bộ nhớ. Tốc độ giảm dần và dung lượng tăng dần khi di chuyển ra xa CPU: Registers (trong CPU) > Cache (gần CPU) > Main Memory (RAM) > Disk (lưu trữ).", en: "This is the memory hierarchy. Speed decreases and capacity increases as you move away from the CPU: Registers (in CPU) > Cache (near CPU) > Main Memory (RAM) > Disk (storage)." } },
                    { q: { vi: "Thiết bị nào sau đây là non-storage I/O device?", en: "Which of the following is a non-storage I/O device?" }, o: [{ vi: "Hard disk", en: "Hard disk" }, { vi: "CD-ROM", en: "CD-ROM" }, { vi: "Keyboard", en: "Keyboard" }, { vi: "Magnetic tape", en: "Magnetic tape" }], a: 2, explanation: { vi: "Thiết bị lưu trữ (storage) có thể giữ lại dữ liệu. Bàn phím (keyboard) chỉ truyền dữ liệu vào tại một thời điểm, nó không lưu trữ dữ liệu.", en: "A storage device can retain data. A keyboard only transmits data at a moment in time; it does not store it." } },
                    { q: { vi: "Magnetic tape có kiểu truy cập nào?", en: "What type of access does a magnetic tape have?" }, o: [{ vi: "Random access", en: "Random access" }, { vi: "Memory-mapped access", en: "Memory-mapped access" }, { vi: "Sequential access", en: "Sequential access" }, { vi: "Parallel access", en: "Parallel access" }], a: 2, explanation: { vi: "Giống như băng cassette, để đọc dữ liệu ở giữa, bạn phải tua qua tất cả dữ liệu ở phía trước. Đây là truy cập tuần tự (sequential).", en: "Like a cassette tape, to read data in the middle, you must wind through all the data before it. This is sequential access." } },
                    { q: { vi: "FireWire (IEEE 1394) có thể kết nối tối đa bao nhiêu thiết bị theo tài liệu?", en: "According to the documentation, FireWire (IEEE 1394) can connect a maximum of how many devices?" }, o: [{ vi: "16", en: "16" }, { vi: "32", en: "32" }, { vi: "63", en: "63" }, { vi: "127", en: "127" }], a: 2, explanation: { vi: "FireWire cho phép kết nối chuỗi (daisy-chaining) lên đến 63 thiết bị.", en: "FireWire allows for the daisy-chaining of up to 63 devices." } },
                    { q: { vi: "Trong số: SCSI, USB, FireWire — cái nào là giao diện song song (parallel) theo tài liệu?", en: "Among SCSI, USB, and FireWire — which is a parallel interface according to the text?" }, o: [{ vi: "USB", en: "USB" }, { vi: "FireWire", en: "FireWire" }, { vi: "SCSI", en: "SCSI" }, { vi: "HDMI", en: "HDMI" }], a: 2, explanation: { vi: "SCSI (Small Computer System Interface) truyền thống là một giao diện song song, truyền nhiều bit cùng một lúc. USB và FireWire là giao diện nối tiếp (serial).", en: "Traditional SCSI (Small Computer System Interface) is a parallel interface, transferring multiple bits at once. USB and FireWire are serial interfaces." } },
                    { q: { vi: "Phương pháp isolated I/O có đặc điểm gì?", en: "What is a characteristic of the isolated I/O method?" }, o: [{ vi: "I/O dùng cùng lệnh với truy xuất memory", en: "I/O uses the same instructions as memory access" }, { vi: "Có tập lệnh riêng cho I/O (input/output) tách biệt với lệnh memory", en: "It has a separate set of I/O instructions (input/output) distinct from memory instructions" }, { vi: "I/O không có địa chỉ", en: "I/O has no address" }, { vi: "Là cách mà ROM được truy xuất", en: "It is the way ROM is accessed" }], a: 1, explanation: { vi: "Trong isolated I/O, CPU có các lệnh đặc biệt (như IN, OUT) chỉ dành cho việc giao tiếp với các thiết bị I/O, tách biệt hoàn toàn với các lệnh đọc/ghi bộ nhớ.", en: "In isolated I/O, the CPU has special instructions (like IN, OUT) used only for communicating with I/O devices, completely separate from memory read/write instructions." } },
                    { q: { vi: "Phương pháp memory-mapped I/O là gì?", en: "What is the memory-mapped I/O method?" }, o: [{ vi: "Mỗi thanh ghi của controller được ánh xạ như một ô nhớ → dùng cùng lệnh đọc/ghi như memory", en: "Each controller register is mapped as a memory location → uses the same read/write instructions as memory" }, { vi: "I/O không bao giờ dùng bus hệ thống", en: "I/O never uses the system bus" }, { vi: "I/O luôn dùng interrupt-driven I/O", en: "I/O always uses interrupt-driven I/O" }, { vi: "Là một loại disk format", en: "It is a type of disk format" }], a: 0, explanation: { vi: "Với memory-mapped I/O, CPU không phân biệt giữa một ô nhớ và một thanh ghi của thiết bị. Nó dùng cùng các lệnh (ví dụ: LOAD, STORE) cho cả hai.", en: "With memory-mapped I/O, the CPU does not distinguish between a memory cell and a device's register. It uses the same instructions (e.g., LOAD, STORE) for both." } },
                    { q: { vi: "Máy thực hiện một chu kỳ (machine cycle) gồm những pha cơ bản nào?", en: "A machine performs a cycle (machine cycle) consisting of which basic phases?" }, o: [{ vi: "Read → Write → Store", en: "Read → Write → Store" }, { vi: "Fetch → Decode → Execute", en: "Fetch → Decode → Execute" }, { vi: "Input → Output → Transfer", en: "Input → Output → Transfer" }, { vi: "Start → Stop → Reset", en: "Start → Stop → Reset" }], a: 1, explanation: { vi: "Đây là 3 bước lặp đi lặp lại cốt lõi của CPU: Lấy lệnh từ bộ nhớ (Fetch), hiểu lệnh đó là gì (Decode), và thực hiện hành động được yêu cầu (Execute).", en: "These are the 3 core repetitive steps of the CPU: Get an instruction from memory (Fetch), understand what it is (Decode), and perform the requested action (Execute)." } },
                    { q: { vi: "Trong programmed I/O, CPU làm gì khi gặp lệnh I/O?", en: "In programmed I/O, what does the CPU do when it encounters an I/O instruction?" }, o: [{ vi: "Gửi interrupt và làm việc khác", en: "Sends an interrupt and does other work" }, { vi: "Đợi/poll liên tục trạng thái thiết bị → CPU bị chặn (busy-wait)", en: "Waits/polls the device status continuously → the CPU is blocked (busy-wait)" }, { vi: "Dùng DMA ngay lập tức", en: "Uses DMA immediately" }, { vi: "Tự động bỏ qua lệnh I/O", en: "Automatically skips the I/O instruction" }], a: 1, explanation: { vi: "Programmed I/O là phương pháp đơn giản nhất nhưng kém hiệu quả nhất. CPU bị kẹt trong một vòng lặp, liên tục hỏi 'Xong chưa?', không thể làm việc khác.", en: "Programmed I/O is the simplest but least efficient method. The CPU gets stuck in a loop, constantly asking 'Are you done yet?', unable to do other work." } },
                    { q: { vi: "Trong interrupt-driven I/O, điều gì xảy ra?", en: "In interrupt-driven I/O, what happens?" }, o: [{ vi: "Thiết bị gửi interrupt khi sẵn sàng, CPU có thể làm việc khác trong lúc chờ", en: "The device sends an interrupt when ready, the CPU can do other work while waiting" }, { vi: "CPU phải poll thường xuyên thiết bị", en: "The CPU must poll the device frequently" }, { vi: "Không có giao tiếp DMA", en: "There is no DMA communication" }, { vi: "CPU dừng hoàn toàn cho đến khi xong I/O", en: "The CPU halts completely until I/O is finished" }], a: 0, explanation: { vi: "Đây là một cải tiến lớn. CPU ra lệnh cho thiết bị và đi làm việc khác. Khi thiết bị hoàn thành, nó sẽ 'ngắt' (interrupt) CPU để báo hiệu.", en: "This is a major improvement. The CPU commands the device and goes off to do other work. When the device is finished, it 'interrupts' the CPU to signal completion." } },
                    { q: { vi: "Direct Memory Access (DMA) có tác dụng gì?", en: "What is the purpose of Direct Memory Access (DMA)?" }, o: [{ vi: "Chuyển khối dữ liệu lớn trực tiếp giữa I/O và memory mà không qua CPU (hoặc chỉ qua mức tối thiểu)", en: "To transfer large blocks of data directly between I/O and memory without CPU intervention (or with minimal intervention)" }, { vi: "Thay thế cache hoàn toàn", en: "To completely replace the cache" }, { vi: "Là một loại controller cho keyboard", en: "It is a type of controller for the keyboard" }, { vi: "Chỉ dùng cho CD-ROM", en: "It is only used for CD-ROMs" }], a: 0, explanation: { vi: "DMA giải phóng CPU khỏi công việc truyền dữ liệu tẻ nhạt. CPU chỉ cần khởi tạo việc truyền, và bộ điều khiển DMA sẽ tự xử lý, cho phép CPU làm những việc hữu ích hơn.", en: "DMA frees the CPU from the tedious job of data transfer. The CPU only needs to initiate the transfer, and the DMA controller handles it, allowing the CPU to do more useful work." } },
                    { q: { vi: "Đặc trưng chính của CISC là gì?", en: "What is the main characteristic of CISC?" }, o: [{ vi: "Tập lệnh nhỏ, đơn giản, thực thi nhanh từng lệnh", en: "A small, simple instruction set, with fast execution for each instruction" }, { vi: "Tập lệnh phức tạp, nhiều chức năng — dùng microprogramming để phân giải thành micro-operations", en: "A complex instruction set with many functions — using microprogramming to resolve into micro-operations" }, { vi: "Không có ALU", en: "No ALU" }, { vi: "Chỉ dùng cho supercomputers", en: "Only used for supercomputers" }], a: 1, explanation: { vi: "CISC (Complex Instruction Set Computer) có các lệnh mạnh mẽ, có thể thực hiện các tác vụ phức tạp trong một lệnh duy nhất. Bên trong, các lệnh này được chia thành các bước nhỏ hơn gọi là micro-operations.", en: "CISC (Complex Instruction Set Computer) has powerful instructions that can perform complex tasks in a single command. Internally, these are broken down into smaller steps called micro-operations." } },
                    { q: { vi: "RISC tập trung vào:", en: "RISC focuses on:" }, o: [{ vi: "Tập lệnh lớn phức tạp", en: "A large, complex instruction set" }, { vi: "Tập lệnh giảm thiểu, mỗi lệnh đơn giản và nhanh", en: "A reduced instruction set, where each instruction is simple and fast" }, { vi: "Loại bỏ cache", en: "Eliminating the cache" }, { vi: "Dùng micromemory cho mỗi lệnh", en: "Using micromemory for each instruction" }], a: 1, explanation: { vi: "RISC (Reduced Instruction Set Computer) có triết lý ngược lại với CISC. Nó sử dụng một tập lệnh nhỏ gồm các lệnh rất đơn giản, mỗi lệnh có thể được thực thi rất nhanh (thường trong một chu kỳ xung nhịp).", en: "RISC (Reduced Instruction Set Computer) has the opposite philosophy of CISC. It uses a small set of very simple instructions, each of which can be executed very quickly (often in a single clock cycle)." } },
                    { q: { vi: "Mục đích của pipelining là:", en: "The purpose of pipelining is:" }, o: [{ vi: "Giảm kích thước RAM", en: "To reduce RAM size" }, { vi: "Tăng throughput bằng cách chồng lấp các pha fetch/decode/execute của nhiều lệnh khác nhau", en: "To increase throughput by overlapping the fetch/decode/execute phases of different instructions" }, { vi: "Thay thế ALU bằng nhiều ALU nhỏ", en: "To replace the ALU with many smaller ALUs" }, { vi: "Làm cho CPU chạy chậm hơn để tiết kiệm điện", en: "To make the CPU run slower to save power" }], a: 1, explanation: { vi: "Pipelining giống như một dây chuyền lắp ráp. Trong khi một lệnh đang được thực thi, lệnh tiếp theo đang được giải mã, và lệnh sau đó nữa đang được nạp. Điều này làm tăng đáng kể số lượng lệnh được hoàn thành trong một đơn vị thời gian (throughput).", en: "Pipelining is like an assembly line. While one instruction is being executed, the next one is being decoded, and the one after that is being fetched. This greatly increases the number of instructions completed per unit of time (throughput)." } },
                    { q: { vi: "Theo Flynn, dạng nào là Single Instruction-stream, Multiple Data-stream?", en: "According to Flynn, which category is Single Instruction-stream, Multiple Data-stream?" }, o: [{ vi: "SISD", en: "SISD" }, { vi: "SIMD", en: "SIMD" }, { vi: "MISD", en: "MISD" }, { vi: "MIMD", en: "MIMD" }], a: 1, explanation: { vi: "SIMD (Single Instruction, Multiple Data) thực hiện cùng một lệnh trên nhiều phần dữ liệu khác nhau cùng một lúc. Điều này rất phổ biến trong xử lý đồ họa và khoa học.", en: "SIMD (Single Instruction, Multiple Data) performs the same instruction on multiple different pieces of data simultaneously. This is very common in graphics and scientific processing." } },
                    { q: { vi: "Định dạng lệnh của máy đơn giản trong chương có độ dài bao nhiêu bit?", en: "What is the instruction format length of the simple computer in the chapter?" }, o: [{ vi: "8 bit", en: "8 bits" }, { vi: "12 bit", en: "12 bits" }, { vi: "16 bit (chia làm 4 trường, mỗi trường 4 bit)", en: "16 bits (divided into 4 fields, each 4 bits)" }, { vi: "32 bit", en: "32 bits" }], a: 2, explanation: { vi: "Máy tính giả định trong sách sử dụng các lệnh 16-bit, được chia thành một opcode 4-bit và ba toán hạng 4-bit.", en: "The hypothetical computer in the book uses 16-bit instructions, divided into a 4-bit opcode and three 4-bit operands." } },
                    { q: { vi: "Trong bảng mã lệnh mẫu, opcode của LOAD là số nào?", en: "In the sample instruction table, what is the opcode for LOAD?" }, o: [{ vi: "0", en: "0" }, { vi: "1", en: "1" }, { vi: "2", en: "2" }, { vi: "3", en: "3" }], a: 1, explanation: { vi: "Theo bảng mã lệnh được cung cấp trong chương, lệnh LOAD được gán mã opcode là 1.", en: "According to the instruction set table provided in the chapter, the LOAD instruction is assigned opcode 1." } },
                    { q: { vi: "Opcode của HALT trong máy đơn giản là gì?", en: "What is the opcode for HALT in the simple computer?" }, o: [{ vi: "0", en: "0" }, { vi: "1", en: "1" }, { vi: "F", en: "F" }, { vi: "8", en: "8" }], a: 0, explanation: { vi: "Lệnh HALT (dừng máy) được gán mã opcode là 0.", en: "The HALT instruction (stop the machine) is assigned opcode 0." } }
                ]
            }
        };
        // --- END: NGÂN HÀNG CÂU HỎI VÀ LÝ THUYẾT ---

        // --- START: JAVASCRIPT LOGIC (HOÀN CHỈNH) ---
        let currentLang = 'vi';
        let currentChapter = 'chapter1';
        let quizState = {};

        document.addEventListener('DOMContentLoaded', () => {
            renderAllContent();
        });

        function renderAllContent() {
            const tabContent = document.querySelector('.tab-content');
            tabContent.innerHTML = '';
            let isFirstChapter = true;
            for (const chapterId in contentData) {
                const chapterDiv = document.createElement('div');
                chapterDiv.id = chapterId;
                chapterDiv.className = isFirstChapter ? 'tab-pane active' : 'tab-pane';
                isFirstChapter = false;

                chapterDiv.innerHTML = `
                    <div class="theory-view">
                        <div class="theory-content"></div>
                        <div class="button-group">
                            <button class="primary-button" onclick="showQuizSetup('${chapterId}')" data-lang-key="startQuiz"></button>
                            <button class="info-button" onclick="askAI()" data-lang-key="askAI"></button>
                        </div>
                    </div>
                    <div class="quiz-view">
                        <div class="quiz-setup">
                            <h3 data-lang-key="quizSetupTitle"></h3>
                            <div>
                                <label data-lang-key="numQuestions"></label>
                                <input type="number" id="num-questions-${chapterId}" value="10" min="1" max="${contentData[chapterId].questions.length}">
                            </div>
                            <div>
                                <button class="primary-button" onclick="startQuiz('${chapterId}')" data-lang-key="start"></button>
                                <button class="secondary-button" onclick="showTheory('${chapterId}')" data-lang-key="backToTheory"></button>
                            </div>
                        </div>
                        <div class="quiz-container" style="display:none;">
                            <div id="question-text-${chapterId}" class="quiz-question"></div>
                            <div id="quiz-options-${chapterId}" class="quiz-options"></div>
                            <div id="explanation-${chapterId}"></div>
                            <div class="button-group">
                                <button onclick="nextQuestion('${chapterId}')" id="next-btn-${chapterId}" class="primary-button" data-lang-key="nextQuestion" style="display:none;"></button>
                            </div>
                        </div>
                        <div class="quiz-results" style="display:none;">
                            <h3 data-lang-key="resultsTitle"></h3>
                            <p id="score-${chapterId}"></p>
                            <button class="secondary-button" onclick="showTheory('${chapterId}')" data-lang-key="backToTheory"></button>
                            <button class="primary-button" onclick="showQuizSetup('${chapterId}')" data-lang-key="retakeQuiz"></button>
                        </div>
                    </div>
                `;
                tabContent.appendChild(chapterDiv);
            }
            updateAllVisibleText();
        }

        function switchTab(chapterId) {
            currentChapter = chapterId;
            document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
            document.getElementById(chapterId).classList.add('active');
            
            document.querySelectorAll('.tab-link').forEach(l => l.classList.remove('active'));
            document.querySelector(`.tab-link[onclick="switchTab('${chapterId}')"]`).classList.add('active');
        }

        function switchLanguage(lang) {
            if (currentLang === lang) return;
            currentLang = lang;
            document.querySelectorAll('.lang-switcher button').forEach(b => b.classList.remove('active'));
            document.querySelector(`.lang-switcher button[onclick="switchLanguage('${lang}')"]`).classList.add('active');
            updateAllVisibleText();
        }
        
        const translations = {
            vi: {
                title: "CSI FPTU - Công cụ Ôn tập Nâng cao",
                subtitle: "Chọn chương để học lý thuyết hoặc làm bài tập trắc nghiệm.",
                vietnamese: "Tiếng Việt", english: "English",
                ch1: "Chương 1", ch2: "Chương 2", ch3: "Chương 3", ch4: "Chương 4", ch5: "Chương 5",
                startQuiz: "Làm bài tập", quizSetupTitle: "Thiết lập bài trắc nghiệm",
                numQuestions: "Số lượng câu hỏi:", start: "Bắt đầu",
                backToTheory: "Quay lại Lý thuyết", nextQuestion: "Câu tiếp theo",
                resultsTitle: "Kết quả", scoreText: "Bạn đã trả lời đúng",
                retakeQuiz: "Làm lại bài", askAI: "Hỏi AI"
            },
            en: {
                title: "CSI FPTU - Advanced Study Tool",
                subtitle: "Select a chapter to study theory or take a multiple-choice quiz.",
                vietnamese: "Vietnamese", english: "English",
                ch1: "Chapter 1", ch2: "Chapter 2", ch3: "Chapter 3", ch4: "Chapter 4", ch5: "Chapter 5",
                startQuiz: "Start Quiz", quizSetupTitle: "Quiz Setup",
                numQuestions: "Number of questions:", start: "Start",
                backToTheory: "Back to Theory", nextQuestion: "Next Question",
                resultsTitle: "Results", scoreText: "You answered correctly",
                retakeQuiz: "Retake Quiz", askAI: "Ask AI"
            }
        };

        function updateAllVisibleText() {
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.getAttribute('data-lang-key');
                if (translations[currentLang][key]) {
                    el.textContent = translations[currentLang][key];
                }
            });

            for (const chapterId in contentData) {
                const theoryDiv = document.querySelector(`#${chapterId} .theory-content`);
                if (theoryDiv) {
                    theoryDiv.innerHTML = contentData[chapterId].theory[currentLang];
                }
            }

            if (quizState[currentChapter] && quizState[currentChapter].isActive) {
                redisplayCurrentQuestion();
            }
        }

        function redisplayCurrentQuestion() {
            const state = quizState[currentChapter];
            if (!state || !state.isActive || state.currentQuestionIndex >= state.questions.length) return;

            const question = state.questions[state.currentQuestionIndex];
            document.getElementById(`question-text-${currentChapter}`).textContent = `(${state.currentQuestionIndex + 1}/${state.questions.length}) ${question.q[currentLang]}`;
            
            const options = document.querySelectorAll(`#quiz-options-${currentChapter} button`);
            options.forEach((button, index) => {
                button.textContent = question.o[index][currentLang];
            });

            const explanationDiv = document.getElementById(`explanation-${currentChapter}`);
            if (explanationDiv.innerHTML !== '') {
                const explanationText = question.explanation ? question.explanation[currentLang] : '';
                explanationDiv.innerHTML = `<div class="explanation-box"><strong>💡 ${currentLang === 'vi' ? 'Giải thích' : 'Explanation'}:</strong> ${explanationText}</div>`;
            }
        }
        
        function showQuizSetup(chapterId) {
            document.querySelector(`#${chapterId} .theory-view`).style.display = 'none';
            document.querySelector(`#${chapterId} .quiz-view`).style.display = 'block';
            document.querySelector(`#${chapterId} .quiz-setup`).style.display = 'block';
            document.querySelector(`#${chapterId} .quiz-container`).style.display = 'none';
            document.querySelector(`#${chapterId} .quiz-results`).style.display = 'none';
        }

        function showTheory(chapterId) {
            if(quizState[chapterId]) quizState[chapterId].isActive = false;
            document.querySelector(`#${chapterId} .theory-view`).style.display = 'block';
            document.querySelector(`#${chapterId} .quiz-view`).style.display = 'none';
        }

        function startQuiz(chapterId) {
            const allQuestions = contentData[chapterId].questions;
            const numQuestionsInput = document.getElementById(`num-questions-${chapterId}`);
            let numQuestions = parseInt(numQuestionsInput.value);
            if (isNaN(numQuestions) || numQuestions <= 0 || numQuestions > allQuestions.length) {
                numQuestions = Math.min(10, allQuestions.length);
                numQuestionsInput.value = numQuestions;
            }
            
            const questions = [...allQuestions].sort(() => 0.5 - Math.random()).slice(0, numQuestions);

            quizState[chapterId] = { questions, currentQuestionIndex: 0, score: 0, isActive: true };

            document.querySelector(`#${chapterId} .quiz-setup`).style.display = 'none';
            document.querySelector(`#${chapterId} .quiz-container`).style.display = 'block';
            document.querySelector(`#${chapterId} .quiz-results`).style.display = 'none';
            
            displayQuestion(chapterId);
        }

        function displayQuestion(chapterId) {
            const state = quizState[chapterId];
            if (state.currentQuestionIndex >= state.questions.length) {
                showResults(chapterId);
                return;
            }

            const question = state.questions[state.currentQuestionIndex];
            document.getElementById(`question-text-${chapterId}`).textContent = `(${state.currentQuestionIndex + 1}/${state.questions.length}) ${question.q[currentLang]}`;
            
            const optionsDiv = document.getElementById(`quiz-options-${chapterId}`);
            optionsDiv.innerHTML = '';
            question.o.forEach((option, index) => {
                const button = document.createElement('button');
                button.textContent = option[currentLang];
                button.onclick = () => selectAnswer(chapterId, index);
                optionsDiv.appendChild(button);
            });

            document.getElementById(`explanation-${chapterId}`).innerHTML = '';
            document.getElementById(`next-btn-${chapterId}`).style.display = 'none';
        }

        function selectAnswer(chapterId, selectedIndex) {
            const state = quizState[chapterId];
            const question = state.questions[state.currentQuestionIndex];
            const correctIndex = question.a;
            
            const options = document.querySelectorAll(`#${chapterId} .quiz-options button`);
            options.forEach(button => button.disabled = true);

            if (selectedIndex === correctIndex) {
                options[selectedIndex].classList.add('correct');
                state.score++;
            } else {
                options[selectedIndex].classList.add('incorrect');
                options[correctIndex].classList.add('correct');
                const explanationDiv = document.getElementById(`explanation-${chapterId}`);
                if(question.explanation) {
                    explanationDiv.innerHTML = `<div class="explanation-box"><strong>💡 ${currentLang === 'vi' ? 'Giải thích' : 'Explanation'}:</strong> ${question.explanation[currentLang]}</div>`;
                }
            }
            document.getElementById(`next-btn-${chapterId}`).style.display = 'inline-block';
        }

        function nextQuestion(chapterId) {
            quizState[chapterId].currentQuestionIndex++;
            displayQuestion(chapterId);
        }

        function showResults(chapterId) {
            const state = quizState[chapterId];
            state.isActive = false;
            document.querySelector(`#${chapterId} .quiz-container`).style.display = 'none';
            const resultsDiv = document.querySelector(`#${chapterId} .quiz-results`);
            resultsDiv.style.display = 'block';
            
            const scoreText = translations[currentLang].scoreText;
            document.getElementById(`score-${chapterId}`).textContent = `${scoreText} ${state.score} / ${state.questions.length} câu.`;
        }

        function askAI() {
            const activeChapter = document.querySelector('.tab-pane.active');
            const titleElement = activeChapter.querySelector('.theory-content h2');
            if (titleElement) {
                let topic = titleElement.textContent.trim();
                topic = topic.replace(/Chapter \d+:|Chương \d+:/i, '').trim();

                const promptText = currentLang === 'vi' 
                    ? `Hãy giải thích chi tiết về chủ đề sau trong môn Khoa học máy tính: "${topic}". Vui lòng giải thích các khái niệm cốt lõi, cho ví dụ minh họa và nêu bật những điểm quan trọng nhất mà sinh viên cần nắm vững.`
                    : `Please provide a detailed explanation of the following topic in Computer Science: "${topic}". Explain the core concepts, provide illustrative examples, and highlight the most important points a student needs to master.`;

                const encodedPrompt = encodeURIComponent(promptText);
                const url = `https://gemini.google.com/app?prompt=${encodedPrompt}`;
                
                window.open(url, '_blank');
            }
        }
    </script>
</body>
</html>
